# Ένας οδηγός για την Rholang

Η Rholang είναι μια νέα γλώσσα προγραμματισμού σχεδιασμένη για χρήση σε κατανεμημένα συστήματα. Όπως όλα τα νεογέννητα πράγματα, αυξάνεται και μεταβάλλεται γρήγορα. αυτό το έγγραφο περιγράφει τη σύνταξη που θα χρησιμοποιηθεί στην έκδοση Rnode-0.2.

Η Rholang είναι "προσανατολισμένη στη διαδικασία": όλοι οι υπολογισμοί γίνονται με τη μετάδοση μηνυμάτων. Τα μηνύματα μεταβιβάζονται σε "κανάλια", τα οποία μοιάζουν με ουρές μηνυμάτων αλλά συμπεριφέρονται ως σύνολα αντί για ουρές. Η Rholang είναι εντελώς ασύγχρονη, υπό την έννοια ότι ενώ μπορείτε να διαβάσετε ένα μήνυμα από ένα κανάλι και στη συνέχεια να κάνετε κάτι με αυτό, δεν μπορείτε να στείλετε ένα μήνυμα και στη συνέχεια να κάνετε κάτι εφόσον θα έχει ληφθεί --- τουλάχιστον, όχι χωρίς ρητή αναμονή ενός μηνύματος επιβεβαίωσης από τον δέκτη. Σημειώστε ότι σε αυτό το έγγραφο οι λέξεις "name" και "channel" χρησιμοποιούνται εναλλακτικά. Αυτό συμβαίνει επειδή στον rho-calculus (στον οποίο βασίζεται η Rholang) χρησιμοποιείται το όνομα του όρου, ωστόσο επειδή μπορείτε να στείλετε και να λάβετε πληροφορίες σχετικά με τα ονόματα, σημασιολογικά είναι σαν κανάλια.

## Συμβόλαια και αποστολή δεδομένων

    1 contract @"HelloWorld"(return) = {
    2   return!("Hello, World!")
    3 } |
    4 new myChannel in {
    5   @"HelloWorld"!(*myChannel)
    6 }

1) Ένα πρόγραμμα Rholang είναι μια ενιαία διαδικασία με μία ή περισσότερες ταυτόχρονες συνθέσεις. Αυτή η διαδικασία ξεκινά με τη δημιουργία ενός συμβολαίου στο όνομα `@"HelloWorld"`. Η δημιουργία του `contract` δημιουργεί μια διαδικασία που δημιουργεί ένα αντίγραφο του σώματός της κάθε φορά που λαμβάνει ένα μήνυμα. Σημειώστε ότι στη Rholang όλες οι διαδικασίες μπορούν να "αναφερθούν" με το `@` για να δημιουργήσουν ένα κανάλι. Οι χορδές είναι απλά ειδικές διαδικασίες, έτσι μπορούμε να παραθέσουμε οποιαδήποτε συμβολοσειρά για την παραγωγή ενός καναλιού.

2) Στο κανάλι επιστροφής στέλνουμε μια διαδικασία, η οποία είναι η συμβολοσειρά `"Hello, World!"`.

4) Για να δημιουργήσουμε ένα νέο, ιδιωτικό κανάλι, χρησιμοποιούμε την κατασκευή `new ... in`. Καμία άλλη διαδικασία δεν μπορεί να στείλει ή να λάβει μηνύματα μέσω αυτού του καναλιού, εκτός αν στέλνουμε ρητά αυτό το κανάλι στην άλλη διαδικασία.

5) Στέλνουμε το κανάλι `myChannel` στο συμβόλαιο στο `@"HelloWorld"`. Ο χειριστής `*` "ξεχωρίζει" ένα κανάλι για να πάρει τη βασική του διαδικασία. Στη Rholang μπορείτε μόνο να στείλετε διεργασίες μέσω καναλιών. δεν μπορείτε να στείλετε κανάλια απευθείας μέσω καναλιών. Επομένως, χρησιμοποιούμε το `*` για να μετατρέψουμε το ιδιωτικό κανάλι σε μια διαδικασία πριν από την αποστολή.

## Λήψη δεδομένων

    1 contract @"HelloAgain"(_) = {
    2   new chan in {
    3     chan!("Hello again, world!") |
    4     for (@text <- chan) { Nil }
    5   }
    6 } | @"HelloAgain"!(Nil)

1) Τα συμβόλαια λαμβάνουν τουλάχιστον μία παράμετρο, αλλά μπορούμε να την πετάξουμε δεσμεύοντας την στο wildcard `_`.

2) Δημιουργούμε ένα νέο κανάλι `chan`.

3) Στέλνουμε τη διαδικασία συμβολοσειράς `"Hello again, world!"` πάνω στο νέο κανάλι.

4) Ακούμε στο νέο κανάλι για ένα μήνυμα. Η λειτουργία `for` μπλοκάρει μέχρι να διατεθεί ένα μήνυμα στο κανάλι` chan`. Στη Rholang μπορείτε να λαμβάνετε ονόματα μόνο στα κανάλια (σημειώστε ότι αυτό διαφέρει από την αποστολή!). Η δέσμευση στην αριστερή πλευρά του `<-` στο `for` είναι στην πραγματικότητα ένα μοτίβο ονόματος. Σε αυτό το παράδειγμα το μοτίβο είναι το `@text`, το οποίο σημαίνει ότι το όνομα που λαμβάνεται είναι μια αναφερόμενη διαδικασία και θέλουμε να δεσμεύσουμε αυτή τη διαδικασία στην ελεύθερη μεταβλητή `text`. Η λειτουργία `for` είναι ακριβώς όπως ένα συμβόλαιο, εκτός του ότι διαβάζει μόνο ένα μήνυμα και στη συνέχεια γίνεται το σώμα της αντί να διαχωρίσει ένα αντίγραφο του σώματός της για κάθε μήνυμα. Σε αυτή την περίπτωση επιλέγουμε να κάνουμε τίποτα στο σώμα `for` απλά κάνοντάς το τη σταματημένη διαδικασία `Nil`, αλλά θα θέλαμε να προχωρήσουμε σε κάποια περαιτέρω επεξεργασία του `text` που περιέχεται στο `chan`.

## Μεταβλητή κατάσταση

     1 new MakeCell in {
     2   // Δημιουργεί ένα κελί στο οποίο μπορείς να αποθηκεύεις τιμές
     3   contract MakeCell(@init, get, set) = {
     4     new valueStore in {
     5       valueStore!(init) |
     6       contract get(ack) = {
     7         for(@value <- valueStore) {
     8           valueStore!(value) | ack!(value)
     9         }
    10       } |
    11       contract set(@newValue, ack) = {
    12         for(_ <- valueStore) {
    13           valueStore!(newValue) | ack!(true)
    14         }
    15       }
    16     }
    17   } |
    18   // Χρήση του κελιού.
    19   new myGet, mySet in {
    20     MakeCell!(123, *myGet, *mySet) |
    21     new ack in {
    22       myGet!(*ack) |
    23       for (@result <- ack) {
    24         //η result τώρα περιέχει την τιμή 123
    25         mySet!(456, *ack) |
    26         for (_ <- ack) {
    27           myGet!(*ack) |
    28           for (@result <- ack) {
    29             //η result τώρα περιέχει την τιμή 456
    30             Nil
    31           }
    32         }
    33       }
    34     }
    35   }
    36 }

1) Δημιουργούμε ένα νέο κανάλι MakeCell και στη συνέχεια το χρησιμοποιούμε στη γραμμή 3 ως το όνομα ενός εσωτερικού συμβολαίου. Καμία διαδικασία εκτός από τον κώδικα μέσα σε αυτό το λεξικό πεδίο δεν μπορεί να το επικαλεστεί.

3) Το συμβόλαιο «MakeCell» «MakeCell» λαμβάνει τρία ορίσματα. Το πρώτο όρισμα είναι η αρχική τιμή που πρέπει να αποθηκευτεί στο κελί. Το δεύτερο και το τρίτο όρισμα είναι κανάλια πάνω στα οποία το κελί θα λαμβάνει αιτήματα για να πάρει και να ρυθμίσει την τιμή. Σημειώστε ότι θέλουμε το πρώτο όρισμα να είναι μια διαδικασία και το δεύτερο και το τρίτο να είναι ονόματα, αλλά τα ονόματα λαμβάνονται πάντοτε μέσω καναλιών, οπότε πρέπει να κάνουμε το πρώτο όρισμα ένα μοτίβο που αρχίζει με `@` για να υποδείξει ότι το όνομα που λαμβάνουμε ως πρώτο επιχείρημα είναι μια αναφερόμενη διαδικασία και αυτή είναι η διαδικασία που θέλουμε να δεσμεσουμε στη μεταβλητή.

4) Για να αποθηκεύσουμε την τιμή, δημιουργούμε ένα νέο κανάλι. Αυτό το κανάλι θα έχει το πολύ ένα μήνυμα, το οποίο θα περιέχει την τρέχουσα τιμή του κελιού.

5) Πριν από αυτή τη γραμμή, δεν υπάρχουν μηνύματα στο κανάλι `valueStore`. Αφού στείλουμε την αρχική τιμή, είναι η μόνη τιμή σε αυτό το κανάλι.

6) Δημιουργούμε ένα συμβόλαιο για να ακούσουμε στο κανάλι `get`. Κάθε φορά που αποστέλλεται ένα μήνυμα στο `get`, το σώμα του συμβολαίου θα εκτελείται.

7) Μπλοκάρουμε έως ότου λάβουμε ένα μήνυμα από το κανάλι `valueStore`. Επειδή υπάρχει το πολύ ένα μήνυμα που περιμένει πάντα στο "valueStore", η ανάγνωση του μηνύματος συμπεριφέρεται σαν να αποκτάτε κλειδαριά.

8) Στέλνουμε εκ νέου την τρέχουσα τιμή στο `valueStore`, επιτρέποντας την επεξεργασία άλλων μηνυμάτων (π.χ. απελευθέρωση της κλειδαριάς) και στέλνουμε την τρέχουσα τιμή πίσω στον πελάτη στο κανάλι` ack`.

11) Ταυτόχρονα με τη σύμβαση `get`, τρέχουμε ένα συμβόλαιο που ακούει στο `set`.

12) Μπλοκάρουμε μέχρι να υπάρξει ένα μήνυμα στο "valueStore", στη συνέχεια το διαβάζουμε. Πετάμε το μήνυμα που διαβάσαμε.

13) Στέλνουμε τη νέα τιμή για αποθήκευση στο `valueStore` και ειδοποιούμε ότι η λειτουργία ολοκληρώθηκε.

18-36) Ο κώδικας χρήσης επιδεικνύει τη δημιουργία ενός κελιού, την εκχώρηση της αρχικής τιμής 123, τη λήψη αυτής της τιμής, τη ρύθμιση της τιμής σε 456, και έπειτα την λήψη αυτής της τιμής.

Σημειώστε τα βαθιά στρώματα της επανάκλησης. Η Rholang σχεδιάστηκε έτσι ώστε να κάνει φυσική την έκφραση των παράλληλων υπολογισμών· ως εκ τούτου, σε άλλες γλώσσες πρέπει να καταστούν σαφείς οι εξαρτήσεις δεδομένων που εμπεριέχονται στην αλληλουχία.

## Εναλλαγή και ταιριάσματα

Στον παρακάτω κώδικα, παρουσιάζουμε ένα παράδειγμα επανάληψης μέσω μιας συνδεδεμένης λίστας που υλοποιείται ως φωλιασμένα ζεύγη [head, tail].

     1 new chan, loop, iCh in {
     2   contract loop(@list, @acc, return) = {
     3     match list { 
     4       [hd, tl] => {
     5         for(@i <- iCh) {
     6           iCh!(i + 1) |
     7           match [hd == i, acc] {
     8             [true, true] => { loop!(tl, true, *return) }
     9             _ => { loop!(tl, false, *return) }
    10           }
    11         }
    12       }
    13       _ => { return!(acc) }
    14     }
    15   } |
    16   iCh!(1) |
    17   loop!([1, [2, [3, [4, []]]]], true, *chan)
    18 }

3) Η κατασκευή `match` επιτρέπει την καταστροφή μιας μεταβλητής μέσω της αντιστοίχισης μοτίβων.

4) Εάν το `list` αντιστοιχεί στο μοτίβο ενός ζεύγους head/tail τότε εκτελούμε το κύριο σώμα του βρόχου.

5) Διαβάσαμε τον τρέχοντα δείκτη από το κανάλι.

6) Αυξάνουμε το δείκτη και το ξανά αποθηκεύουμε.

7) Η λέξη-κλειδί `match` επίσης επιτρέπει την αντιστοίχιση πιο περίπλοκων εκφράσεων ενάντια στα μοτίβα.

8) Εδώ επιβεβαιώνουμε ότι η αρχή της λίστας είναι ίση με τον τρέχοντα δείκτη και ότι ο συσσωρευτής εξακολουθεί να είναι ίσος με `true` και επαναλαμβάνει αναδρομικά τον βρόχο ξανά.

13) Αν το `list` δεν συμπίπτει με το μοτίβο ζεύγους head/tail τότε ο βρόχος έχει τελειώσει και επιστρέφουμε τη συσσωρευμένη τιμή.

16) Ξεκινάμε το κανάλι ευρετηρίου.

17) Επικαλούμαι τον βρόχο με την αρχική μας λίστα.

## Χάρτες

     1 new MakeCoatCheck in {
     2   contract MakeCoatCheck(ret) = {
     3     new port, table in {
     4       ret!(*port) |
     5       for(@"new", @arg, ack <= port) {
     6         new ticket in {
     7           ack!(*ticket) |
     8           @{*ticket | *table}!(arg)
     9         }
    10       } |
    11       for(@"get", @arg, ack <= port) {
    12         for (@value <- @{arg | *table}) {
    13           @{arg | *table}!(value) |
    14           ack!(value)
    15         }
    16       } |
    17       for(@"set", @arg1, @arg2, ack <= port) {
    18         for (_ <- @{arg1 | *table}) {
    19           @{arg1 | *table}!(arg2) |
    20           ack!(true)
    21         }
    22       }
    23     }
    24   } |
    25 
    26   // Χρήση
    27   new ret, get, set in {
    28     MakeCoatCheck!(*ret) |
    29     for (cc <- ret) {
    30       // Δημιουργεί ένα νέο κελί με αρχική τιμή 0
    31       cc!("new", 0, *ret) |
    32       for (ticket <- ret) {
    33         contract get(return) = { cc!("get", *ticket, *return) } |
    34         contract set(@value, return) = { cc!("set", *ticket, value, *return) } |
    35         
    36         get!(*ret) | for(@r <- ret) {
    37           //το r ισούται με 0
    38           for(_ <- ret){
    39             set!(1, *ret) | for(_ <- ret) {
    40               get!(*ret) | for(@r <- ret) {
    41                 //το r ισούται με 1
    42                 Nil
    43               }
    44             }
    45           }
    46         }
    47       }
    48     }
    49   }
    50 }

2) Ένα μοτίβο σχεδιασμού, που χρησιμοποιείται παραπάνω στο συμβόλαιο MakeCell, είναι να λαμβάνει από τον καλούντα ένα κανάλι για κάθε διαφορετική λειτουργικότητα που μια διαδικασία παρέχει. Ένας προγραμματιστής αντικειμενοστραφούς γλώσσας μπορεί να πει ότι η MakeCell απαιτεί από τον καλούντα να παρέχει ένα κανάλι για κάθε μέθοδο. Το MakeCoatCheck χρησιμοποιεί μια πιο αντικειμενοστραφή προσέγγιση, όπως θα δούμε.

3) Δημιουργούμε ένα κανάλι `port` για αλληλεπίδραση με τον έλεγχο καθώς και ένα όνομα `table' που θα χρησιμοποιηθεί για την αποθήκευση/ανάκτηση τιμών στον έλεγχο.

4) Στέλνουμε το `port` έξω στον καλούντα, ώστε να μπορούν να αλληλεπιδρούν με τον έλεγχο.

5, 11, 17) Ορίζουμε διαφορετικές μεθόδους που μπορούν να καλούνται με την αποστολή ενός μηνύματος στο `port`. Αυτό γίνεται με τον καθορισμό αποκλειστικά αμοιβαίων μοτίβων που μπορεί να ταιριάξει το μήνυμα στο `port`, με το πρώτο στοιχείο του μηνύματος να είναι το όνομα της μεθόδου και τα επόμενα στοιχεία να είναι το(τα) όρισμα(τα) και το κανάλι επιστροφής. Χρησιμοποιώντας το βέλος `<=` αντί για το βέλος `<-`σημαίνει ότι τα `for`s "αντιγράφονται". Αυτό τους δίνει την ίδια συμπεριφορά με τα `contract`s, δηλαδή η διαδικασία ακρόασης για μηνύματα στο `port` επιμένει μετά την αναπαραγωγή ενός στιγμιότυπου του σώματός του.

8) Εκμεταλευόμαστε το ότι μπορούμε να παραθέσουμε μια διαδικασία για να δημιουργήσουμε ένα όνομα για να δημιουργήσουμε ένα μοναδικό όνομα για κάθε τιμή που θα αποθηκευτεί. Η διαδικασία `*ticket | *table`  παράγεται από την ταυτόχρονη σύνθεση των διαδικασιών που παράγονται με την απαρίθμηση των ονομάτων `ticket` και `table`. Αυτή η διαδικασία μπορεί στη συνέχεια να αναφερθεί για να σχηματίσει ένα μοναδικό όνομα που στη συνέχεια χρησιμοποιείται για την αποθήκευση της τιμής αποστέλλοντάς το στο όνομα.

## Φιλόσοφοι που δειπνούν και αδιέξοδο

     1 new philosopher1, philosopher2, north, south, knife, spoon in {
     2     north!(*knife) |
     3     south(!*spoon) |
     4     for (@knf <- north) { for (@spn <- south) {
     5         philosopher1!("Complete!") |
     6         north!(knf) |
     7         south!(spn)
     8     } } |
     9     for (@spn <- south) { for (@knf <- north) {
    10         philosopher2!("Complete!") |
    11         north(knf) |
    12         south(spn)
    13     } }
    14 }

Το πρόβλημα δείπνου των φιλοσόφων έχει δύο φιλοσόφους που μοιράζονται μόνο ένα σύνολο μαχαιροπήρουνων. Ο Philosopher1 κάθεται στην ανατολική πλευρά του τραπεζιού ενώ ο Philosopher2 κάθεται δυτικά. Κάθε ένας χρειάζεται ένα μαχαίρι και ένα κουτάλι για να φάει. Ο καθένας αρνείται να παραιτηθεί από ένα σκεύος μέχρι να χρησιμοποιήσει και τα δύο για να πάρει μια δαγκωματιά. Αν και οι δύο φιλόσοφοι πάνε να πάρουν πρώτα το σκεύος στα δεξιά τους, και οι δύο θα λιμοκτονίσουν: ο Philosopher1 παίρνει το μαχαίρι, ο Philosopher2 παίρνει το κουτάλι και κανένας απο τους δύο δεν τα ξανα αφήνει.

Ακολουθεί ο τρόπος επίλυσης του προβλήματος:

     1 new philosopher1, philosopher2, north, south, knife, spoon in {
     2     north!(*knife) |
     3     south!(*spoon) |
     4     for (@knf <- north; @spn <- south) {
     5         philosopher1!("Complete!") |
     6         north!(knf) |
     7         south!(spn)
     8     } |
     9     for (@spn <- south; @knf <- north) {
    10         philosopher2!("Complete!") |
    11         north!(knf) |
    12         south!(spn)
    13     }
    14 }

4, 9) Ο χειριστής ένωσης, σημειωμένος με ερωτηματικό `;`, δηλώνει ότι η συνέχιση πρέπει να προχωρήσει μόνο εάν υπάρχει διαθέσιμο ένα μήνυμα σε καθένα από τα κανάλια ταυτόχρονα, αποτρέποντας το παραπάνω αδιέξοδο.

## Ασφαλή σχέδια μοτίβου

Σε αυτή την ενότητα περιγράφουμε διάφορα σχέδια μοτίβου. Αυτά τα μοτίβα είναι προσαρμοσμένα από το [_A PictureBook of Secure Cooperation_](http://erights.org/talks/efun/SecurityPictureBook.pdf)  του Marc Stiegler.

### Facets

Στο συμβόλαιο MakeCell, ο πελάτης παρέχει δύο κανάλια, ένα για να πάρει την τιμή και ένα για να την ορίσει. Αν ο πελάτης περάσει μόνο το κανάλι `get` σε μια άλλη διαδικασία, αυτή η διαδικασία έχει στην πραγματικότητα μια προβολή μόνο για ανάγνωση του κελιού.

Τα κανάλια όπως το `get` και το `set` ονομάζονται "facets" της διαδικασίας. Ενσωματώνουν την εξουσία για να εκτελέσουν τη δράση. Εάν το κανάλι `set` είναι δημόσιο κανάλι όπως το`@"Foo"`, τότε όποιος μπορεί να μάθει ή ακόμα και να μαντέψει τη συμβολοσειρά `"Foo"` έχει την εξουσία να ρυθμίσει την τιμή του κελιού. Από την άλλη πλευρά, αν το κανάλι `set` δημιουργήθηκε με τον διαχειριστή `new`, τότε δεν υπάρχει τρόπος για οποιαδήποτε άλλη διαδικασία να κατασκευάσει το κανάλι `set`· πρέπει να μεταβιβαστεί απευθείας σε μια διαδικασία, προκειμένου η διαδικασία να τη χρησιμοποιήσει.

Σημειώστε ότι η απόκτηση των `get` και` set` είναι επίσης εξουσιοδοτημένη να παρεμποδίζει μηνύματα που αποστέλλονται στο κελί:

    for (@ret <- get) { P } | 
    for (@ret <- get) { Q } | 
    get!(*ack)

Αυτός ο όρος έχει δύο διαδικασίες που ακούν στο κανάλι `get` και μόνο ένα μήνυμα που στέλνεται στο `get`. Μόνο μία από τις δύο διαδικασίες θα είναι σε θέση να λάβει το μήνυμα.

Με τη λήψη καναλιών από τον πελάτη για λήψη και ρύθμιση, το συμβόλαιο MakeCell αφήνει τις αποφάσεις σχετικά με το πόσο δημόσια είναι αυτά τα κανάλια στον πελάτη. Το συμβόλαιο MakeCoatCheck, από την άλλη πλευρά, κατασκευάζει τα δικά του κανάλια και και εκθέτει τις μεθόδους στον πελάτη, οπότε είναι σε θέση να επιβάλει εγγυήσεις απορρήτου.

### Εξασθένηση των μεταφορέων

Στο συμβόλαιο MakeCoatCheck, υπάρχει μόνο ένα κανάλι και τα μηνύματα αποστέλλονται εσωτερικά. Για να έχουμε το ίδιο αποτέλεσμα ως ενα facet που μόνο για ανάγνωση, μπορούμε να δημιουργήσουμε μια διαδικασία προώθησης που απλά αγνοεί τα μηνύματα που δεν θέλει να προωθήσει. Το παρακάτω συμβόλαιο διαβιβάζει μόνο τη μέθοδο "get".

    contract MakeGetForwarder(target, ret) = {
        new port in {
            ret!(*port) |
            contract port(method, @arg, ack) = {
                method == "get" match { true => target!("get", arg, *ack) }
            }
        }
    }

### Ανάκληση

Μπορούμε να εφαρμόσουμε την ανάκληση δημιουργώντας έναν προωθητή με έναν διακόπτη kill.

     1 contract MakeRevokableForwarder(target, ret) = {
     2     new port, kill, forwardFlag in {
     3         ret!(*port, *kill) |
     4         forwardFlag!(true) |
     5         contract port(msg) = {
     6             for (@status <- forwardFlag) {
     7                 forwardFlag!(status) |
     8                 status match { true => target!(msg) }
     9             }
    10         } |
    11         for (_ <- kill; _ <- forwardFlag) {
    12             forwardFlag!(false)
    13         }
    14     }
    15 }

2) Δημιουργούμε μια πόρτα για να ακούσουμε για κλήσεις μεθόδων και ένα κανάλι `forwardFlag` για να αποθηκεύουμε το αν θα προωθήσουμε μηνύματα.

3) Επιστρέφουμε το κανάλι στο οποίο οι πελάτες στέλνουν αιτήματα και το κανάλι στο οποίο θα αποσταλεί το σήμα kill.

4) Καθορίσαμε την αρχική κατάσταση του `forwardFlag` σε true.

5-10) Διαβάζουμε σε ένα αυθαίρετο μήνυμα, παίρνουμε και αντικαθιστούμε την αξία της σημαίας. Εάν η σημαία είναι αληθής, διαβιβάζουμε το μήνυμα στο target.

11-13) Εάν ένα μήνυμα έχει ποτέ σταλεί στο κανάλι `kill`, ορίζουμε το 'forwardFlag' σε false. Στη συνέχεια η διαδικασία προώθησης σταματά την προώθηση μηνυμάτων.

### Σύνθεση

Συνδυάζοντας ένα εξασθενητικό προωθητή με ένα ανακλητό προωθητή, παίρνουμε και τα δύο χαρακτηριστικά:

    new ret in {
        MakeGetForwarder(target, ret) |
        for (@pair <- ret) {
            pair match [getOnly, kill] => {
                MakeRevokableForwarder!(getOnly, *ret) |
                for (revokableGetOnly <- ret) {
                    // give away revokableGetOnly instead of target
                    // hang onto kill for later revocation
                }
            }
        }
    }

### Πρωοθητής σύνδεσης

Ένας πρωοθητής σύνδεσης μπορεί να καταγράψει όλα τα μηνύματα που έχουν σταλεί σε ένα κανάλι, στέλνοντας τα σε ένα δεύτερο κανάλι.

    contract MakeLoggingForwarder(target, logger, ret) = {
        new port in {
            ret!(*port) |
            contract port(msg) = {
                target!(msg) |
                logger!(msg)
            }
        }
    }

### Υπευθηνότητα

Ας υποθέσουμε ότι η Alice έχει ένα κανάλι και θα ήθελε να καταγράψει την πρόσβαση του Bob σε αυτό. Ο Bob θα ήθελε να μεταβιβάσει τη χρήση αυτού του καναλιού στην Carol και να καταγράψει την πρόσβασή της. Κάθε συμβαλλόμενο μέρος είναι ελεύθερο να κατασκευάσει το δικό του προωθητή καταγραφής σχετικά με το κανάλι που έχει λάβει. Η Alice θα θέσει τον Bob υπεύθυνο για ότι κάνει η Carol.

### Σφράγισμα και αποσφράγισμα

### Sealing and unsealing

    contract MakeSealerUnsealer(ret) =  {
        new sealer, unsealer, ccRet in {
            ret!(*sealer, *unsealer) |
            MakeCoatCheck!(*ccRet) |
            for (cc <- ccRet) {
                contract sealer(@value, ret) = {
                    cc!("new", value, *ret)
                } |
                contract unsealer(@ticket, ret) = {
                    cc!("get", ticket, *ret)
                }
            }
        }
    }

Ένα ζεύγος σφραγίσματος/αποσφραγίσματος παρέχει την ίδια λειτουργικότητα με τα δημόσια κλειδιά, αλλά χωρίς κρυπτογραφία. Είναι απλώς μια εξασθένηση του ελέγχου που περιγράφεται παραπάνω. Αυτό το σχέδιο μοτίβου μπορεί να χρησιμοποιηθεί για να υπογράψει κάτι για λογαριασμό του χρήστη. Στον οδηγό για το blockchain στη Rholang, θα δούμε ότι ένα ζεύγος sealer/unsealer λειτουργεί ακόμη και ως ζεύγος κλειδιών για την υπογραφή/επαλήθευση στο blockchain επειδή δεν υπάρχουν μυστικά για αποθήκευση, μόνο τα μη πλαστογραφήσιμα ονόματα που πρέπει να παραμείνουν μη προσβάσιμα.

### Προσοχή στην αποστολή εξασθενητών

Μια βασική αρχή που πρέπει να θυμάστε με τις διαδικασίες του RChain είναι αυτή που είναι παρόμοια με τις πιο παραδοσιακές εφαρμογές ιστού: οποιοσδήποτε κώδικας στέλνετε σε κάποιον άλλον μπορεί να αποσυναρμολογηθεί. Από τα τέλη της δεκαετίας του 1990, όταν έγινε εφικτή η αγορά των πραγμάτων μέσω του διαδικτύου, [υπήρξαν πλατφόρμες ηλεκτρονικού εμπορίου](https://blog.detectify.com/2016/11/17/7-most-common-e-commerce-security-mistakes/) όπου η πλατφόρμα βασίστηκε στα προγράμματα περιήγησης των χρηστών για να στείλει τη σωστή τιμή του στοιχείου πίσω σε αυτήν. Οι συγγραφείς δεν σκέφτηκαν ότι ο χρήστης θα ανοίγε τα εργαλεία προγραμματιστών και θα άλλαζε την τιμή πριν να στείλει πίσω. Ο σωστός τρόπος για να δημιουργήσετε μια πλατφόρμα ηλεκτρονικού εμπορίου είναι να αποθηκεύσετε τις τιμές στο διακομιστή και να τις ελέγξετε εκεί.

Ας υποθέσουμε ότι ο Bob είναι πρόθυμος να εκτελέσει κάποιο κώδικα για την Alice· έχει ένα συμβόλαιο που λέει κάτι σαν "Πάρτε μια διαδικασία από αυτό το κανάλι και τρέξτε τη".

    for (p <- x) { *p }

Αυτό είναι ακριβώς σαν ένα πρόγραμμα περιήγησης ιστού να είναι πρόθυμο να εκτελέσει τον κώδικα JavaScript που παίρνει από έναν ιστότοπο. Αν η Alice στείλει στον Bob έναν εξασθενητικό μεταφορέα, ο Bob μπορεί να χρησιμοποιήσει τις παραγωγές πρότυπων αντιστοιχίας της Rholang για να διαλύσει τη διαδικασία και να αποκτήσει πρόσβαση στον υποκείμενο πόρο. Αντ 'αυτού, όπως στο παράδειγμα ηλεκτρονικού εμπορίου, η Alice πρέπει να στείλει μόνο κώδικα που διαβιβάζει τα αιτήματα στις δικές της διαδικασίες και να κάνει την εξασθένηση εκεί.

## Συμπέρασμα

Το RChain είναι μια γλώσσα σχεδιασμένη για χρήση σε blockchain, αλλά δεν έχουμε αναφέρει τίποτα για τους κόμβους, τα namespaces, τα πορτοφόλια, τα Rev και το Phlogiston, τη δομή του δικτύου ή τον Casper. Ένα προσεχές έγγραφο θα εξετάσει όλα αυτά τα θέματα και πολλά άλλα.

Ελπίζουμε ότι τα παραπάνω παραδείγματα προκαλούν την επιθυμία να γράψουμε περισσότερο κώδικα και να επιδείξουμε την ευκολία έκφρασης των ταυτόχρονων σχεδίων.
