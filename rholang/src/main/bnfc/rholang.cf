-- Top level contract declaration
DContr. Contr ::= Proc1 ;

-- Processes
PNil.     Proc4 ::= "Nil" ;
PValue.   Proc4 ::= Value;
PDrop.    Proc3 ::= "*" Chan ;
PInject.  Proc3 ::= "#" Chan ;
PLift.    Proc2 ::= Chan "!" "(" [Proc] ")" ;
PFoldL.   Proc1 ::= "sum" "(" Bind "/:" Bind ")" "{" Proc "}" ;
PFoldR.   Proc1 ::= "total" "(" Bind ":\\" Bind ")" "{" Proc "}" ;
PInput.   Proc1 ::= "for" "(" [Bind] ")" "{" Proc "}" ;
PChoice.  Proc1 ::= "select" "{" [CBranch] "}" ;
PMatch.   Proc1 ::= "match" Proc "with" [PMBranch] ;
PNew.     Proc1 ::= "new" [Var] "in" Proc1 ;
PPrint.   Proc1 ::= "print" "(" Proc ")" ;
PConstr.  Proc1 ::= Var "(" [Proc] ")" ;
PContr.   Proc1 ::= "contract" Var "(" [CPattern] ")" "=" "{" Proc "}" ;
PPar.     Proc  ::= Proc "|" Proc1 ;
separator nonempty Proc "," ;
_. Proc  ::= Proc1 ;
_. Proc1 ::= Proc2 ;
_. Proc2 ::= Proc3 ;
_. Proc3 ::= Proc4 ;
_. Proc4 ::= "{" Proc "}" ;

-- Channels
CVar.    Chan ::= Var ;
CQuote.  Chan ::= "@" Proc3 ;

-- Variable binding
InputBind.     Bind ::= CPattern "<-" Chan ;
CondInputBind. Bind ::= CPattern "<-" Chan "if" Proc ;
separator nonempty Bind ";" ;

-- Pattern match branches
PatternMatch. PMBranch ::= PPattern "=>" "{" Proc "}" ;
separator nonempty PMBranch "" ; 

-- Choice branch
Choice. CBranch ::= "case" [Bind] "=>" "{" Proc "}" ;
separator nonempty CBranch "" ;

-- Quantity
QTrue.    RhoBool   ::= "true" ;
QFalse.   RhoBool   ::= "false" ;
QBool.    Quantity7 ::= RhoBool ;
QInt.     Quantity7 ::= Integer ;
QDouble.  Quantity7 ::= Double ;
QString.  Quantity7 ::= String ;
QCPrim.   Quantity7 ::= CPrim ;
QVar.     Quantity7 ::= Var;
QMap.     Quantity7 ::= "Map()" ;
QDot.     Quantity6 ::= Quantity7 "." Var "(" [Quantity] ")" ;
QNeg.     Quantity5 ::= "-" Quantity6 ;
QMult.    Quantity4 ::= Quantity4 "*" Quantity5 ;
QDiv.     Quantity4 ::= Quantity4 "/" Quantity5 ;
QAdd.     Quantity3 ::= Quantity3 "+" Quantity4 ;
QMinus.   Quantity3 ::= Quantity3 "-" Quantity4 ;
QLt.      Quantity2 ::= Quantity2 "<" Quantity3 ;
QLte.     Quantity2 ::= Quantity2 "<=" Quantity3 ;
QGt.      Quantity2 ::= Quantity2 ">" Quantity3 ;
QGte.     Quantity2 ::= Quantity2 ">=" Quantity3 ;
QEq.      Quantity1 ::= Quantity1 "==" Quantity2 ;
QNeq.     Quantity1 ::= Quantity1 "!=" Quantity2 ;
_. Quantity  ::= Quantity1 ;
_. Quantity1 ::= Quantity2 ;
_. Quantity2 ::= Quantity3 ;
_. Quantity3 ::= Quantity4 ;
_. Quantity4 ::= Quantity5 ;
_. Quantity5 ::= Quantity6 ;
_. Quantity6 ::= Quantity7 ;
_. Quantity7 ::= "(" Quantity ")" ;
separator Quantity "," ;

-- Cryptographic primitives
QByteString. CPrim ::= ByteString ;
QText. CPrim ::= Text ;
CPQ. CPQuantity ::= "{" Quantity "}";
CPV. CPVar ::= Var ;
CPByteString. ByteString ::= "bytestring(" Quantity ")" ; -- bytestring literal in base16 encoding
CPText. Text ::= "text(" Quantity ")";
-- Secp256k1 signature primitives
CPNewKeyPairSecp256k1. Quantity ::= "secp256k1.new_key_pair" Var "in" CPQuantity ;
CPPubKeySecp256k1. Secp256k1PubKey ::= CPVar ".secp256k1.public_key" ;
CPPrvKeySecp256k1. Secp256k1PrvKey ::= CPVar ".secp256k1.private_key" ;
CPSignSecp256k1. ByteString ::= "secp256k1.sign(" Secp256k1PubKey "," ByteString ")" ;
CPVerifySecp256k1. RhoBool ::= "secp256k1.verify(" ByteString "," ByteString "," Secp256k1PrvKey ")" ;
CPBytesFromPubKeySecp256k1. ByteString ::= Secp256k1PubKey ".bytes";
CPBytesFromPrvKeySecp256k1. ByteString ::= Secp256k1PrvKey ".bytes";
CPBytesToPubKeySecp256k1. Secp256k1PubKey ::= "secp256k1.public_key(" ByteString ")" ;
CPBytesToPrvKeySecp256k1. Secp256k1PrvKey ::= "secp256k1.private_key(" ByteString ")" ;
-- DJB Ed25519 signature primitives
CPNewKeyPairEd25519. Quantity ::= "ed25519.new_key_pair" Var "in" CPQuantity;
CPPubKeyEd25519. Ed25519PubKey ::= CPVar ".ed25519.public_key" ;
CPPrvKeyEd25519. Ed25519PrvKey ::= CPVar ".ed25519.private_key" ;
CPSignEd25519. ByteString ::= "ed25519.sign(" Ed25519PubKey "," ByteString ")" ;
CPVerifyEd25519. RhoBool ::= "ed25519.verify(" ByteString "," ByteString "," Ed25519PrvKey ")" ;
CPBytesFromPubKeyEd25519. ByteString ::= Ed25519PubKey ".bytes";
CPBytesFromPrvKeyEd25519. ByteString ::= Ed25519PrvKey ".bytes";
CPBytesToPubKeyEd25519. Ed25519PubKey ::= "ed25519.public_key(" ByteString ")" ;
CPBytesToPrvKeyEd25519. Ed25519PrvKey ::= "ed25519.private_key(" ByteString ")" ;
-- DJB Curve25519 encryption primitives
CPNewKeyPairCurve25519. Quantity ::= "curve25519.new_key_pair" Var "in" CPQuantity ;
CPNewNonce. Quantity ::= "curve25519.new_nonce" Var "in" CPQuantity ;
CPPubKeyCurve25519. Curve25519PubKey ::= CPVar ".curve25519.public_key" ;
CPPrvKeyCurve25519. Curve25519PrvKey ::= CPVar ".curve25519.private_key" ;
CPNonceCurve25519. Curve25519Nonce ::= CPVar ;
CPEncryptCurve25519. ByteString ::= "curve25519.encrypt(" Curve25519PubKey "," Curve25519PrvKey "," Curve25519Nonce "," ByteString ")" ;
CPDecryptCurve25519. ByteString ::= "curve25519.decrypt(" Curve25519PubKey "," Curve25519PrvKey "," Curve25519Nonce "," ByteString ")" ;
CPBytesFromPubKeyCurve25519. ByteString ::= Curve25519PubKey ".bytes";
CPBytesFromPrvKeyCurve25519. ByteString ::= Curve25519PrvKey ".bytes";
CPBytesFromNonceCurve25519. ByteString ::= CPVar ".bytes";
CPBytesToPubKeyCurve25519. Curve25519PubKey ::= "curve25519.public_key(" ByteString ")" ;
CPBytesToPrvKeyCurve25519. Curve25519PrvKey ::= "curve25519.private_key(" ByteString ")" ;
CPBytesToNonceCurve25519. Curve25519Nonce ::= "curve25519.nonce(" ByteString ")" ;
-- hash functions
CPSha256. ByteString ::= "sha256(" ByteString ")" ;
CPKeccak256. ByteString ::= "keccak256(" ByteString ")" ;
CPBlake2b256. ByteString ::= "blake2b256(" ByteString ")" ;
-- binary to text encoding
CPBase16encode. Text ::= "base16.encode(" ByteString ")" ;
CPBase58encode. Text ::= "base58.encode(" ByteString ")" ;
CPBase64encode. Text ::= "base64.encode(" ByteString ")" ;
-- text to binary decoding
CPBase16decode. ByteString ::= "base16.decode(" Text ")" ;
CPBase58decode. ByteString ::= "base58.decode(" Text ")" ;
CPBase64decode. ByteString ::= "base64.decode(" Text ")" ;

-- Values
VQuant.   Value   ::= Quantity ;
EChar.    Value   ::= Char ;
ETuple.   Value   ::= "[" [Proc] "]" ;

-- EStruct.  Entity   ::= Struct ;
-- ECollect. Entity   ::= Collect ;
-- StructConstr. Struct ::= Var "{" [Proc] "}" ;
-- CString. Collect ::= String ;
-- EDate.    Entity   ::= Datetime ;
-- CArray.  Collect ::= Array ;
-- CList.   Collect ::= List ;

-- Variable patterns
VarPtVar.  VarPattern ::= Var ;
VarPtWild. VarPattern ::= "_" ;
separator VarPattern "," ;

-- Process patterns
PPtVal.    PPattern4 ::= ValPattern ;
PPtVar.    PPattern4 ::= VarPattern ;
PPtNil.    PPattern4 ::= "Nil" ;
PPtDrop.   PPattern3 ::= "*" CPattern ;
PPtInject. PPattern3 ::= "#" CPattern ;
PPtOutput. PPattern2 ::= CPattern "!" "(" [PPattern] ")" ;
PPtInput.  PPattern1 ::= "for" "(" [PatternBind] ")" "{" PPattern "}" ;
PPtMatch.  PPattern1 ::= "match" PPattern "with" [PatternPatternMatch] ;
PPtNew.    PPattern1 ::= "new" [VarPattern] "in" PPattern1 ;
PPtConstr. PPattern1 ::= Var "(" [PPattern] ")" ;
PPtPar.    PPattern  ::= PPattern "|" PPattern1 ;
separator PPattern "," ;
coercions PPattern 4 ;

-- Channel patterns
CPtVar.    CPattern ::= VarPattern ;
CValPtrn.  CPattern ::= ValPattern ;
CPtQuote.  CPattern ::= "@" PPattern3 ;
separator CPattern "," ;

-- Bind pattern
PtBind.   PatternBind ::= CPattern "<-" CPattern ;
separator nonempty PatternBind ";" ;

-- Pattern match branch pattern
PtBranch. PatternPatternMatch ::= PPattern "=>" "{" PPattern "}" ;
separator nonempty PatternPatternMatch "" ;

-- Value patterns

-- We only allow for constants in pattern matches
-- unlike for Procs which can have arbitrary operations
VPtStruct. ValPattern ::= Var "{" [PPattern] "}" ;
VPtTuple. ValPattern ::= "<" [PPattern] ">" ;
VPtTrue. ValPattern ::= "true" ;
VPtFalse. ValPattern ::= "false" ;
VPtInt. ValPattern ::= Integer ;
VPtDbl. ValPattern ::= Double ;
VPtNegInt. ValPattern ::= "-" Integer;
VPtNegDbl. ValPattern ::= "-" Double;
VPtStr. ValPattern ::= String ;
--VPtString. ValPattern ::=  ;
--VPtArray.  ValPattern ::=  ;
--VPtList.   ValPattern ::=  ;
separator nonempty ValPattern "," ;

-- Names and variables
token Name (upper (letter | digit | '_' | '\'' | '-' )*) ;
token Var (lower (letter | digit | '_' | '\'' | '-')*) ;
-- token Hex (('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f')*) ;

separator nonempty Var "," ;
separator nonempty Name "," ;

comment "//" ;
comment "/*" "*/" ;