# Учебник Rholang

Rholang – полнофункциональный, стандартный, полный по Тьюрингу язык программирования, построенный на -алгебре. Как и все новорожденные, оно быстро растет и быстро меняется; этот документ описывает синтаксис, который будет использоваться в версии SDK 0.1.

Rholang «ориентирован на процесс»: все вычисления выполняются посредством передачи сообщений. Сообщения передаются по «каналам», которые скорее напоминают очереди сообщений, а ведут себя как наборы, а не как очереди. Rholang полностью асинхронен в том смысле, что, хотя вы можете читать сообщение с канала и затем что-то делать с ним, вы не можете сразу отправить сообщение, а затем сделать что-то после его получения - по крайней мере, не без явно ожидаемого сообщения подтверждения от получателя.

## Контракты и отправка данных

    1 new helloWorld в {
    2 contract helloWorld (name) = {
    3 «Привет» .display (имя, «! \ N»)
    4} |
    5 helloWorld ("Джо")
    6}

1) Программа Rholang - это один процесс. Этот процесс начинается с создания нового канала с именем `helloWorld`. Чтобы создать новый, частный канал, мы используем конструкцию `new ... in`. Никакой другой процесс не может отправлять или получать сообщения по этому каналу, если мы явно не отправим этот канал другому процессу.

2) Производство `contract` создает процесс, который генерирует копию своего скелета всякий раз, когда он получает сообщение.

3) Метод `display` строки записывается в стандартную версию. Он берет список строк для печати следующего. Поэтому, чтобы это работало, сообщение `name` должно быть строкой.

5) Мы отправляем строку `` Джо`` по каналу `helloWorld`.

## Получение данных

     1 new helloAgain в {
     2   contract helloAgain (_) = {
     3      new chan в {
     4        chan («Привет, мир!») |
     5          for (текст <- chan) {
     6 text.display ("\ n")
     7}
     8}
     9} |
    10 helloAgain (Nil)
    11}

2) Контракты принимают по крайней мере один параметр, но мы можем выбросить его, привязывая его к переменной, которую мы никогда не используем.

3) Мы создаем новый канал `chan`.

4) Мы отправляем строковый процесс «Hello again!» На новый канал.

5) Мы слушаем новый канал для одного сообщения. Операция `for` блокируется до тех пор, пока на канале` chan` не появится сообщение. Операция `for` похожа на контракт, за исключением того, что она только считывает одно сообщение, а затем становится его телом вместо того, чтобы разворачивать копию своего тела для каждого сообщения.

## Mutable state

      1 new MakeCell in {
     2   // Makes a single cell in which you can store values
     3   contract MakeCell(init, get, set) = {
     4     new valueStore in {
     5       valueStore(init) |
     6       contract get(ack) = {
     7         for(value <- valueStore) {
     8           valueStore(value) | ack(value)
     9         }
    10       } |
    11       contract set(pair) = {
    12         for(_ <- valueStore) {
    13           match pair with [newValue, ack] => {
    14             valueStore(newValue) | ack(Nil)
    15           }
    16         }
    17       }
    18     }
    19   } |
    20   // Cell usage.
    21   new myGet, mySet in {
    22     MakeCell(123, myGet, mySet) |
    23     new ack in {
    24       myGet(ack) |
    25       for (result <- ack) {
    26         result.display("\n") |
    27         mySet([456, ack]) |
    28         for (_ <- ack) {
    29           myGet(ack) |
    30           for (result <- ack) {
    31             result.display("\n")
    32           }
    33         }
    34       }
    35     }
    36   }
    37 }

1) Мы создаем новый канал MakeCell, а затем используем его в строке 3 как имя внутреннего контракта. Никакой процесс, кроме кода внутри этой лексической области, не может вызвать его.

3) Контракт «MakeCell» принимает три аргумента. Первый аргумент - это начальное значение, которое должно быть сохранено в ячейке. Второй и третий аргументы - это каналы, по которым ячейка будет получать запросы для получения и установки значения.

4) Чтобы сохранить значение, мы создаем новый канал. Этот канал будет содержать не более одного сообщения, содержащего текущее значение ячейки.

5) Перед этой строкой на канале `valueStore` нет сообщений. После отправки начального значения это единственное значение на этом канале.

6) Мы создали контракт на прослушивание канала `get`. Каждый раз, когда сообщение отправляется на `get`, тело контракта будет исполнено

7) Мы блокируем, пока не получим одно сообщение из канала valueStore. Поскольку в `valueStore` есть сообщение не более одного сообщения, чтение сообщения ведет себя так же, как получение блокировки.

8) Мы снова отправляем текущее значение в `valueStore`, позволяя обрабатывать другие сообщения, и мы отправляем текущее значение клиенту на канал` ack`.

11) Параллельно с контрактом `get` мы запускаем контракт, прослушивающий` set`.

12) Мы блокируем, пока не появится сообщение «valueStore», а затем прочитайте его. Мы отбрасываем сообщение, которое мы читаем.

13) Операция `match` выполняет деструктурирование связывания, разбивая« пару »кортежа на свои компоненты и присваивая им имена.

14) Мы отправляем новое значение для хранения на `valueStore` и сигнализируем, что операция завершена.

21-36). Код использования демонстрирует создание ячейки, назначение начального значения 123, получение и печать этого значения, установка значения до 456, а затем получение и печать этого значения.

Обратите внимание на глубокие уровни обратного вызова. Rholang был разработан, чтобы сделать параллельные вычисления естественными для выражения; как следствие, зависимости данных, подразумеваемые в последовательности на других языках, должны быть ясными.

## Итерация и сопоставление

В приведенном ниже коде `iterate` сначала отправляет канал` next` над `iterator`, а затем для каждого сообщения, полученного на` next`, отправляет пару, содержащую следующий элемент в списке, и выполняется ли итерация.

      1 new iterator, iterate in {
     2     contract iterate(list, iterator) = {
     3         new next, right in {
     4             iterator(next) |
     5             for (_ <- next) {
     6                 contract right(pair) = {
     7                     match pair with [i, limit] => {
     8                         iterator([list.nth(i), i < limit]) |
     9                         for (_ <- next) {
    10                             match i + 1 < limit with true => {
    11                                 right([i + 1, limit]) 
    12                             }
    13                         }
    14                     }
    15                 } |
    16                 right([0, list.size()])
    17             }
    18         }
    19     } |
    20     // Invoke the iterator contract on channel
    21     iterate([4,5,6], iterator) |
    22     
    23     // Interacts with the iterator
    24     for (next <- iterator) {
    25         next(Nil) |
    26         new left in {
    27             contract left(_) = {
    28                 for (pair <- iterator) {
    29                     match pair with [v, keepGoing] => {
    30                         v.display("\n") |
    31                         match keepGoing with true => { 
    32                             next(Nil) |
    33                             left(Nil) 
    34                         }
    35                     }
    36                 }
    37             } |
    38             left(Nil)
    39         }
    40     }
    41 }

7) Конструкция `match .. with` позволяет деструктурировать bind.

8) Метод «nth» на кортежах позволяет извлекать отдельные элементы.

16) Кортежи имеют метод `size`.

## Карты

     1 new MakeCoatCheck in {
     2     contract MakeCoatCheck(ret) = {
     3         new port, mapStore in {
     4             mapStore(Map()) |
     5             ret(port) |
     6             contract port (method, ack, arg1, arg2) = {
     7                 match method with
     8                 "new" => {
     9                     for (map <- mapStore) {
    10                         new ticket in {
    11                             map.insert(ticket, arg1) |
    12                             mapStore(map) |
    13                             ack(ticket)
    14                         }            
    15                     }
    16                 }
    17                 "get" => {
    18                     for (map <- mapStore) {
    19                         mapStore(map) |
    20                         ack(map.get(arg1))
    21                     }
    22                 }
    23                 "set" => {
    24                     for (map <- mapStore) {
    25                         map.insert(arg1, arg2) |
    26                         mapStore(map) |
    27                         ack(Nil)
    28                     }
    29                 }
    30             }
    31         }
    32     } |
    33 
    34     // Usage
    35     new ret in {
    36         MakeCoatCheck(ret) |
    37         for (cc <- ret) {
    38             // Creates new cell with initial value 0
    39             cc("new", ret, 0, Nil) |
    40             for (ticket <- ret) {
    41                 // Sets the cell to 1
    42                 cc("set", ret, ticket, 1) |
    43                 for (ack <- ret) {
    44                     // Reads the value
    45                     cc("get", ret, ticket, Nil) |
    46                     for (storedValue <- ret) {
    47                         // Prints 1
    48                         storedValue.display("\n")
    49                     }
    50                 }
    51             }
    52         }
    53     }

2) Один шаблон проектирования, используемый в контракте MakeCell выше, заключается в том, чтобы получать от вызывающего канала канал для каждой разной функции, предоставляемой процессом. Объектно-ориентированный программист может сказать, что MakeCell требует, чтобы вызывающий абонент предоставил канал для каждого метода. Матчи выполняются в порядке, указанном в коде; если совпадение не происходит, блок `match` оценивает процесс` Nil`. Как мы увидим, MakeCoatCheck использует более объектно-ориентированный подход.

3-4) Каждая проверка пальто имеет свою собственную изменчивую реентеративную карту, в которой хранятся предметы. Мы храним недавно построенную карту на mapStore. Он имеет следующий API:

    insert(key, value)
    insertMany(key1, val1, key2, val2, ..., keyn, valn)
    getOrElse(key, default)
    get(key)

6) Мы ожидаем четыре аргумента каждый раз; мы могли бы также ожидать один кортеж и использовать связывание деструктурирования для отправки на основе как метода, так и длины кортежа.

## Обеденные философы и тупик

     1 new north, south, knife, spoon in {
     2     north(knife) |
     3     south(spoon) |
     4     for (knf <- north) { for (spn <- south) {
     5         "Philosopher 1 Utensils: ".display(knf, ", ", spn, "\n") |
     6         north(knf) |
     7         south(spn)
     8     } } |
     9     for (knf <- north) { for (spn <- south) {
    10         "Philosopher 2 Utensils: ".display(knf, ", ", spn, "\n") |
    11         north(knf) |
    12         south(spn)
    13     } }
    14 }

Проблема столовых философов состоит из двух философов, которые разделяют только один набор серебра. Философ1 сидит на восточной стороне стола, а Философ 2 сидит на западе. Каждому нужны как нож, так и вилка, чтобы поесть. Каждый из них отказывается отказаться от посуды, пока не воспользуется им первый. Если оба философа достигают первым  посуды по правую руку, оба голодают: Философ1 получает нож, Философ2 получает вилку и никуда не отпускает.
Проблема столовых философов состоит из двух философов, которые разделяют только один набор серебра. Философ1 сидит на восточной стороне стола, а Философ 2 сидит на западе. Каждому нужны как нож, так и вилка, чтобы поесть. Каждый из них отказывается отказаться от посуды, пока не воспользуется им первый. Если оба философа достигают первым  посуды по правую руку, оба голодают: Философ1 получает нож, Философ2 получает вилку и никуда не отпускает.

Вот как решить проблему:

     1 new north, south, knife, spoon in {
     2     north(knife) |
     3     south(spoon) |
     4     for (knf <- north; spn <- south) {
     5         "Philosopher 1 Utensils: ".display(knf, ", ", spn, "\n") |
     6         north(knf) |
     7         south(spn)
     8     } |
     9     for (spn <- south; knf <- north) {
    10         "Philosopher 2 Utensils: ".display(knf, ", ", spn, "\n") |
    11         north(knf) |
    12         south(spn)
    13     }
    14 }

4, 9). Оператор объединения, обозначенный точкой с запятой `;`, объявляет, что продолжение должно наступить только в том случае, если есть сообщение, доступное на каждом из каналов одновременно, предотвращая тупик выше.

## Безопасные шаблоны проектирования

В этом разделе мы описываем несколько шаблонов проектирования. Эти шаблоны адаптированы из «PictureBook of Secure Cooperation» от Марка Штиглера (http://erights.org/talks/efun/SecurityPictureBook.pdf).

### Границы

В контракте MakeCell клиент предоставляет два канала: один для получения значения и один для его настройки. Если клиент затем передает только канал `get` в другой процесс, этот процесс имеет доступ к просмотру ячейки только для чтения.

Такие каналы, как `get` и` set`, называются «гранями» процесса. Они инкапсулируют полномочия для выполнения действия. Если канал `set` является общедоступным каналом, например` @ "Foo", то любой, кто может узнать или даже угадать строку `` Foo ``, имеет право устанавливать значение ячейки. С другой стороны, если канал `set` был создан с помощью оператора` new`, тогда нет никакого способа для любого другого процесса построить канал `set`; он должен быть передан процессу непосредственно, чтобы процесс мог его использовать.

Обратите внимание: если `get` и` set` не создаются как половинки iopairs, то владение этими каналами также является полномочием перехватывать сообщения, отправленные в ячейку:

    for (ret <- get) { P } | 
    for (ret <- get) { Q } | 
    get(ack)

Этот термин имеет два процесса, прослушивающих канал `get` и одно сообщение, отправленное через` get`. Только один из двух процессов сможет получить сообщение.

Принимая каналы от клиента для получения и настройки, контракт MakeCell оставляет решения о том, как публичные эти каналы принадлежат клиенту. Контракт MakeCellFactory, с другой стороны, создает свои собственные каналы и возвращает их клиенту, поэтому он в состоянии обеспечить гарантии конфиденциальности.

### Аттенюирующие форвардеры

В контракте MakeCellFactory есть только один канал, и сообщения отправляются внутренне. Чтобы получить тот же эффект, что и факс для чтения, мы можем создать процесс пересылки, который просто игнорирует любые сообщения, которые он не хочет пересылать. Контракт ниже только направляет метод «получить».

    contract MakeGetForwarder(target, ret) = {
      new port in {
            ret(port) |
            contract port(tuple) = {
                tuple.nth(0) match with "get" => target(tuple)
            }
        }
    }

### Отзыв

Мы можем реализовать аннулирование, создав переадресацию с помощью переключателя kill.

     1 contract MakeRevokableForwarder(target, ret) = {
     2     new port, kill, forwardFlag in {
     3         ret(port, kill) |
     4         forwardFlag(true) |
     5         contract port(tuple) = {
     6             for (status <- forwardFlag) {
     7                 forwardFlag(status) |
     8                 match status with true => { target(tuple) }
     9             }
    10         } |
    11         for (_ <- kill; _ <- forwardFlag) {
    12             forwardFlag(false)
    13         }
    14     }
    15 }

2) Мы создаем порт для прослушивания вызовов методов и канала `forwardFlag` для хранения сообщений о пересылке.

3) Мы возвращаем канал, по которому клиенты отправляют запросы и канал, на который нужно отправить сигнал об ошибке.

4) Мы устанавливаем начальное состояние `forwardFlag` в true.

5-10). Мы читаем в произвольном наборе частей сообщения и получаем и заменяем значение флага. Если флаг является истинным, мы пересылаем кортеж сообщения `target`.

11-13) Если сообщение отправляется по каналу `kill`, мы устанавливаем` forwardFlag` в false. Процесс пересылки затем останавливает отправку сообщений.

### Состав

Объединив аттенюирующий форвардер с обожаемым форвардером, мы получим обе функции:

    new ret in {
        MakeGetForwarder(target, ret) |
        for (pair <- ret) {
            match pair with [getOnly, kill] => {
                MakeRevokableForwarder(getOnly, ret) |
                for (revokableGetOnly <- ret) {
                    // give away revokableGetOnly instead of target
                    // hang onto kill for later revocation
                }
            }
        }
    }

### Logging forwarder

Перевозчик протоколирования может записывать все сообщения, отправленные по каналу, эхом их на второй канал.

    contract MakeLoggingForwarder(target, logger, ret) = {
        new port in {
            ret(port) |
            contract port(tuple) {
                target(tuple) |
                logger(tuple)
            }
        }
    }

### Подотчетность

Предположим, что у Алисы есть канал и вы хотите зарегистрировать доступ Боба к нему. Боб хотел бы делегировать использование этого канала Кэрол и зарегистрировать ее доступ. Каждая сторона может свободно создавать свой собственное перемещение по каналу, который они получили. Алиса будет держать Боба ответственным за все, что делает Кэрол.

### Закрытие и разблокировка

    contract MakeSealerUnsealer(ret) =  {
        new sealer, unsealer, ccRet in {
            ret(sealer, unsealer) |
            MakeCoatCheck(ccRet) |
            for (cc <- ccRet) {
                contract sealer(value, ret) = {
                    cc("new", ret, value, Nil)
                } |
                contract unsealer(ticket, ret) = {
                    cc("get", ret, ticket, Nil)
                }
            }
        }
    }

Пара закрытия / разблокировки дает ту же функциональность, что и открытые ключи, но без криптографии. Это просто затухание проверки , описанной выше. Этот шаблон дизайна может использоваться для подписи чего-либо от имени пользователя. В учебном блоке Rholang blockchain мы увидим, что он даже работает над блокчейном, потому что нет никаких секретов для хранения, причем только неприемлемые имена остаются недоступными.
Пара закрытия / разблокировки дает ту же функциональность, что и открытые ключи, но без криптографии. Это просто затухание проверки пальто, описанной выше. Этот шаблон дизайна может использоваться для подписи чего-либо от имени пользователя. В учебном блоке Rholang blockchain мы увидим, что он даже работает над блокчейном, потому что нет никаких секретов для хранения, причем только неприемлемые имена остаются недоступными.

### Остерегайтесь отправки ключей

Основным принципом, который следует учитывать при работе с процессами RChain, является тот, который похож на более традиционные веб-приложения: любой код, который вы отправляете другой стороне, может быть разобран. С конца 1990-х годов стало возможным покупать вещи через Интернет, [были платформы для электронной коммерции] (https://blog.detectify.com/2016/11/17/7-most-common-e-commerce-security-errors/ ), когда платформа полагалась на браузеры пользователей, чтобы отправить правильную цену товара обратно. Авторы не думали о том, что пользователь открывает инструменты разработчика и меняет цену, прежде чем ее отправят обратно. Правильный способ создания платформы электронной коммерции - хранить цены на сервере и проверять их там.

Предположим, что Боб готов запустить код для Алисы; у него есть контракт, который говорит что-то вроде: «Получить процесс с этого канала и запустить его».

    for (p <- x) { *p }

Это похоже на то, что веб-браузер хочет запустить код JavaScript, который он получает с веб-сайта. Если Алиса даст разрешение Бобу,то он может использовать образцы, соответствующие образцу в Rholang, чтобы разделить процесс и получить доступ к базовому ресурсу. Вместо этого, как и в примере с электронной коммерцией, Алисе следует отправлять только код, который пересылает запросы к ее собственным процессам и делает сохранение там.

## Вывод

RChain - это язык, предназначенный для использования в блокчейне, но мы ничего не упомянули об узлах, пространствах имен, кошельках, Rev и phlogiston, сетевой структуре или Casper. В предстоящем документе будут рассмотрены все эти вопросы и многое другое.

Мы надеемся, что предыдущие примеры пробуждают желание написать больше кода и продемонстрировать легкость выражения многозадачных  проектов.
