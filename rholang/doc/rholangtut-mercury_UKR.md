# Rholang посібник

Rholang - це нова мова програмування, призначена для використання в розподілених системах. Як і всі новонароджені речі, вона зростає і швидко змінюється; цей документ описує синтаксис, який буде використовуватися в релізі Mercury.

Rholang є "орієнтованою на процес": всі обчислення здійснюються шляхом передачі повідомлення. Повідомлення передаються на "канали", які швидше нагадують черги повідомлень, але ведуть себе як набори, а не черги. Rholang повністю асинхронний, в тому сенсі, що доки ви не прочитаєте повідомлення з каналу, а потім зробите щось із ним, ви не зможете відправити повідомлення, а потім зробити щось, щойно воно буде отримане---принаймні, не без явного очікування підтвердження від отримувача.

## Контракти, відображення та надсилання даних

    1 contract @"HelloWorld"(system) = {
    2     system!("print", "Hello, world!")
    3 }

1) В Інтернеті сервери мають IP-адреси. Система доменних імен (DNS) відображає алфавітно-цифрові рядки в номери, наче в телефонній книзі. Замість використання чисел чи рядків, Rholang є "рефлексивною": всі канали називаються серійним процесом. Всі серіалізації процесів починаються з `@`. Цей контракт прослуховує повідомлення, надіслані у канал, названий серіалізацією строкового процесу `"HelloWorld"`. Щоб бути більш стислими, ми кажемо: "Цей контракт прослуховує ім'я `@"HelloWorld"`."

У договорі оголошується API, за допомогою якого інші процеси можуть взаємодіяти з ним. Усі договори верхнього рівня мають однаковий API: вони мають один аргумент, канал для процесу `system`. Процес `system` містить імена всіх каналів, які можуть викликати побічні ефекти на вузол. Це вбудований процес, який слухає повідомлення, що складаються з імені методу та деяких аргументів.

2) Оператор знаку оклику видає повідомлення праворуч через свій канал ліворуч. Кожне повідомлення - це набір імен. Якщо ми надсилаємо процес замість імені, він автоматично отримує серійний номер у назву.

У цьому випадку ми надсилаємо повідомлення, що складається з двох процесів, рядок "print" та рядок `"Hello, world!"`. Процес `system` - це вбудований процес, який прослуховує повідомлення, що складаються з імені методу та деяких аргументів; в цьому випадку процес повторює другий аргумент до стандартного виводу.

## Нові канали, отримання даних та патерни

    1 contract @"HelloAgain"(system) = new chan in {
    2     chan!("Hello again, world!") |
    3     for (@text <- chan) system!("print", text)
    4 }

1) Для створення нового приватного каналу ми використовуємо конструкцію `new ... in`. Жоден інший процес не може надсилати та отримувати повідомлення через цей канал, якщо ми не відсилаємо цей канал на інший процес.

2) Ми відправляємо рядок процесу `"Hello again, world!"` через новий канал.

3) Ми слухаємо новий канал для повідомлення. Операція `for` блокується, доки у каналі `chan` не з'явиться повідомлення.

Мова патернів (також відома як "просторові типи даних") включає в себе мови процесів та імен. Кожен процес із вільними змінними - це патерн, який відповідає процесу з тією ж структурою; вільні змінні зв'язуються з підпрограмами в такому положенні. У рядку 3 ми очікуємо кортеж з одним елементом. Цей елемент - це серіалізація деякого процесу, і тому починається з `@`. Оскільки ми відправили рядок на рядок 2, вільна змінна `text` прив'язується до цього строкового процесу. Нарешті, рядок 3 пересилає цю строку до процесу `system` для друку.

Пізніше ми розглянемо деякі інші особливості патернів.

## Мутабельність, реплікація та вибір

     1 contract @"CellDemo"(system) = new MakeCell in {
     2     // Makes a single cell in which you can store values
     3     contract MakeCell(@init, get, set) = new valueStore in {
     4         valueStore!(init) |
     5         for (@value <= valueStore) {
     6             select {
     7                 ack <- get => valueStore!(value) | ack!(value)
     8                 @newValue, ack <- set => valueStore!(newValue) | ack!()
     9             }
    10         }
    11     } |
    12 
    13     // Cell usage.
    14     new myGet, mySet in {
    15         MakeCell(123, *myGet, *mySet) |
    16         new ack in {
    17             myGet!(*ack) |
    18             for (@result <- ack) {
    19                 system!("print", result, *ack) |
    20                 for (_ <- ack) {
    21                     mySet!(456, *ack) |
    22                     for (_ <- ack) {
    23                         myGet!(*ack) |
    24                         for (@result <- ack) {
    25                             system!("print", result)
    26                         }
    27                     }
    28                 }
    29             }
    30         }
    31     }
    32 }

1) Ми створюємо новий канал MakeCell, а потім використовуємо його в рядку 3 як назву внутрішнього контракту. Ніякий процес, крім коду в контракті `@"CellDemo"` не може його викликати.

3) Контракт `MakeCell` приймає три аргументи. Перший аргумент - це процес, початкове значення якого слід зберігати в ячійці. Другий та третій аргументи - це канали, через які ячійка отримуватиме запити, щоб отримати та встановити значення. Ті, хто знайомий з C++, можуть подумати про канали, приблизно еквівалентні покажчикам у тому сенсі, що покажчик - тип серійного виводу, який позначає розташування. Оператор `@` у цьому контексті приблизно еквівалентний `&`, який позначає передачу параметрів за посиланням; змінна `init` прив'язується до процесу замість каналу. У C++ для перетворення вказівника на посилання використовується оператор `*`; Аналогічним чином, в Rholang для перетворення каналу в процес, ми використовуємо оператор `*`. Оскільки ми можемо надсилати лише процеси по каналу, оператор `*` використовується дуже часто; див. непарні рядки в прикладі використання.

Щоб зберегти значення, ми створюємо новий канал. Цей канал матиме щонайбільше одне повідомлення, що містить поточне значення ячійки.

4) Перед цим рядком у каналі `valueStore` немає повідомлень. Після того, як ми надішлемо початкове значення, це буде єдиним значенням цього каналу.

5) Паралельно з 4, ми намагаємося прочитати з `valueStore`. Подвійна стрілка говорить, що як тільки ми отримаємо повідомлення на цьому каналі, ми повинні негайно створити копію процесу відразу після `for` і розпочати спроби прочитати на цьому каналі.

Після того, як повідомлення стає доступним, ми зв'язуємо змінну `value` з процесом у повідомленні.

6-8) Ключове слово `select` у рядку 6 означає, що тільки одна з гілок у рядках 7 або 8 зможе виконатись. На цьому етапі немає повідомлення, що чекає у каналі `valueStore`.

Якщо у каналі з'явилось повідомлення `get`, тоді може зпрацювати гілка у рядку 7. Змінна `ack` прив'язується до повідомлення, а потім паралельно відбуваються дві речі: значення, яке ми читаємо, знову надсилається на `valueStore`, а також надсилається у канал `ack`.

Повідомлення - це кортежі імен. Усі повідомлення, які ми бачили до цих пір, мали арність 1, але тут, у рядку 8, ми чекаємо на повідомлення з арністю 2. Перша частина патерну пов'язує змінну `newValue` з першою частиною повідомлення, а друга частина патерну пов'язує змінну `ack` із каналом. Замість відправлення `value` на `valueStore`, як ми зробили у рядку 7, ми відправляємо `newValue`.

Також у рядку 8 ми надсилаємо повідомлення з артиксом 0. У прикладі використання рядку 20 та 22 використовують символ підкреслення для отримання цього порожнього повідомлення та відкидають його.

9) На даний момент у каналі `valueStore` з'являється рівно одне повідомлення.

13-31) Код використання демонструє створення ячійки, присвоюючи початкове значення 123, отримуючи та друкуючи це значення, встановлюючи значення до 456, потім отримуючи та друкуючи це значення.

Зверніть увагу на глибокі шари зворотнього виклику. Rholang була розроблена, щоб зробити паралельні обчислення природними для експресії; як наслідок, залежність даних, що вживаються у послідовності в інших мовах, повинні бути явними.

## Ітерація

    1 contract @"IterateDemo"(system) = new chan in {
    2     [1,2,3].iterate(chan) |
    3     for (@num, ack << chan) system!("print", num, *ack)
    4 }

2) Дужки позначають список. Списки мінливі, а кортежі, позначені круглими дужками, ні. Деякі процеси, як і ті, що підтримуються об'єктами Java, мають методи; Тут метод `iterate` викликається каналом для ітерації.

3) Оператор `<<` вказує на "послідовне відправлення", або іншими словами, що повідомлення від chan потребують підтвердження перед тим, як нові повідомлення будуть відправлені.

Метод `print` - це метод системного процесу, що може приймати один або два аргументи. У випадку з двома параметрами, другий аргумент - це канал, на який буде надсилатись підтвердження після завершення друку. Метод `iterate` отримує таке підтвердження та надсилає наступне повідомлення. Після того, як список заавершить ітерацію, рядок 3 перетвориться на процес `Nil`, який нічого не робить і збирає сміття.

## Параметри узгодження патернів та інших параметрів

     1 contract @"CoatCheckDemo"(system) = new MakeCoatCheck in {
     2     contract MakeCoatCheck(ret) = {
     3         new (portIn, portOut):iopair, table in {
     4             ret!(*portOut) |
     5             for (@method, ack, ...@rest <= portIn) {
     6                 match method {
     7                     case "new" => match rest {
     8                         case (initialValue) => new ticket in {
     9                             ack!(*ticket) |
    10                             @(*ticket | *table)!(initialValue)
    11                         }            
    12                     }
    13                     case "get" => match rest {
    14                         case (ticket) => {
    15                             for (@value <! @(*ticket | *table)) {
    16                                 ack!(value)
    17                             }
    18                         }
    19                     }
    20                     case "set" => match rest {
    21                         case (store, @newValue) => {
    22                             for (_ <- @(*ticket | *table)) {
    23                                 @(*ticket | *table)!(newValue) |
    24                                 ack!()
    25                             }
    26                         }
    27                     }
    28                 }
    29             }
    30         }
    31     } |
    32 
    33     // Usage
    34     new ret in {
    35         MakeCoatCheck(ret) |
    36         for (cc <- ret) {
    37             // Creates new cell with initial value 0
    38             cc!("new", *ret, 0) |
    39             for (ticket <- ret) {
    40                 // Sets the cell to 1
    41                 cc!("set", *ret, *ticket, 1) |
    42                 for (ack <- ret) {
    43                     // Reads the value
    44                     cc!("get", *ret, *ticket) |
    45                     for (@storedValue <- ret) {
    46                         // Prints 1
    47                         system!("print", storedValue)
    48                     }
    49                 }
    50             }
    51         }
    52     }
    53 }

2) Один патерн проектування, що використовується у вищезазначеному контракті MakeCell, полягає в тому, щоб отримати від викликаючого об'єкта канал для кожної окремої частини функціональності, яку забезпечує процес. Об'єктно-орієнтований програміст може сказати, що MakeCell вимагає, щоб викликаючий об'єкт надав канали для кожного методу. Спроби виконуються у порядку, який вони відображають в коді; якщо не відбувається відповідність, блок `match` оцінюється як процес `Nil`.

3) MakeCoatCheck використовує більш об'єктно-орієнтований підхід. Конструкція `(in, out):iopair` дозволяє створити поєднану пару каналів. Це помилка типу надіслати повідомлення через канал `in` або отримати повідомлення через канал `out`. Проте будь-яке повідомлення, надіслане через канал `out`, може бути отримано через канал `in`. Це дозволяє нам повернути канал `out`, на якому можна здійснювати "виклики методу", не дозволяючи іншим процесам перехоплювати запити, призначені для нашого процесу.

Новий канал `table` буде використовуватися для створення каналів для внутрішнього використання.

5) Ми неодноразово читали у повідомленнях будь-якої арності, більшої або рівної двом. Змінна `method` прив'язана до першого аргументу; ми очікуємо рядок, який називає метод, подібно до системного процесу. Змінна `ack` зв'язується з каналом, на який ми надішлемо будь-який результат виклику методу. Змінна `rest` прив'язана до кортежу, що містить решту частин повідомлення.

6) Конструкція `match ... case` дозволяє зібрати патерн співпадаючий із структурою процесу. Ми використовуємо це для відправлення повідомлень.

7-12) Якщо метод `method` - це рядок `"new"`, то у рядку 8 ми припускаємо, що `rest` буде кортежем з одним елементом, початковим значенням. Ми створюємо канал `ticket` і повертаємо його за допомогою каналу `ack`. Ми також об'єднуємо процеси `*ticket` з `*table` у новий процес, а потім отримуємо назву каналу від них. Оскільки тільки ми маємо доступ до таблиці `table`, тільки ми і можемо маніпулювати даними, що зберігаються у каналах, побудованих таким чином. Канал `ticket` (квиток) поводиться як повернений квиток для перевіреного  шару, а канал `@(*ticket | *table)` - це запис таблиці, вказаний цією клавішею.

13-19) Якщо метод `method` - це рядок `"get"`, то ми приймаємо, що у рядку 14 `rest` буде кортежем з одним елементом, конкретниv квитком для отримання елемента. Оператор `<!` зчитує значення зі стовпця та негайно повертає його; це,

    for (y <! x) { P }

це cинтаксичний цукор для

    for (y <- x) { x!(*y) | P }.

20-27) Якщо `method` - це рядок `"set"`, тоді ми вважаємо, що у рядку 21 `rest` буде кортежем з двома елементами: ключем і новим значенням. Рядок 22 викидає поточне значення на цей квиток, рядок 23 надсилає нове значення, а рядок 24 - сигнали про те, що це зроблено.

## Обробка помилок

     1 for (@info, ret, err <- channel) {
     2     // Either return a result on ret or an error on err
     3 } |
     4 select {
     5     result <- ret => {
     6         // Process result
     7     }
     8     // Messages on err that don't fit this pattern
     9     // aren't intercepted here.
    10     @"TypeError", msg <- err => {
    11         // Handle type error
    12     }
    13 }

1-3) Ми можемо вказати кілька каналів, через які дані можуть бути відправлені назад клієнту.

4) У цьому контексті `select` поводиться майже так само, як і `try` в інших мовах. Тільки один з одержувачів у рядках 5 та 10 зможе виконатись; вони перебувають в стані гонитви, щоб побачити, хто отримає повідомлення першим. Якщо рядки 1-3 мають інваріант, що або є результатом надсилання на `ret`, або помилкою на `err`, то гонитви не відбудеться. Якщо, з іншого боку, ми хочемо надіслати як результат, так і помилку, ми повинні використовувати `for`:

    for (@info, ret, err <- channel) {
        // Either return a result on ret or an error on err
    } |
    for(result <- ret) {
        // Process result
    } |
    for(@"TypeError", msg <- err) {
        // Handle type error
    }

10) Шаблон тут складніший ніж т, що ми бачили раніше. Тут ми вказуємо, що ми хочемо тільки повідомлення з двома іменами, а ім'я повинно бути серіалізацією рядка `"TypeError"`. Якщо це щось інше, ця гілка не буде продовжуватись.

## Взаємне блокування філософів, що обідають

     1 new north, south, knife, fork in {
     2     north!(knife) |
     3     south!(fork) |
     4     for (knf <- north) for (frk <- south) {
     5         philosopher1!(knf, frk)
     6     } |
     7     for (frk <- south) for (knf <- north) {
     8         philosopher2!(knf, frk)
     9     }
    10 }

У проблемі філософів, що обідають, є два філософи, які поділяють лише один набір столового срібла. Перший Philosopher1 сидить на східній (east) стороні столу, а другий Philosopher2 сидить на західній (west). Кожен має потребу в ножі та виделці, щоб поїсти. Кожен не бажає відмовлятися від посуду, поки він не використає обидва предмети для своєї вечері. Якщо обидва філософа використають спочатку предмет посуду з правого боку від себе, то обидва голодуватимуть: Philosopher1 отримає ножа, а Philosopher12 отримає виделку, і ніхто з них не поступиться.

Ось як вирішити проблему:

     1 new north, south, knife, spoon in {
     2     north!(knife) |
     3     south!(spoon) |
     4     for (knf <- north; spn <- south) {
     5         philosopher1!(knf, spn)
     6     } |
     7     for (spn <- south; knf <- north) {
     8         philosopher2!(knf, spn)
     9     }
    10 }

4, 7) Приєднаний оператор, позначений крапкою з комою `;`, оголошує, що продовження слід виконати, лише якщо одночасно є повідомлення, доступне для кожного з каналів, запобігаючи виникненню взаємного блокування вище.

## Вбудовані типи, постійне надсилання, логічні сполучники та фільтрація

Ми бачили, що патерни, які ми можемо використовувати в конструкції `match` або в конструкції `for`, включають процеси з вільними змінними. Ми також можемо використовувати патерни, що описують вбудовані процеси. Патерн `Integer`описує всі 32-розрядні цілі числа; аналогічно для `Double`,`String` та `Boolean`.

Ми можемо об'єднати патерни за допомогою логічних сполучників AND, OR та NOT, позначаючи `&&`, `||` та `~`, відповідно.

    for (@(x && Integer) <- y) { P }

Цей процес пов'язує змінну процесу `x` з повідомленням, отриманим у `y`, але також наполягає на тому, що `x` це ціле число.

Існує американська загадка, яка говорить: "Як ви отримаєте п'ятнадцять центів решти, коли одна монета не нікель, а інша - не дайм?" Нікель вартує п'ять центів, а дайм вартує десять. Припустимо, що у нас є наступні повідомлення, надіслані на `coins` (монети), в які закодовані доступні види американських монет вартістю менше п'ятнадцяти центів:

    coins!!(1) | coin!!(5) | coin!!(10)

Оператор `!!` означає, що повідомлення повинні залишатися у каналі назавжди і не використовуватися при отриманні конструкцією `for`.

    new x in { x!!("Hi there!") | for (msg <= x) { system!("print", msg) } }

Наведений вище процес друкуватиме "Hi there!" поки працює віртуальна машина.

Ми можемо закодувати загадку як

    for (@(x && ~5) <- coins; @(y && ~10) <- coins if x+y == 15) {
        system!("print", (x, y))
    }

Перший патерн `@(x && ~5)` відповідатиме будь-якому повідомленню в `coins`, яке не дорівнює 5, і прив'язує до нього `x`; аналогічним чином, другий патерн `@(y && ~10)` відповідатиме будь-якому повідомленню в `coins`, яке не дорівнює 10, і прив'язує до нього `y`. Параметр `if` у конструкції `for` дозволяє задовольнити умови, тільки якщо формула справа від нього оцінюється як `true`; у цьому випадку нічого не буде надруковано, якщо значення не дорівнюють 15.

Відповідь на загадку: "A dime and a nickel" (і дайм, і нікель), оскільки дайм - це не нікель, а нікель - це не дайм. Змінна `x` буде зв'язуватися з 10, а змінна `y` буде зв'язуватися з 5, і буде надруковано `(10, 5)`.

## Захищені патерни проектування

У цьому розділі ми описуємо кілька моделей проектування. Ці патерни адаптовані із книги Марка Стіглера [_Ілюстрована книжка з безпечної співпраці_](http://erights.org/talks/efun/SecurityPictureBook.pdf).

### Грані

У контракті MakeCell клієнт надає два канали, один для отримання вартості, а інший - для її налаштування. Якщо клієнт передає лише канал `get` іншому процесу, цей процес ефективно відображається в режимі лише для читання ячійки.

Канали типу `get` та `set` називаються "гранями" процесу. Вони включають повноваження для виконання дії. Якщо канал `set` є загальнодоступним, наприклад як `@"Foo"`, то кожен, хто може побачити або навіть вгадати рядок `"Foo"`, має право встановлювати значення ячійки. З іншого боку, якщо канал `set` був створений за допомогою оператора `new`, то для іншого процесу неможливо побудувати канал `set`; він повинен бути переданий безпосередньо процесу, щоб цей процес зміг його використовувати.

Зверніть увагу, що якщо `get` та `set` не створюються як половини iopairs, то володіння цими каналами також є повноваженнями для перехоплення повідомлень, надісланих до ячійки:

    for (ret <- get) { P } | 
    for (ret <- get) { Q } | 
    get!(*ack)

Цей термін має два процеси прослуховування каналів `get` та одне повідомлення, яке надсилається через `get`. Тільки один з двох процесів зможе отримати повідомлення.

Отримавши канали від клієнта для отримання та встановлення, контракт MakeCell залишає рішення про те, як публікувати ці канали для клієнта. Контракт MakeCellFactory, з іншого боку, створює власні канали та повертає їх клієнтові, таким чином він може забезпечити гарантії конфіденційності.

### Послаблені форвардери

У контракті MakeCellFactory існує лише один канал, а повідомлення відправляються внутрішньо. Щоб отримати той самий ефект, що і при грані лише для читання, ми можемо створити процес форвардера, який просто ігнорує повідомлення, які не хоче пересилати. Нижчезазначений контракт передає лише метод "get".

    contract MakeGetForwarder(target, ret) = {
        new (portIn, portOut):iopair in {
            ret!(*portOut) |
            for (@method, ...@rest <= portIn) {
                method match {
                    case "get" => target!(method, ...rest)
                }
            }
        }
    }

### Відгук

Ми можемо реалізувати відгук, створивши форвардер з можливістю знищення процесу.

     1 contract MakeRevokableForwarder(target, ret) = {
     2     new (portIn, portOut):iopair, kill, forwardFlag in {
     3         ret!(*portOut, *kill) |
     4         forwardFlag!(true) |
     5         for (...@rest <= portIn) {
     6             for (@status <! forwardFlag) {
     7                 if (status) {
     8                     target!(rest)
     9                 } else {
    10                     Nil
    11                 }
    12             }
    13         } |
    14         for (_ <- kill; _ <- forwardFlag) {
    15             forwardFlag!(false)
    16         }
    17     }
    18 }

2) Ми створюємо iopair для відправлення метода та канал `forwardFlag` для зберігання або передачі повідомлень.

3) Ми повертаємо канал, на який клієнти надсилають запити, і канал, на який надсилається сигнал знищення.

4) Ми встановили початковий стан `forwardFlag` на значення true.

5-13) Ми зчитуємо в довільному кортежі частини повідомлень і отримуємо значення флагу. Якщо позначка флагу true, ми пересилаємо кортеж повідомлення на `target`.

14-15). Якщо повідомлення було будь-коли надіслано до каналу `kill`, ми встановлюємо `forwardFlag` на false, що зупиняє переадресацію повідомлень.

### Композиція

Об'єднавши послаблений форвадер із відкличним форвардером, ми отримуємо обидві функції:

    new ret in {
        MakeGetForwarder(target, *ret) |
        for (@getOnly, kill <- ret) {
            MakeRevokableForwarder(getOnly, *ret) |
            for (@revokableGetOnly <- ret) {
                // give away revokableGetOnly instead of target
                // hang onto kill for later revocation
            }
        }
    }

### Форвардер авторизації

Форвардер авторизації може записувати всі повідомлення, надіслані у канал, повторюючи їх у другому каналі.

    contract MakeLoggingForwarder(target, logger, ret) = {
        new (portIn, portOut):iopair in {
            ret!(*portOut) |
            for (...@rest <= portIn) {
                target!(...rest) |
                logger!(...rest)
            }
        }
    }

### Підзвітність

Припустимо, Аліса має канал і хоче надату Бобу авторизацію для доступу до нього. Боб хотів би делегувати використання цього каналу Керол і авторизувати їй доступ. Кожна сторона має право створювати власний форвардер авторизації в каналі, який вони отримали. Аліса назначить Боба відповідальним за те, що робить Керол.

### Закриття та відкриття

     1 contract MakeSealerUnsealer(ret) =  {
     2     new (sealerIn, sealerOut):iopair,
     3         (unsealerIn, unsealerOut):iopair,
     4         mapRet in {
     5 
     6         ret!(*sealerOut, *unsealerOut) |
     7         MakeCoatCheck(mapRet) |
     8         for (cc <- mapRet) {
     9             for (@value, ret <= sealerIn) {
    10                 cc!("new", *ret, value)
    11             } |
    12             for (ticket, ret <= unsealerIn) {
    13                 cc!("get", *ret, *ticket)
    14             }
    15         }
    16     }
    17 }

Пара закриття/відкриття забезпечує таку ж функціональність, як і відкриті ключі, але без криптографії. Це просто послаблення перевірки шару, описаного вище. Цей дизайн патерну можна використовувати для підписання чогось від імені користувача. У посібнику блокчейн Rholang ми бачимо, що він навіть працює на блокчейні, тому що не має секретів для зберігання, тільки невизначені імена залишаються недоступними.

### Остерігайтеся надсилання аттенюаторів

Основний принцип, який слід мати на увазі щодо процесів RChain - це те, що він схожий на більш традиційні веб-програми: будь-який код, який ви надсилаєте іншому учаснику, можна розібрати. З кінця 1990-х років, коли стало можливим купувати речі через Інтернет, [існують e-commerce платформи](https://blog.detectify.com/2016/11/17/7-most-common-e-commerce-security-mistakes/), де платформа спиралася на браузери користувачів, щоб відправити правильну ціну товару назад. Автори не думали про те, що користувач відкриває інструменти для розробників та змінює ціну, перш ніж товар буде відісланий назад. Правильний спосіб побудови e-commerce платформи - зберігати ціни на сервері та перевіряти їх там.

Припустимо, що Боб готовий запустити якийсь код для Аліси; у нього є контракт, який говорить щось на кшталт: "Отримати процес із цього каналу і запустити його".

    for (@P <- x) { P }

Це як веб-браузер, який готовий запустити код JavaScript, який він отримує з веб-сайту. Якщо Аліса надсилає Бобу послаблений форвардер, Боб може використовувати процеси відповідного дизайну в Rholang для розбору процесу і отримання доступу до основного ресурсу. Натомість, як і в прикладі з e-commerce, Аліса повинна надсилати лише код, який пересилає запити до власних процесів і здійснює послаблення там.

## Висновок

RChain це мова, призначена для використання на блокчейні, але ми нічого не згадували про вузли, прості імена, гаманці, Rev та phlogiston, структуру мережі або Casper. У майбутньому документі буде розглянуто всі ці питання та багато іншого.

Ми сподіваємось, що вищенаведені приклади зможуть викликати бажання написати ще більше коду та продемонструвати легкість паралельного проектування.
