# Ένας οδηγός για την Rholang

Η Rholang είναι μια νέα γλώσσα προγραμματισμού σχεδιασμένη για χρήση σε κατανεμημένα συστήματα. Όπως όλα τα νεογέννητα πράγματα, αυξάνεται και μεταβάλλεται γρήγορα. αυτό το έγγραφο περιγράφει τη σύνταξη που θα χρησιμοποιηθεί στην έκδοση 0.1 SDK.

Η Rholang είναι "προσανατολισμένη στη διαδικασία": όλοι οι υπολογισμοί γίνονται με τη μετάδοση μηνυμάτων. Τα μηνύματα μεταβιβάζονται σε "κανάλια", τα οποία μοιάζουν με ουρές μηνυμάτων αλλά συμπεριφέρονται ως σύνολα αντί για ουρές. Η Rholang είναι εντελώς ασύγχρονη, υπό την έννοια ότι ενώ μπορείτε να διαβάσετε ένα μήνυμα από ένα κανάλι και στη συνέχεια να κάνετε κάτι με αυτό, δεν μπορείτε να στείλετε ένα μήνυμα και στη συνέχεια να κάνετε κάτι εφόσον θα έχει ληφθεί --- τουλάχιστον, όχι χωρίς ρητή αναμονή ενός μηνύματος επιβεβαίωσης από τον δέκτη.

## Συμβόλαια και αποστολή δεδομένων

    1 new helloWorld in {
    2   contract helloWorld(name) = {
    3     "Hello, ".display(name, "!\n")
    4   } |
    5   helloWorld("Joe")
    6 }
    
1) Ένα πρόγραμμα Rholang είναι μια ενιαία διαδικασία. Αυτή η διαδικασία ξεκινά με τη δημιουργία ενός νέου καναλιού που ονομάζεται `helloWorld`. Για να δημιουργήσουμε ένα νέο, ιδιωτικό κανάλι, χρησιμοποιούμε την κατασκευή `new ... in`. Καμία άλλη διαδικασία δεν μπορεί να στείλει ή να λάβει μηνύματα μέσω αυτού του καναλιού, εκτός αν στέλνουμε ρητά αυτό το κανάλι στην άλλη διαδικασία.

2) Η παραγωγή του `contract` δημιουργεί μια διαδικασία που δημιουργεί ένα αντίγραφο του σώματός της κάθε φορά που λαμβάνει ένα μήνυμα.

3) Η μέθοδος `display` μιας συμβολοσειράς γράφει στην έξοδο standard. Παίρνει μια λίστα των συμβολοσειρών για να εκτυπώσει μετά. Επομένως, για να λειτουργήσει αυτό, το μήνυμα `name 'θα πρέπει να είναι μια συμβολοσειρά.

5) Στέλνουμε τη συμβολοσειρά `"Joe"` στο κανάλι `helloWorld`.

## Λήψη δεδομένων

     1 new helloAgain in {
     2   contract helloAgain(_) = {
     3     new chan in {
     4       chan("Hello again, world!") |
     5       for (text <- chan) {
     6         text.display("\n")
     7       }
     8     }
     9   } |
    10   helloAgain(Nil)
    11 }

2) Τα συμβόλαια λαμβάνουν τουλάχιστον μία παράμετρο, αλλά μπορούμε να την πετάξουμε δεσμεύοντας την σε μια μεταβλητή που δεν χρησιμοποιούμε ποτέ.

3) Δημιουργούμε ένα νέο κανάλι `chan`.

4) Στέλνουμε τη διαδικασία συμβολοσειράς `"Hello again, world!"` πάνω στο νέο κανάλι.

5) Ακούμε στο νέο κανάλι για ένα μήνυμα. Η λειτουργία `for` μπλοκάρει μέχρι να διατεθεί ένα μήνυμα στο κανάλι` chan`. Η λειτουργία `for` είναι ακριβώς όπως ένα συμβόλαιο, εκτός του ότι διαβάζει μόνο ένα μήνυμα και στη συνέχεια γίνεται το σώμα της αντί να διαχωρίσει ένα αντίγραφο του σώματός της για κάθε μήνυμα.

## Μεταβλητή κατάσταση

     1 new MakeCell in {
     2   // Δημιουργεί ένα κελί στο οποίο μπορείς να αποθηκεύεις τιμές
     3   contract MakeCell(init, get, set) = {
     4     new valueStore in {
     5       valueStore(init) |
     6       contract get(ack) = {
     7         for(value <- valueStore) {
     8           valueStore(value) | ack(value)
     9         }
    10       } |
    11       contract set(pair) = {
    12         for(_ <- valueStore) {
    13           match pair with [newValue, ack] => {
    14             valueStore(newValue) | ack(Nil)
    15           }
    16         }
    17       }
    18     }
    19   } |
    20   // Χρήση του κελιού.
    21   new myGet, mySet in {
    22     MakeCell(123, myGet, mySet) |
    23     new ack in {
    24       myGet(ack) |
    25       for (result <- ack) {
    26         result.display("\n") |
    27         mySet([456, ack]) |
    28         for (_ <- ack) {
    29           myGet(ack) |
    30           for (result <- ack) {
    31             result.display("\n")
    32           }
    33         }
    34       }
    35     }
    36   }
    37 }
    
1) Δημιουργούμε ένα νέο κανάλι MakeCell και στη συνέχεια το χρησιμοποιούμε στη γραμμή 3 ως το όνομα ενός εσωτερικού συμβολαίου. Καμία διαδικασία εκτός από τον κώδικα μέσα σε αυτό το λεξικό πεδίο δεν μπορεί να το επικαλεστεί.

3) Η σύμβαση «MakeCell» λαμβάνει τρία ορίσματα. Το πρώτο όρισμα είναι η αρχική τιμή που πρέπει να αποθηκευτεί στο κελί. Το δεύτερο και το τρίτο όρισμα είναι κανάλια πάνω στα οποία το κελί θα λαμβάνει αιτήματα για να πάρει και να ρυθμίσει την τιμή.

4) Για να αποθηκεύσουμε την τιμή, δημιουργούμε ένα νέο κανάλι. Αυτό το κανάλι θα έχει το πολύ ένα μήνυμα, το οποίο θα περιέχει την τρέχουσα τιμή του κελιού.

5) Πριν από αυτή τη γραμμή, δεν υπάρχουν μηνύματα στο κανάλι `valueStore`. Αφού στείλουμε την αρχική τιμή, είναι η μόνη τιμή σε αυτό το κανάλι.

6) Δημιουργούμε ένα συμβόλαιο για να ακούσουμε στο κανάλι `get`. Κάθε φορά που αποστέλλεται ένα μήνυμα στο `get`, το σώμα του συμβολαίου θα εκτελείται

7) Μπλοκάρουμε έως ότου λάβουμε ένα μήνυμα από το κανάλι `valueStore`. Επειδή υπάρχει το πολύ ένα μήνυμα που περιμένει πάντα στο "valueStore", η ανάγνωση του μηνύματος συμπεριφέρεται σαν να αποκτάτε κλειδαριά.

8) Στέλνουμε εκ νέου την τρέχουσα τιμή στο `valueStore`, επιτρέποντας την επεξεργασία άλλων μηνυμάτων και στέλνουμε την τρέχουσα τιμή πίσω στον πελάτη στο κανάλι` ack`.

11) Παράλληλα με τη σύμβαση `get`, τρέχουμε ένα συμβόλαιο που ακούει στο `set`.

12) Μπλοκάρουμε μέχρι να υπάρξει ένα μήνυμα στο "valueStore", στη συνέχεια το διαβάζουμε. Πετάμε το μήνυμα που διαβάσαμε.

13) Η λειτουργία `match` καταστρέφει τη δέσμευση, χωρίζοντας την πλειάδα `pair` στα εξαρτήματά της και αναθέτοντας ονόματα σε αυτά.

14) Στέλνουμε τη νέα τιμή για αποθήκευση στο `valueStore` και ειδοποιούμε ότι η λειτουργία ολοκληρώθηκε.

21-36) Ο κώδικας χρήσης επιδεικνύει τη δημιουργία ενός κελιού, την εκχώρηση της αρχικής τιμής 123, τη λήψη και την εκτύπωση αυτής της τιμής, τη ρύθμιση της τιμής σε 456, και έπειτα την λήψη και την εκτύπωση αυτής της τιμής.

Σημειώστε τα βαθιά στρώματα της επανάκλησης. Η Rholang σχεδιάστηκε έτσι ώστε να κάνει φυσική την έκφραση των παράλληλων υπολογισμών· ως εκ τούτου, σε άλλες γλώσσες πρέπει να καταστούν σαφείς οι εξαρτήσεις δεδομένων που εμπεριέχονται στην αλληλουχία.

## Εναλλαγή και ταιριάσματα

Στον παρακάτω κώδικα, η `iterate` αρχικά στέλνει ένα κανάλι `next` στο `iterator` και στη συνέχεια για κάθε μήνυμα που λαμβάνεται στο `next` στέλνει ένα ζεύγος που περιέχει το επόμενο στοιχείο της λίστας και εάν η επανάληψη έχει γίνει.

     1 new iterator, iterate in {
     2     contract iterate(list, iterator) = {
     3         new next, right in {
     4             iterator(next) |
     5             for (_ <- next) {
     6                 contract right(pair) = {
     7                     match pair with [i, limit] => {
     8                         iterator([list.nth(i), i < limit]) |
     9                         for (_ <- next) {
    10                             match i + 1 < limit with true => {
    11                                 right([i + 1, limit]) 
    12                             }
    13                         }
    14                     }
    15                 } |
    16                 right([0, list.size()])
    17             }
    18         }
    19     } |
    20     // Καλούμε το συμβόλαιο iterator στο κανάλι
    21     iterate([4,5,6], iterator) |
    22     
    23     // Αλληλεπιδρά με το iterator
    24     for (next <- iterator) {
    25         next(Nil) |
    26         new left in {
    27             contract left(_) = {
    28                 for (pair <- iterator) {
    29                     match pair with [v, keepGoing] => {
    30                         v.display("\n") |
    31                         match keepGoing with true => { 
    32                             next(Nil) |
    33                             left(Nil) 
    34                         }
    35                     }
    36                 }
    37             } |
    38             left(Nil)
    39         }
    40     }
    41 }

7) Η κατασκευή `match .. with` επιτρέπει την καταστροφή της δέσμευσης.

8) Η μέθοδος `nth` στις πλειάδες επιτρέπει την εξαγωγή μεμονωμένων στοιχείων.

16) Οι πλειάδες έχουν μια μέθοδο `size`.

## Χάρτες

     1 new MakeCoatCheck in {
     2     contract MakeCoatCheck(ret) = {
     3         new port, mapStore in {
     4             mapStore(Map()) |
     5             ret(port) |
     6             contract port (method, ack, arg1, arg2) = {
     7                 match method with
     8                 "new" => {
     9                     for (map <- mapStore) {
    10                         new ticket in {
    11                             map.insert(ticket, arg1) |
    12                             mapStore(map) |
    13                             ack(ticket)
    14                         }            
    15                     }
    16                 }
    17                 "get" => {
    18                     for (map <- mapStore) {
    19                         mapStore(map) |
    20                         ack(map.get(arg1))
    21                     }
    22                 }
    23                 "set" => {
    24                     for (map <- mapStore) {
    25                         map.insert(arg1, arg2) |
    26                         mapStore(map) |
    27                         ack(Nil)
    28                     }
    29                 }
    30             }
    31         }
    32     } |
    33 
    34     // Χρήση
    35     new ret in {
    36         MakeCoatCheck(ret) |
    37         for (cc <- ret) {
    38             // Δημιουργεί ένα νέο κελί με αρχική τιμή 0
    39             cc("new", ret, 0, Nil) |
    40             for (ticket <- ret) {
    41                 // Ορίζει το κελί σε 1
    42                 cc("set", ret, ticket, 1) |
    43                 for (ack <- ret) {
    44                     // Διαβάζει την τιμή
    45                     cc("get", ret, ticket, Nil) |
    46                     for (storedValue <- ret) {
    47                         // Εκτυπώνει 1
    48                         storedValue.display("\n")
    49                     }
    50                 }
    51             }
    52         }
    53     }
    54 }
    
2) Ένα μοτίβο σχεδιασμού, που χρησιμοποιείται παραπάνω στο συμβόλαιο MakeCell, είναι να λαμβάνει από τον καλούντα ένα κανάλι για κάθε διαφορετική λειτουργικότητα που μια διαδικασία παρέχει. Ένας προγραμματιστής αντικειμενοστραφούς γλώσσας μπορεί να πει ότι η MakeCell απαιτεί από τον καλούντα να παρέχει ένα κανάλι για κάθε μέθοδο. Τα ταιριάσματα επιχειρούνται με τη σειρά που εμφανίζονται στον κώδικα· αν δεν συμβαίνει κανένα ταίριασμα, το μπλοκ `match` ορίζεται στη διαδικασία `Nil`. Το MakeCoatCheck χρησιμοποιεί μια πιο αντικειμενοστραφή προσέγγιση, όπως θα δούμε.

3-4) Κάθε έλεγχος coat έχει το δικό του μεταβλητό χάρτη επανεισόδου στον οποίο αποθηκεύονται τα αντικείμενα. Αποθηκεύουμε το νεόκτιστο χάρτη στο mapStore. Έχει το ακόλουθο API:

    insert(key, value)
    insertMany(key1, val1, key2, val2, ..., keyn, valn)
    getOrElse(key, default)
    get(key)

6) Περιμένουμε τέσσερα ορίσματα κάθε φορά· θα μπορούσαμε επίσης να αναμένουμε μία ενιαία πλειάδα και να είχαμε καταστρέψει την δέσμευση για να αποσταλεί με βάση τόσο τη μέθοδο όσο και το μήκος της πλειάδας.

## Φιλόσοφοι που δειπνούν και αδιέξοδο

     1 new north, south, knife, spoon in {
     2     north(knife) |
     3     south(spoon) |
     4     for (knf <- north) { for (spn <- south) {
     5         "Philosopher 1 Utensils: ".display(knf, ", ", spn, "\n") |
     6         north(knf) |
     7         south(spn)
     8     } } |
     9     for (knf <- north) { for (spn <- south) {
    10         "Philosopher 2 Utensils: ".display(knf, ", ", spn, "\n") |
    11         north(knf) |
    12         south(spn)
    13     } }
    14 }

Το πρόβλημα δείπνου των φιλοσόφων έχει δύο φιλοσόφους που μοιράζονται μόνο ένα σύνολο μαχαιροπήρουνων. Ο Philosopher1 κάθεται στην ανατολική πλευρά του τραπεζιού ενώ ο Philosopher2 κάθεται δυτικά. Κάθε ένας χρειάζεται ένα μαχαίρι και ένα πιρούνι για να φάει. Ο καθένας αρνείται να παραιτηθεί από ένα σκεύος μέχρι να χρησιμοποιήσει και τα δύο για να πάρει μια δαγκωματιά. Αν και οι δύο φιλόσοφοι πάνε να πάρουν πρώτα το σκεύος στα δεξιά τους, και οι δύο θα λιμοκτονίσουν: ο Philosopher1 παίρνει το μαχαίρι, ο Philosopher2 παίρνει το πιρούνι και κανένας απο τους δύο δεν τα ξανα αφήνει.

Ακολουθεί ο τρόπος επίλυσης του προβλήματος:

     1 new north, south, knife, spoon in {
     2     north(knife) |
     3     south(spoon) |
     4     for (knf <- north; spn <- south) {
     5         "Philosopher 1 Utensils: ".display(knf, ", ", spn, "\n") |
     6         north(knf) |
     7         south(spn)
     8     } |
     9     for (spn <- south; knf <- north) {
    10         "Philosopher 2 Utensils: ".display(knf, ", ", spn, "\n") |
    11         north(knf) |
    12         south(spn)
    13     }
    14 }

4, 9) Ο χειριστής ένωσης, σημειωμένος με ερωτηματικό `;`, δηλώνει ότι η συνέχιση πρέπει να προχωρήσει μόνο εάν υπάρχει διαθέσιμο ένα μήνυμα σε καθένα από τα κανάλια ταυτόχρονα, αποτρέποντας το παραπάνω αδιέξοδο.

## Ασφαλή σχέδια μοτίβου

Σε αυτή την ενότητα περιγράφουμε διάφορα σχέδια μοτίβου. Αυτά τα μοτίβα είναι προσαρμοσμένα από το [_A PictureBook of Secure Cooperation_](http://erights.org/talks/efun/SecurityPictureBook.pdf)  του Marc Stiegler.

### Facets

Στο συμβόλαιο MakeCell, ο πελάτης παρέχει δύο κανάλια, ένα για να πάρει την τιμή και ένα για να την ορίσει. Αν ο πελάτης περάσει μόνο το κανάλι `get` σε μια άλλη διαδικασία, αυτή η διαδικασία έχει στην πραγματικότητα μια προβολή μόνο για ανάγνωση του κελιού.

Τα κανάλια όπως το `get` και το `set` ονομάζονται "facets" της διαδικασίας. Ενσωματώνουν την εξουσία για να εκτελέσουν τη δράση. Εάν το κανάλι `set` είναι δημόσιο κανάλι όπως το`@"Foo"`, τότε όποιος μπορεί να μάθει ή ακόμα και να μαντέψει τη συμβολοσειρά `"Foo"` έχει την εξουσία να ρυθμίσει την τιμή του κελιού. Από την άλλη πλευρά, αν το κανάλι `set` δημιουργήθηκε με τον διαχειριστή `new`, τότε δεν υπάρχει τρόπος για οποιαδήποτε άλλη διαδικασία να κατασκευάσει το κανάλι `set`· πρέπει να μεταβιβαστεί απευθείας σε μια διαδικασία, προκειμένου η διαδικασία να τη χρησιμοποιήσει.

Σημειώστε ότι η απόκτηση των `get` και` set` είναι επίσης εξουσιοδοτημένη να παρεμποδίζει μηνύματα που αποστέλλονται στο κελί:

    for (ret <- get) { P } | 
    for (ret <- get) { Q } | 
    get(ack)

Αυτός ο όρος έχει δύο διαδικασίες που ακούν στο κανάλι `get` και μόνο ένα μήνυμα που στέλνεται στο `get`. Μόνο μία από τις δύο διαδικασίες θα είναι σε θέση να λάβει το μήνυμα.

Με τη λήψη καναλιών από τον πελάτη για λήψη και ρύθμιση, το συμβόλαιο MakeCell αφήνει τις αποφάσεις σχετικά με το πόσο δημόσια είναι αυτά τα κανάλια στον πελάτη. Το συμβόλαιο MakeCellFactory, από την άλλη πλευρά, κατασκευάζει τα δικά του κανάλια και τα επιστρέφει στον πελάτη, έτσι ώστε να είναι σε θέση να επιβάλει εγγυήσεις ιδιωτικότητας.

### Εξασθένηση των μεταφορέων

Στο συμβόλαιο MakeCellFactory, υπάρχει μόνο ένα κανάλι και τα μηνύματα αποστέλλονται εσωτερικά. Για να έχουμε το ίδιο αποτέλεσμα ως ενα facet που μόνο για ανάγνωση, μπορούμε να δημιουργήσουμε μια διαδικασία προώθησης που απλά αγνοεί τα μηνύματα που δεν θέλει να προωθήσει. Το παρακάτω συμβόλαιο διαβιβάζει μόνο τη μέθοδο "get".

    contract MakeGetForwarder(target, ret) = {
        new port in {
            ret(port) |
            contract port(tuple) = {
                tuple.nth(0) match with "get" => target(tuple)
            }
        }
    }

### Ανάκληση

Μπορούμε να εφαρμόσουμε την ανάκληση δημιουργώντας έναν προωθητή με έναν διακόπτη kill.

     1 contract MakeRevokableForwarder(target, ret) = {
     2     new port, kill, forwardFlag in {
     3         ret(port, kill) |
     4         forwardFlag(true) |
     5         contract port(tuple) = {
     6             for (status <- forwardFlag) {
     7                 forwardFlag(status) |
     8                 match status with true => { target(tuple) }
     9             }
    10         } |
    11         for (_ <- kill; _ <- forwardFlag) {
    12             forwardFlag(false)
    13         }
    14     }
    15 }
    
2) Δημιουργούμε μια πόρτα για να ακούσουμε για κλήσεις μεθόδων και ένα κανάλι `forwardFlag` για να αποθηκεύουμε το αν θα προωθήσουμε μηνύματα.

3) Επιστρέφουμε το κανάλι στο οποίο οι πελάτες στέλνουν αιτήματα και το κανάλι στο οποίο θα αποσταλεί το σήμα kill.

4) Καθορίσαμε την αρχική κατάσταση του `forwardFlag` σε true.

5-10) Διαβάζουμε σε μια αυθαίρετη πλειάδα τμημάτων μηνυμάτων και παίρνουμε την αξία της σημαίας. Αν η σημαία είναι αληθής, προωθούμε την πλειάδα μηνυμάτων στο `target`.

11-13) Εάν ένα μήνυμα έχει ποτέ σταλεί στο κανάλι `kill`, ορίζουμε το 'forwardFlag' σε false. Στη συνέχεια η διαδικασία προώθησης σταματά την προώθηση μηνυμάτων.

### Σύνθεση

Συνδυάζοντας ένα εξασθενητικό προωθητή με ένα ανακλητό προωθητή, παίρνουμε και τα δύο χαρακτηριστικά:

    new ret in {
        MakeGetForwarder(target, ret) |
        for (pair <- ret) {
            match pair with [getOnly, kill] => {
                MakeRevokableForwarder(getOnly, ret) |
                for (revokableGetOnly <- ret) {
                    // δώσε το revokableGetOnly αντί για το target
                // hang στην kill για να γίνει αργότερα ανάκληση
                }
            }
        }
    }

### Πρωοθητής σύνδεσης

Ένας πρωοθητής σύνδεσης μπορεί να καταγράψει όλα τα μηνύματα που έχουν σταλεί σε ένα κανάλι, στέλνοντας τα σε ένα δεύτερο κανάλι.

    contract MakeLoggingForwarder(target, logger, ret) = {
        new port in {
            ret(port) |
            contract port(tuple) {
                target(tuple) |
                logger(tuple)
            }
        }
    }

### Υπευθηνότητα

Ας υποθέσουμε ότι η Alice έχει ένα κανάλι και θα ήθελε να καταγράψει την πρόσβαση του Bob σε αυτό. Ο Bob θα ήθελε να μεταβιβάσει τη χρήση αυτού του καναλιού στην Carol και να καταγράψει την πρόσβασή της. Κάθε συμβαλλόμενο μέρος είναι ελεύθερο να κατασκευάσει το δικό του προωθητή καταγραφής σχετικά με το κανάλι που έχει λάβει. Η Alice θα θέσει τον Bob υπεύθυνο για ότι κάνει η Carol.

### Σφράγισμα και αποσφράγισμα

    contract MakeSealerUnsealer(ret) =  {
        new sealer, unsealer, ccRet in {
            ret(sealer, unsealer) |
            MakeCoatCheck(ccRet) |
            for (cc <- ccRet) {
                contract sealer(value, ret) = {
                    cc("new", ret, value, Nil)
                } |
                contract unsealer(ticket, ret) = {
                    cc("get", ret, ticket, Nil)
                }
            }
        }
    }


Ένα ζεύγος σφραγίσματος/αποσφραγίσματος παρέχει την ίδια λειτουργικότητα με τα δημόσια κλειδιά, αλλά χωρίς κρυπτογραφία. Είναι απλώς μια εξασθένηση του ελέγχου που περιγράφεται παραπάνω. Αυτό το σχέδιο μοτίβου μπορεί να χρησιμοποιηθεί για να υπογράψει κάτι για λογαριασμό του χρήστη. Στον οδηγό για το blockchain στη Rholang, θα δούμε ότι λειτουργεί ακόμη και στο blockchain επειδή δεν υπάρχουν μυστικά προς αποθήκευση, μόνο τα μη πλαστογραφήσιμα ονόματα που πρέπει να παραμείνουν μη προσβάσιμα.

# # # Προσοχή στην αποστολή εξασθενητών

Μια βασική αρχή που πρέπει να θυμάστε με τις διαδικασίες του RChain είναι αυτή που είναι παρόμοια με τις πιο παραδοσιακές εφαρμογές ιστού: οποιοσδήποτε κώδικας στέλνετε σε κάποιον άλλον μπορεί να αποσυναρμολογηθεί. Από τα τέλη της δεκαετίας του 1990, όταν έγινε εφικτή η αγορά των πραγμάτων μέσω του διαδικτύου, [υπήρξαν πλατφόρμες ηλεκτρονικού εμπορίου](https://blog.detectify.com/2016/11/17/7-most-common-e-commerce-security-mistakes/) όπου η πλατφόρμα βασίστηκε στα προγράμματα περιήγησης των χρηστών για να στείλει τη σωστή τιμή του στοιχείου πίσω σε αυτήν. Οι συγγραφείς δεν σκέφτηκαν ότι ο χρήστης θα ανοίγε τα εργαλεία προγραμματιστών και θα άλλαζε την τιμή πριν να στείλει πίσω. Ο σωστός τρόπος για να δημιουργήσετε μια πλατφόρμα ηλεκτρονικού εμπορίου είναι να αποθηκεύσετε τις τιμές στο διακομιστή και να τις ελέγξετε εκεί.

Ας υποθέσουμε ότι ο Bob είναι πρόθυμος να εκτελέσει κάποιο κώδικα για την Alice· έχει ένα συμβόλαιο που λέει κάτι σαν "Πάρτε μια διαδικασία από αυτό το κανάλι και τρέξτε τη".

    for (p <- x) { *p }

Αυτό είναι ακριβώς σαν ένα πρόγραμμα περιήγησης ιστού να είναι πρόθυμο να εκτελέσει τον κώδικα JavaScript που παίρνει από έναν ιστότοπο. Αν η Alice στείλει στον Bob έναν εξασθενητικό μεταφορέα, ο Bob μπορεί να χρησιμοποιήσει τις παραγωγές πρότυπων αντιστοιχίας της Rholang για να διαλύσει τη διαδικασία και να αποκτήσει πρόσβαση στον υποκείμενο πόρο. Αντ 'αυτού, όπως στο παράδειγμα ηλεκτρονικού εμπορίου, η Alice πρέπει να στείλει μόνο κώδικα που διαβιβάζει τα αιτήματα στις δικές της διαδικασίες και να κάνει την εξασθένηση εκεί.

## Συμπέρασμα

Το RChain είναι μια γλώσσα σχεδιασμένη για χρήση σε blockchain, αλλά δεν έχουμε αναφέρει τίποτα για τους κόμβους, τα namespaces, τα πορτοφόλια, τα Rev και το Phlogiston, τη δομή του δικτύου ή τον Casper. Ένα προσεχές έγγραφο θα εξετάσει όλα αυτά τα θέματα και πολλά άλλα.

Ελπίζουμε ότι τα παραπάνω παραδείγματα προκαλούν την επιθυμία να γράψουμε περισσότερο κώδικα και να επιδείξουμε την ευκολία έκφρασης των ταυτόχρονων σχεδίων.
