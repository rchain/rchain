# Учебник Rholang

Rholang - это новый язык программирования, предназначенный для использования в распределенных системах. Как и все новорожденные, оно быстро растет и быстро меняется; этот документ описывает синтаксис, который будет использоваться в выпуске Mercury.

Язык ориентирован на параллельное исполнение, с упором на парсинг данных, поступающих по различным каналам. Эти каналы статично типизированы и могут быть использованы как трубы для получения отдельных сообщений, потоки или в них могут храниться данные.Подобно языкам с функциональной типизацией, он поддерживает алгебраические структуры данных и оперирует с неизменными величинами. Он поддерживает формальную верификацию величин. Он поддерживает формальную верификацию при помощи поведенческих типов.

## Контракты, отражение и отправка данных

    1 contract @"HelloWorld"(system) = {
    2     system!("print", "Hello, world!")
    3 }

1) В Интернете серверы имеют IP-адреса. Служба доменных имен (DNS) сопоставляет буквенно-цифровые строки номерам, а не телефонной книге. Вместо использования чисел или строк Rholang «отражает»: все каналы- они называются сериализованным процессом. Все сериализации процессов начинаются с `@`. Этот контракт прослушивает сообщения, отправленные по каналу, названному сериализацией строкового процесса `"HelloWorld"`. Чтобы быть краткими, мы говорим: «Этот контракт выводит`"HelloWorld"`.

Контракт объявляет API, с помощью которого другие процессы могут взаимодействовать с ним. Контракты верхнего уровня имеют один и тот же API: у них есть один аргумент, канал для процесса `system`. Процесс `system` содержит имена всех каналов, которые могут вызывать побочные эффекты на узле. Это встроенный процесс, который прослушивает сообщения, состоящие из имени метода и некоторых аргументов.

2) Оператор контрольной точки отправляет сообщение справа от канала налево. Каждое сообщение является кортежем имен. Если мы отправим процесс вместо имени, он автоматически сериализуется в имя.

В этом случае мы отправляем сообщение, состоящее из двух процессов: строки `` print`` и строки `` Hello, world! "`. Процесс `system` - это встроенный процесс, который прослушивает сообщения, состоящие из имени метода и некоторых аргументов; в этом случае процесс вторит второму аргументу стандартного вывода.

## Новые каналы, прием данных и шаблонов

    1 contract @"HelloAgain"(system) = new chan in {
    2     chan!("Hello again, world!") |
    3     for (@text <- chan) system!("print", text)
    4 }

1) Чтобы создать новый частный канал, мы используем конструкцию `new ... in`. Никакой другой процесс не может отправлять или получать сообщения по этому каналу, если мы явно не отправим этот канал другому процессу.

2) Мы отправляем строковый процесс `"Hello again, world!"`  На новый канал.

3) Мы выводим новый канал для сообщения. Операция `for` блокируется до тех пор, пока на канале` chan` не появится сообщение.

Язык шаблонов (также называемый «пространственными типами») включает язык процессов и имен. Каждый процесс со свободными переменными - это шаблон, который соответствует процессу с той же структурой; свободные переменные связываются с подпроцессами в этой позиции. В строке 3 мы ожидаем кортеж с одним элементом. Этот элемент является сериализацией некоторого процесса и поэтому начинается с `@`. Поскольку мы отправили строку в строке 2, свободная переменная `text` привязана к этому строковому процессу. Наконец, строка 3 переводит эту строку в процесс `system` для печати.

Позже мы рассмотрим еще несколько особенностей шаблонов.

## Непостоянная переменная, копирование и выбор

    1 contract @"CellDemo"(system) = new MakeCell in {
     2     // Makes a single cell in which you can store values
     3     contract MakeCell(@init, get, set) = new valueStore in {
     4         valueStore!(init) |
     5         for (@value <= valueStore) {
     6             select {
     7                 ack <- get => valueStore!(value) | ack!(value)
     8                 @newValue, ack <- set => valueStore!(newValue) | ack!()
     9             }
    10         }
    11     } |
    12 
    13     // Cell usage.
    14     new myGet, mySet in {
    15         MakeCell(123, *myGet, *mySet) |
    16         new ack in {
    17             myGet!(*ack) |
    18             for (@result <- ack) {
    19                 system!("print", result, *ack) |
    20                 for (_ <- ack) {
    21                     mySet!(456, *ack) |
    22                     for (_ <- ack) {
    23                         myGet!(*ack) |
    24                         for (@result <- ack) {
    25                             system!("print", result)
    26                         }
    27                     }
    28                 }
    29             }
    30         }
    31     }
    32 }

1) Мы создаем новый канал MakeCell, а затем используем его в строке 3 как имя внутреннего контракта. Никакой другой процесс, кроме кода внутри`@"CellDemo"` контракта, может вызвать его.

3) Контракт «MakeCell» принимает три аргумента. Первый аргумент - это процесс, начальное значение которого должно быть сохранено в ячейке. Второй и третий аргументы - это каналы, по которым ячейка будет получать запросы для получения и установки значения. Те, кто знаком с C ++, могут рассматривать каналы как примерно эквивалентные указателям в том смысле, что указатель представляет собой сериализуемый тип данных, который обозначает местоположение. Оператор `@` в этом контексте примерно эквивалентен символу `&`, который обозначает pass-by-reference; переменная `init` привязывается к процессу, а не к каналу. В C ++ для преобразования указателя в ссылку используется оператор `*`; аналогично, в Rholang для преобразования канала в процесс мы используем оператор `*`. Поскольку мы можем отправлять процессы только по каналу, оператор `*` используется очень часто; см. строки с нечетными номерами в примере использования.

Чтобы сохранить значение, мы создаем новый канал. Этот канал будет содержать не более одного сообщения, содержащего текущее значение ячейки.

4) Перед этой строкой на канале `valueStore` нет сообщений. После отправки начального значения это единственное значение на этом канале.

5) Параллельно с 4 мы пытаемся читать из `valueStore`. Стрелка с двойным стеблем говорит, что как только мы получим сообщение на этом канале, мы должны создать копию процесса сразу после `for` и начать пытаться прочитать на этом канале снова сразу.

Когда сообщение становится доступным, мы связываем переменную `value` с процессом в сообщении.

6-8). Ключевое слово `select` в строке 6 означает, что только одна из ветвей на линиях 7 или 8 будет продолжена. На этом этапе на канале `valueStore` нет сообщения.

Если есть сообщение на канале `get`, тогда может работать ветка в строке 7. Переменная `ack` привязана к сообщению, а затем параллельно происходит две вещи: прочитанное нами значение снова отправляется на` valueStore`, а также отправляется на канал `ack`.

Сообщения - это кортежи имен. Все сообщения, которые мы видели до сих пор, имели значение 1, но здесь, в строке 8, мы ждем сообщения значение 2. Первая часть шаблона связывает переменную `newValue` с первой частью сообщения, а вторая часть шаблона связывает переменную `ack` с каналом. Вместо отправки `value` в` valueStore`, как это было в строке 7, мы отправляем `newValue`.

Также в строке 8 мы отправляем сообщение значения 0. В примере использования строки 20 и 22 используют знак подчеркивания для получения этого пустого сообщения и отбрасывают его.

9) На этом этапе снова появляется сообщение на канале `valueStore`.

13-31) Код использования демонстрирует создание ячейки, назначение начального значения 123, получение и печать этого значения, установка значения до 456, а затем получение и печать этого значения.

Обратите внимание на глубокие уровни обратного вызова. Rholang был разработан, чтобы сделать параллельные вычисления естественными для выражения; как следствие, зависимости данных, подразумеваемые в последовательности на других языках, должны быть ясными.

## Итерация

     1 contract @"IterateDemo"(system) = new chan in {
    2     [1,2,3].iterate(chan) |
    3     for (@num, ack << chan) system!("print", num, *ack)
    4 }


2) Скобки указывают список. Списки являются изменяемыми, а кортежи, обозначенные круглыми скобками, - нет. Некоторые процессы, например, поддерживаемые объектами Java, имеют методы; здесь метод `iterate` вызывается с каналом для итерации.

3) Оператор `` `указывает на« последовательную отправку »или, другими словами, что сообщения от чан нуждаются в подтверждении до того, как будут отправлены новые сообщения.

Метод `print` системного процесса может принимать один или два аргумента. В двухпараметрическом случае второй аргумент представляет собой канал, по которому сообщение подтверждения будет отправлено после завершения печати. Метод iterate получит это подтверждение и отправит следующее сообщение. Как только список завершит итерацию, строка 3 будет развиваться в процессе `Nil`, который ничего не делает и собирает мусор.

## Параметры сопоставления и остановка шаблона

      1 contract @"CoatCheckDemo"(system) = new MakeCoatCheck in {
     2     contract MakeCoatCheck(ret) = {
     3         new (portIn, portOut):iopair, table in {
     4             ret!(*portOut) |
     5             for (@method, ack, ...@rest <= portIn) {
     6                 match method {
     7                     case "new" => match rest {
     8                         case (initialValue) => new ticket in {
     9                             ack!(*ticket) |
    10                             @(*ticket | *table)!(initialValue)
    11                         }            
    12                     }
    13                     case "get" => match rest {
    14                         case (ticket) => {
    15                             for (@value <! @(*ticket | *table)) {
    16                                 ack!(value)
    17                             }
    18                         }
    19                     }
    20                     case "set" => match rest {
    21                         case (store, @newValue) => {
    22                             for (_ <- @(*ticket | *table)) {
    23                                 @(*ticket | *table)!(newValue) |
    24                                 ack!()
    25                             }
    26                         }
    27                     }
    28                 }
    29             }
    30         }
    31     } |
    32 
    33     // Usage
    34     new ret in {
    35         MakeCoatCheck(ret) |
    36         for (cc <- ret) {
    37             // Creates new cell with initial value 0
    38             cc!("new", *ret, 0) |
    39             for (ticket <- ret) {
    40                 // Sets the cell to 1
    41                 cc!("set", *ret, *ticket, 1) |
    42                 for (ack <- ret) {
    43                     // Reads the value
    44                     cc!("get", *ret, *ticket) |
    45                     for (@storedValue <- ret) {
    46                         // Prints 1
    47                         system!("print", storedValue)
    48                     }
    49                 }
    50             }
    51         }
    52     }
    53 }

2) Один шаблон проектирования, используемый в контракте MakeCell выше, заключается в том, чтобы получать от вызывающего канала канал для каждой разной функциональности, предоставляемой процессом. Объектно-ориентированный программист может сказать, что MakeCell требует, чтобы вызывающий абонент предоставил канал для каждого метода. Матчи выполняются в порядке, указанном в коде; если совпадение не происходит, блок `match` оценивает процесс` Nil`.


3) MakeCoatCheck использует более объектно-ориентированный подход. Конструкция `(in, out): iopair` позволяет нам создать связанную пару каналов. Это ошибка типа для отправки сообщения по каналу `in` или для получения сообщения по каналу` out`. Однако любое сообщение, отправленное по каналу `out`, может быть получено по каналу` in`. Это позволяет нам вернуть канал `out`, по которому можно вызвать вызовы методов, не позволяя другим процессам перехватывать запросы, предназначенные для нашего процесса.

Новый канал `table` будет использоваться для создания каналов для внутреннего использования.

5) Мы неоднократно читаем здесь сообщения о любой степени, большей или равной двум. Переменная `method` привязана к первому аргументу; мы ожидаем строку, которая называет метод, как это делает системный процесс. Переменная `ack` привязана к каналу, по которому мы отправим любой результат вызова метода. Переменная `rest` привязана к кортежу, содержащему остальную часть частей сообщения.

6) Конструкция `match ... case` позволяет нам сопоставить шаблон по структуре процесса. Мы используем это для отправки сообщений.

7-12) Если `method` - это строка` new `, то в строке 8 мы предполагаем, что `rest` будет кортежем с одним элементом, начальным значением. Мы создаем канал  `ticket`   и возвращаем его с помощью канала `ack`. Мы также объединяем процессы *ticket 'с`table`, в новый процесс, а затем выводим из них имя канала. Поскольку у нас есть доступ к «таблице», мы можем манипулировать данными, хранящимися на построенных таким образом каналах. Канал `ticket` ведет себя как погашаемый билет для проверенного пальто, а канал` @ (* ticket | * table) `- это запись в таблице, указанная этим ключом.

13-19) Если `method` является строкой`"get', то мы предполагаем, что в строке 14` rest будет кортежем с одним элементом, конкретным билетом для элемента для извлечения. Оператор  `<!`   cчитывает значение из таблицы и сразу же возвращает его; то есть,

    for (y <! x) { P }

синтаксический сахар для

    for (y <- x) { x!(*y) | P }.

20-27). Если `method` является строкой ` set`,то мы предполагаем в строке 21, что` rest` будет кортежем с двумя элементами: ключом и новым значением. Строка 22 выбрасывает текущее значение в этом билете, строка 23 отправляет новое значение, а строка 24 сигнализирует, что это сделано.

## Обработка ошибок

     1 for (@info, ret, err <- channel) {
     2     // Either return a result on ret or an error on err
     3 } |
     4 select {
     5     result <- ret => {
     6         // Process result
     7     }
     8     // Messages on err that don't fit this pattern
     9     // aren't intercepted here.
    10     @"TypeError", msg <- err => {
    11         // Handle type error
    12     }
    13 }

1-3). Мы можем указать несколько каналов, по которым данные могут быть отправлены обратно клиенту.

4) В этом контексте `select` ведет себя так же, как` try` на других языках. Только один из получателей на линиях 5 и 10 продолжит работу; они участвуют в гонках, чтобы узнать, кто первым получил сообщение. Если строки 1-3 имеют инвариант, то либо результат отправляется на `ret`, либо ошибка на` err`, тогда не будет гонки. Если, с другой стороны, мы хотим отправить как результат, так и ошибку, вместо этого следует использовать `for`:

    for (@info, ret, err <- channel) {
        // Either return a result on ret or an error on err
    } |
    for(result <- ret) {
        // Process result
    } |
    for(@"TypeError", msg <- err) {
        // Handle type error
    }

10) Шаблон здесь более сложный, чем мы видели раньше. Здесь мы указываем, что нам нужны только сообщения с двумя именами, а первое имя должно быть сериализацией строки `` TypeError``. Если это что-то другое, эта ветка не будет продолжена.

## Обедающие философы и тупик

     1 new north, south, knife, fork in {
     2     north!(knife) |
     3     south!(fork) |
     4     for (knf <- north) for (frk <- south) {
     5         philosopher1!(knf, frk)
     6     } |
     7     for (frk <- south) for (knf <- north) {
     8         philosopher2!(knf, frk)
     9     }
    10 }

Проблема обедающих философов состоит из двух философов, которые разделяют только один набор серебра. Философ1 сидит на восточной стороне стола, а Философ 2 сидит на западе. Каждому нужны как нож, так и вилка, чтобы поесть. Каждый из них отказывается отказаться от посуды, пока не съесь куслк. Если оба философа достигают первую посуду по правую руку, оба голодают: Философ1 получает нож, Философ2 получает вилку и никуда не отпускает.

Вот как решить проблему:

     1 new north, south, knife, spoon in {
     2     north!(knife) |
     3     south!(spoon) |
     4     for (knf <- north; spn <- south) {
     5         philosopher1!(knf, spn)
     6     } |
     7     for (spn <- south; knf <- north) {
     8         philosopher2!(knf, spn)
     9     }
    10 }

4, 7). Оператор объединения, обозначенный точкой с запятой `;`, объявляет, что продолжение должно выполняться только в том случае, если есть сообщение, доступное на каждом из каналов одновременно, предотвращая тупик выше.

## Встроенные типы, постоянная отправка, логические соединения и фильтрация

Мы видели, что шаблоны, которые мы можем использовать в конструкции `match` или в конструкции` for`, включают процессы со свободными переменными. Мы также можем использовать шаблоны, описывающие встроенные процессы. Шаблон `Integer` описывает все 32-разрядные целые числа; аналогично для `Double`,` String` и `Boolean`.

Мы можем комбинировать шаблоны, используя логические связки AND, OR и NOT, обозначенные соответственно `&&`, `||` и `~`.

    for (@ (x && Integer) <- y) {P}

Этот процесс связывает переменную процесса `x` с сообщением, полученным на` y`, но также утверждает, что `x` является целым числом.

Есть американская загадка, в которой говорится: «Как вы разменяете пятнадцать центов , когда одна монета не никель, а другая - ни копейки?» Никель стоит пять центов, а копейка стоит десять. Предположим, что у нас есть следующие сообщения, отправленные на «монеты», кодирующие доступные виды американской монеты со стоимостью менее пятнадцати центов:

    coins!!(1) | coin!!(5) | coin!!(10)

Оператор `!!` означает, что сообщения должны оставаться на канале постоянно и не использоваться, если они получены конструкцией `for`.

      new x in { x!!("Hi there!") | for (msg <= x) { system!("print", msg) } }

Вышеупомянутый процесс напечатает «Hi there!» пока виртуальная машина работает.

Мы можем закодировать загадку как

    for (@(x && ~5) <- coins; @(y && ~10) <- coins if x+y == 15) {
        system!("print", (x, y))
    }

Первый шаблон, `@ (x && ~ 5)`, будет соответствовать любому сообщению на `coins` которое не является 5, и привязать к нему` x`; аналогично, второй шаблон `@ (y && ~ 10)` будет соответствовать любому сообщению на`coins` , которое не равно 10, и привяжет к нему` y`. Предложение `if` в конструкции` for` позволяет  продолжить , если формула справа от нее оценивается как `true`; в этом случае ничего не будет напечатано, если значения не будут равны 15.

Ответ на загадку: «Копейка и никель», поскольку ни копейки не никель, а никель - ни копейки. Переменная `x` будет связываться с 10, а переменная` y` будет привязана к 5, а `(10, 5)` будет напечатана.

## Безопасные шаблоны проектирования

В этом разделе мы описываем несколько шаблонов проектирования. Эти шаблоны адаптированы из «PictureBook of Secure Cooperation» от Марка Штиглера (http://erights.org/talks/efun/SecurityPictureBook.pdf).

### Границы

В контракте MakeCell клиент предоставляет два канала: один для получения значения и один для его настройки. Если клиент затем передает только канал `get` в другой процесс, этот процесс имеет доступ к просмотру ячейки только для чтения.

Такие каналы, как `get` и` set`, называются «гранями» процесса. Они инкапсулируют полномочия для выполнения действия. Если канал `set` является общедоступным каналом, например `@"Foo"`, то любой, кто может узнать или даже угадать строку , `@"Foo"` имеет право устанавливать значение ячейки. С другой стороны, если канал `set` был создан с помощью оператора` new`, тогда нет никакого способа для любого другого процесса построить канал `set`; он должен быть передан процессу непосредственно, чтобы процесс мог его использовать.

Обратите внимание: если `get` и` set` не создаются как половинки iopairs, то владение этими каналами также является полномочием перехватывать сообщения, отправленные в ячейку:

    for (ret <- get) { P } | 
    for (ret <- get) { Q } | 
    get!(*ack)

Этот термин имеет два процесса, прослушивающих канал `get` и одно сообщение, отправленное через` get`. Только один из двух процессов сможет получить сообщение.

Принимая каналы от клиента для получения и настройки, контракт MakeCell оставляет решения о том, как публичные эти каналы принадлежат клиенту. Контракт MakeCellFactory, с другой стороны, создает свои собственные каналы и возвращает их клиенту, поэтому он в состоянии обеспечить гарантии конфиденциальности.

### Аттенюирующие форварды

В контракте MakeCellFactory есть только один канал, и сообщения отправляются внутренне. Чтобы получить тот же эффект, что и факс для чтения, мы можем создать процесс пересылки, который просто игнорирует любые сообщения, которые он не хочет пересылать. Контракт ниже только направляет метод «получить».

    contract MakeGetForwarder(target, ret) = {
        new (portIn, portOut):iopair in {
            ret!(*portOut) |
            for (@method, ...@rest <= portIn) {
                method match {
                    case "get" => target!(method, ...rest)
                }
            }
        }
    }

### Отзыв

Мы можем реализовать аннулирование, создав переадресацию с помощью переключателя kill.

    1 contract MakeRevokableForwarder(target, ret) = {
     2     new (portIn, portOut):iopair, kill, forwardFlag in {
     3         ret!(*portOut, *kill) |
     4         forwardFlag!(true) |
     5         for (...@rest <= portIn) {
     6             for (@status <! forwardFlag) {
     7                 if (status) {
     8                     target!(rest)
     9                 } else {
    10                     Nil
    11                 }
    12             }
    13         } |
    14         for (_ <- kill; _ <- forwardFlag) {
    15             forwardFlag!(false)
    16         }
    17     }
    18 }

2) Мы создаем iopair для отправки метода и канал `forwardFlag` для хранения сообщений о пересылке.

3) Мы возвращаем канал, по которому клиенты отправляют запросы и канал, на который нужно отправить сигнал об ошибке.

4) Мы устанавливаем начальное состояние `forwardFlag` в true.

5-13). Мы читаем в произвольном наборе частей сообщения и получаем значение флага. Если флаг является истинным, мы пересылаем кортеж сообщения `target`.

14-15) Если сообщение отправляется по каналу `kill`, мы устанавливаем` forwardFlag` значение false, которое останавливает пересылку сообщений.

### Состав

Объединив аттенюирующий форвард с форвардером, мы получим обе функции:

    new ret in {
        MakeGetForwarder(target, *ret) |
        for (@getOnly, kill <- ret) {
            MakeRevokableForwarder(getOnly, *ret) |
            for (@revokableGetOnly <- ret) {
                // give away revokableGetOnly instead of target
                // hang onto kill for later revocation
            }
        }
    }

### Регистратор данных

Регистратор данных может записывать все сообщения, отправленные по каналу, эхом  на второй канал.

    contract MakeLoggingForwarder(target, logger, ret) = {
        new (portIn, portOut):iopair in {
            ret!(*portOut) |
            for (...@rest <= portIn) {
                target!(...rest) |
                logger!(...rest)
            }
        }
    }

### Подотчетность

Предположим, что у Алисы есть канал и вы хотите зарегистрировать доступ Боба к нему. Боб хотел бы делегировать использование этого канала Кэрол и зарегистрировать ее доступ. Каждая сторона может свободно создавать свой собственный регистратор данных по каналу, который они получили. Алиса будет держать Боба ответственным за все, что делает Кэрол.

### Скрытие и разблокировка

     1 contract MakeSealerUnsealer(ret) =  {
     2     new (sealerIn, sealerOut):iopair,
     3         (unsealerIn, unsealerOut):iopair,
     4         mapRet in {
     5 
     6         ret!(*sealerOut, *unsealerOut) |
     7         MakeCoatCheck(mapRet) |
     8         for (cc <- mapRet) {
     9             for (@value, ret <= sealerIn) {
    10                 cc!("new", *ret, value)
    11             } |
    12             for (ticket, ret <= unsealerIn) {
    13                 cc!("get", *ret, *ticket)
    14             }
    15         }
    16     }
    17 }

Пара скрытия / разблокировки дает ту же функциональность, что и открытые ключи, но без криптографии. Это просто затухание проверки маски, описанной выше. Этот шаблон дизайна может использоваться для подписи чего-либо от имени пользователя. В учебном блоке Rholang blockchain мы увидим, что он даже работает над блокчейном, потому что нет никаких секретов для хранения, причем только неприемлемые имена остаются недоступными.

### Остерегайтесь отправки ключей

Основным принципом, который следует учитывать при работе с процессами RChain, является тот, который похож на более традиционные веб-приложения: любой код, который вы отправляете другой стороне, может быть разобран. С конца 1990-х годов стало возможным покупать вещи через Интернет, [были платформы для электронной коммерции] (https://blog.detectify.com/2016/11/17/7-most-common-e-commerce- security-errors /), когда платформа полагалась на браузеры пользователей, чтобы отправить правильную цену товара обратно. Авторы не думали о том, что пользователь открывает инструменты разработчика и меняет цену, прежде чем ее отправят обратно. Правильный способ создания платформы электронной коммерции - хранить цены на сервере и проверять их там.

Предположим, что Боб готов запустить код для Алисы; у него есть контракт, который говорит что-то вроде: «Получить процесс с этого канала и запустить его».

    for (@P <- x) { P }

Это похоже на то, что веб-браузер хочет запустить код JavaScript, который он получает с веб-сайта. Если Алиса отправит Бобу данные, Боб может использовать образцы, соответствующие образцу в Rholang, чтобы разделить процесс и получить доступ к базовому ресурсу. Вместо этого, как и в примере с электронной коммерцией, Алисе следует отправлять только код, который пересылает запросы к ее собственным процессам и делает затухание там.

## Вывод

RChain - это язык, предназначенный для использования в блокчейне, но мы ничего не упомянули об узлах, пространствах имен, кошельках, Rev и phlogiston, сетевой структуре или Casper. В предстоящем документе будут рассмотрены все эти вопросы и многое другое.

Мы надеемся, что предыдущие примеры пробуждают желание написать больше кода и продемонстрировать легкость выражения многозадачность проектов.

