# A Rholang підручник

Rholang - цце нова мова програмування, призначена для використання в розподілених системах. Як і всі новонароджені речі, вона зростає і швидко змінюється; цей документ описує синтаксис, який буде використовуватися у версії 0.1 SDK.

Rholang є є "орієнтованою на процес": всі обчислення здійснюються шляхом передачі повідомлення. Повідомлення передаються на "канали", які швидше нагадують черги повідомлень, але ведуть себе як набори, а не черги. Rholang повністю асинхронний, в тому сенсі, що доки ви не прочитаєте повідомлення з каналу, а потім зробите щось із ним, ви не зможете відправити повідомлення, а потім зробити щось, щойно воно буде отримане --- принаймні, не без явного очікування підтвердження від отримувача.

## Контракти та надсилання даних

    1 new helloWorld in {
    2   contract helloWorld(name) = {
    3     "Hello, ".display(name, "!\n")
    4   } |
    5   helloWorld("Joe")
    6 }

1) Програма Rholang - це єдиний процес. Цей процес починається шляхом створення нового каналу під назвою `helloWorld`. Для створення нового приватного каналу ми використовуємо конструкцію `new ... in`. Жоден інший процес не може надсилати та отримувати повідомлення через цей канал, якщо ми не відсилаємо цей канал на інший процес.

2) Виробництво `contract` створює процес, який продукує копію свого змісту, щоразу, коли отримує повідомлення.

3) Метод рядку `display` записує стандартний вивід. Потім набирається список рядків для друку. Тому, щоб це працювати, повідомлення `name` повинно бути ланцюжком.

5) Ми відправляємо рядок `"Joe"` в канал `helloWorld`.

## Отримання даних

     1 new helloAgain in {
     2   contract helloAgain(_) = {
     3     new chan in {
     4       chan("Hello again, world!") |
     5       for (text <- chan) {
     6         text.display("\n")
     7       }
     8     }
     9   } |
    10   helloAgain(Nil)
    11 }

2) Контракти приймають принаймні один параметр, але ми можемо його викинути, зв'язавши його з змінною, яку ми ніколи не використовуємо.

3) Ми створюємо новий канал `chan`.

4) Ми відправляємо рядок процесу `"Hello again, world!"` в новий канал.

5) Ми слухаємо новий канал для одного повідомлення. Операція `for` блокується, доки у каналі `chan` не з'явиться повідомлення. Операція `for` - це як контракт, за винятком того, що він тільки читає одне повідомлення, а потім перетворюється на його зміст, замість того, щоб виготовити копію свого змісту для кожного повідомлення.

## Мутабельний стан

     1 new MakeCell in {
     2   // Makes a single cell in which you can store values
     3   contract MakeCell(init, get, set) = {
     4     new valueStore in {
     5       valueStore(init) |
     6       contract get(ack) = {
     7         for(value <- valueStore) {
     8           valueStore(value) | ack(value)
     9         }
    10       } |
    11       contract set(pair) = {
    12         for(_ <- valueStore) {
    13           match pair with [newValue, ack] => {
    14             valueStore(newValue) | ack(Nil)
    15           }
    16         }
    17       }
    18     }
    19   } |
    20   // Cell usage.
    21   new myGet, mySet in {
    22     MakeCell(123, myGet, mySet) |
    23     new ack in {
    24       myGet(ack) |
    25       for (result <- ack) {
    26         result.display("\n") |
    27         mySet([456, ack]) |
    28         for (_ <- ack) {
    29           myGet(ack) |
    30           for (result <- ack) {
    31             result.display("\n")
    32           }
    33         }
    34       }
    35     }
    36   }
    37 }

1) Ми створюємо новий канал MakeCell, а потім використовуємо його в рядку 3, як назву внутрішнього контракту. Жоден процес, крім коду всередині цієї лексичної області, не може викликати його.

3) Контракт `MakeCell` приймає три аргументи. Перший аргумент - початкове значення, яке потрібно зберегти в ячийці. Другий та третій аргументи - це канали, через які ячійка отримуватиме запити, щоб отримати та встановити значення.

4) Щоб зберегти значення, ми створюємо новий канал. Цей канал матиме щонайбільше одне повідомлення, що містить поточне значення ячійки.

5) Перед цим рядком у каналі `valueStore` немає повідомлень. Після того, як ми надішлемо початкове значення, це буде єдиним значенням цього каналу.

6) Ми створили контракт для прослуховування каналу `get`. Щоразу, коли повідомлення надсилається на `get`, зміст договору буде виконаний.

7) Ми блокуємо, поки не отримаємо одне повідомлення з каналу `valueStore`. Оскільки в режимі `valueStore` є щонайменше одне повідомлення, читання повідомлення поводиться так само, як отримання блокування.

8) Ми відправляємо поточне значення на `valueStore` знову, дозволяючи обробляти інші повідомлення, і ми відправляємо поточне значення назад клієнту на канал `ack`.

11) Паралельно із контрактом `get`, ми виконуємо контракт, прослуховуючи `set`.

12) Ми блокуємо, доки не з'явиться повідомлення про значення `valueStore`, а потім читаємо його. Ми викидаємо повідомлення, яке ми читаємо.

13) Операція `match` виконує декомпозицію `pair`, розбиваючи парний кортеж на свої компоненти та присвоюючи їм імена.

14) Ми відправляємо нове значення для зберігання у `valueStore` та сигналізуємо, що операція завершена.

21-36) Код використання демонструє створення ячійки, присвоюючи початкове значення 123, отримуючи та друкуючи це значення, встановлюючи значення на 456, потім отримуючи та друкуючи це значення.

Зверніть увагу на глибокі шари зворотнього виклику. Rholang була розроблена, щоб зробити паралельні обчислення природними для експресії; як наслідок, залежність даних, що вживаються у послідовності в інших мовах, повинні бути явними.

## Ітерація та відповідність

У наведеному нижче коді `iterate` спочатку надсилає канал `next` через `iterator`, а потім для кожного повідомлення, отримане на` next`, посилає пару, що містить наступний елемент у списку, і чи завершується ітерація.

     1 new iterator, iterate in {
     2     contract iterate(list, iterator) = {
     3         new next, right in {
     4             iterator(next) |
     5             for (_ <- next) {
     6                 contract right(pair) = {
     7                     match pair with [i, limit] => {
     8                         iterator([list.nth(i), i < limit]) |
     9                         for (_ <- next) {
    10                             match i + 1 < limit with true => {
    11                                 right([i + 1, limit]) 
    12                             }
    13                         }
    14                     }
    15                 } |
    16                 right([0, list.size()])
    17             }
    18         }
    19     } |
    20     // Invoke the iterator contract on channel
    21     iterate([4,5,6], iterator) |
    22     
    23     // Interacts with the iterator
    24     for (next <- iterator) {
    25         next(Nil) |
    26         new left in {
    27             contract left(_) = {
    28                 for (pair <- iterator) {
    29                     match pair with [v, keepGoing] => {
    30                         v.display("\n") |
    31                         match keepGoing with true => { 
    32                             next(Nil) |
    33                             left(Nil) 
    34                         }
    35                     }
    36                 }
    37             } |
    38             left(Nil)
    39         }
    40     }
    41 }

7) Конструкція `match .. with` дозволяє деструктуризувати зв'язок.

8) Метод `nth` у кортежах дозволяє витлучати окремі елементи.

16) Кортежі мають метод `size`.

## Карти

     1 new MakeCoatCheck in {
     2     contract MakeCoatCheck(ret) = {
     3         new port, mapStore in {
     4             mapStore(Map()) |
     5             ret(port) |
     6             contract port (method, ack, arg1, arg2) = {
     7                 match method with
     8                 "new" => {
     9                     for (map <- mapStore) {
    10                         new ticket in {
    11                             map.insert(ticket, arg1) |
    12                             mapStore(map) |
    13                             ack(ticket)
    14                         }            
    15                     }
    16                 }
    17                 "get" => {
    18                     for (map <- mapStore) {
    19                         mapStore(map) |
    20                         ack(map.get(arg1))
    21                     }
    22                 }
    23                 "set" => {
    24                     for (map <- mapStore) {
    25                         map.insert(arg1, arg2) |
    26                         mapStore(map) |
    27                         ack(Nil)
    28                     }
    29                 }
    30             }
    31         }
    32     } |
    33 
    34     // Usage
    35     new ret in {
    36         MakeCoatCheck(ret) |
    37         for (cc <- ret) {
    38             // Creates new cell with initial value 0
    39             cc("new", ret, 0, Nil) |
    40             for (ticket <- ret) {
    41                 // Sets the cell to 1
    42                 cc("set", ret, ticket, 1) |
    43                 for (ack <- ret) {
    44                     // Reads the value
    45                     cc("get", ret, ticket, Nil) |
    46                     for (storedValue <- ret) {
    47                         // Prints 1
    48                         storedValue.display("\n")
    49                     }
    50                 }
    51             }
    52         }
    53     }
    54 }

2) Один патерн проектування, що використовується у вищезазначеному контракті MakeCell, полягає в тому, щоб отримати від викликаючого об'єкта канал для кожної окремої частини функціональності, яку забезпечує процес. Об'єктно-орієнтований програміст може сказати, що MakeCell вимагає, щоб викликаючий об'єкт надав канали для кожного методу. Спроби виконуються у порядку, який вони відображають в коді; якщо не відбувається відповідність, блок `match` оцінюється як процес `Nil`.

3-4) Кожна перевірка шару має власну реентрабельну карту, на якій можна зберігати об'єкти. Ми зберігаємо нещодавно побудовану карту на mapStore. Вона має наступний API:

    insert(key, value)
    insertMany(key1, val1, key2, val2, ..., keyn, valn)
    getOrElse(key, default)
    get(key)

6) Ми очікуємо на чотири аргументи щоразу; ми також могли б очікувати одиничного кортежу і використовувати з'єднання деструктуризації для відправлення на основі як методу, так і довжини кортежу.

## Взаємне блокування філософів, що обідають

     1 new north, south, knife, spoon in {
     2     north(knife) |
     3     south(spoon) |
     4     for (knf <- north) { for (spn <- south) {
     5         "Philosopher 1 Utensils: ".display(knf, ", ", spn, "\n") |
     6         north(knf) |
     7         south(spn)
     8     } } |
     9     for (knf <- north) { for (spn <- south) {
    10         "Philosopher 2 Utensils: ".display(knf, ", ", spn, "\n") |
    11         north(knf) |
    12         south(spn)
    13     } }
    14 }

У проблемі філософів, що обідають, є два філософи, які поділяють лише один набір столового срібла. Перший Philosopher1 сидить на східній (east) стороні столу, а другий Philosopher2 сидить на західній (west). Кожен має потребу в ножі та виделці, щоб поїсти. Кожен не бажає відмовлятися від посуду, поки він не використає обидва предмети для своєї вечері. Якщо обидва філософа використають спочатку предмет посуду з правого боку від себе, то обидва голодуватимуть: Philosopher1 отримає ножа, а Philosopher12 отримає виделку, і ніхто з них не поступиться.

Ось як вирішити проблему:

         1 new north, south, knife, spoon in {
     2     north(knife) |
     3     south(spoon) |
     4     for (knf <- north; spn <- south) {
     5         "Philosopher 1 Utensils: ".display(knf, ", ", spn, "\n") |
     6         north(knf) |
     7         south(spn)
     8     } |
     9     for (spn <- south; knf <- north) {
    10         "Philosopher 2 Utensils: ".display(knf, ", ", spn, "\n") |
    11         north(knf) |
    12         south(spn)
    13     }
    14 }

4, 9) Приєднаний оператор, позначений крапкою з комою `;`, оголошує, що продовження слід виконати, лише якщо одночасно є повідомлення, доступне для кожного з каналів, запобігаючи виникненню взаємного блокування вище.

## Захищені патерни проектування

У цьому розділі ми описуємо кілька моделей проектування. Ці патерни адаптовані із книги Марка Стіглера [_Ілюстрована книжка з безпечної співпраці_](http://erights.org/talks/efun/SecurityPictureBook.pdf).

### Грані

У контракті MakeCell клієнт надає два канали, один для отримання вартості, а інший - для її налаштування. Якщо клієнт передає лише канал `get` іншому процесу, цей процес ефективно відображається в режимі лише для читання ячійки.

Канали типу `get` та `set` називаються "гранями" процесу. Вони включають повноваження для виконання дії. Якщо канал `set` є загальнодоступним, наприклад як `@"Foo"`, то кожен, хто може побачити або навіть вгадати рядок `"Foo"`, має право встановлювати значення ячійки. З іншого боку, якщо канал `set` був створений за допомогою оператора `new`, то для іншого процесу неможливо побудувати канал `set`; він повинен бути переданий безпосередньо процесу, щоб цей процес зміг його використовувати.

Зверніть увагу, що позиції `get` і` set` також є повноваженнями для перехоплення повідомлень, надісланих до ячійки:

    for (ret <- get) { P } | 
    for (ret <- get) { Q } | 
    get(ack)

Цей термін має два процеси прослуховування каналів `get` та одне повідомлення, яке надсилається через `get`. Тільки один з двох процесів зможе отримати повідомлення.

Отримавши канали від клієнта для отримання та встановлення, контракт MakeCell залишає рішення про те, як публікувати ці канали для клієнта. Контракт MakeCellFactory, з іншого боку, створює власні канали та повертає їх клієнтові, таким чином він може забезпечити гарантії конфіденційності.

### Послаблені форвардери

 контракті MakeCellFactory існує лише один канал, а повідомлення відправляються внутрішньо. Щоб отримати той самий ефект, що і при грані лише для читання, ми можемо створити процес форвардера, який просто ігнорує повідомлення, які не хоче пересилати. Нижчезазначений контракт передає лише метод "get".

     contract MakeGetForwarder(target, ret) = {
        new port in {
            ret(port) |
            contract port(tuple) = {
                tuple.nth(0) match with "get" => target(tuple)
            }
        }
    }

### Відгук

Ми можемо реалізувати відгук, створивши форвардер з можливістю знищення процесу.

          1 contract MakeRevokableForwarder(target, ret) = {
     2     new port, kill, forwardFlag in {
     3         ret(port, kill) |
     4         forwardFlag(true) |
     5         contract port(tuple) = {
     6             for (status <- forwardFlag) {
     7                 forwardFlag(status) |
     8                 match status with true => { target(tuple) }
     9             }
    10         } |
    11         for (_ <- kill; _ <- forwardFlag) {
    12             forwardFlag(false)
    13         }
    14     }
    15 }

2) Ми створюємо порт для прослуховування викликів методу та канал `forwardFlag` для зберігання передачі повідомлень.

3) Ми повертаємо канал, на який клієнти надсилають запити, іі канал, на який надсилається сигнал знищення.

4) и встановили початковий стан `forwardFlag` на значення true.

5-10) Ми зчитуємо в довільному кортежі частини повідомлень і отримуємо значення флагу. Якщо позначка флагу true, ми пересилаємо кортеж повідомлення на `target`.

11-13) Якщо повідомлення було будь-коли надіслано до каналу `kill`, ми встановлюємо `forwardFlag` на false, що зупиняє переадресацію повідомлень.

### Композиція

Об'єднавши послаблений форвадер із відкличним форвардером, ми отримуємо обидві функції:

    new ret in {
        MakeGetForwarder(target, ret) |
        for (pair <- ret) {
            match pair with [getOnly, kill] => {
                MakeRevokableForwarder(getOnly, ret) |
                for (revokableGetOnly <- ret) {
                    // give away revokableGetOnly instead of target
                    // hang onto kill for later revocation
                }
            }
        }
    }

### Форвардер авторизації

Форвардер авторизації може записувати всі повідомлення, надіслані у канал, повторюючи їх у другому каналі.

    contract MakeLoggingForwarder(target, logger, ret) = {
        new port in {
            ret(port) |
            contract port(tuple) {
                target(tuple) |
                logger(tuple)
            }
        }
    }

### Підзвітність

Припустимо, Аліса має канал і хоче надату Бобу авторизацію для доступу до нього. Боб хотів би делегувати використання цього каналу Керол і авторизувати їй доступ. Кожна сторона має право створювати власний форвардер авторизації в каналі, який вони отримали. Аліса назначить Боба відповідальним за те, що робить Керол.

### Закриття та відкриття

    contract MakeSealerUnsealer(ret) =  {
        new sealer, unsealer, ccRet in {
            ret(sealer, unsealer) |
            MakeCoatCheck(ccRet) |
            for (cc <- ccRet) {
                contract sealer(value, ret) = {
                    cc("new", ret, value, Nil)
                } |
                contract unsealer(ticket, ret) = {
                    cc("get", ret, ticket, Nil)
                }
            }
        }
    }

Пара закриття/відкриття забезпечує таку ж функціональність, як і відкриті ключі, але без криптографії. Це просто послаблення перевірки шару, описаного вище. Цей дизайн патерну можна використовувати для підписання чогось від імені користувача. У посібнику блокчейн Rholang ми бачимо, що він навіть працює на блокчейні, тому що не має секретів для зберігання, тільки невизначені імена залишаються недоступними.

### Остерігайтеся надсилання аттенюаторів

Основний принцип, який слід мати на увазі щодо процесів RChain - це те, що він схожий на більш традиційні веб-програми: будь-який код, який ви надсилаєте іншому учасникові, можна розібрати. З кінця 1990-х років, коли стало можливим купувати речі через Інтернет, [існують e-commerce платформи](https://blog.detectify.com/2016/11/17/7-most-common-e-commerce-security-mistakes/), де платформа спиралася на браузери користувачів, щоб відправити правильну ціну товару назад. Автори не думали про те, що користувач відкриває інструменти для розробників та змінює ціну, перш ніж товар буде відісланий назад. Правильний спосіб побудови e-commerce платформи - зберігати ціни на сервері та перевіряти їх там.

Припустимо, що Боб готовий запустити якийсь код для Аліси; у нього є контракт, який говорить щось на кшталт: "Отримати процес із цього каналу і запустити його".

    for (p <- x) { *p }

Це як веб-браузер, який готовий запустити код JavaScript, який він отримує з веб-сайту. Якщо Аліса надсилає Бобу послаблений форвардер, Боб може використовувати процеси відповідного дизайну в Rholang для розбору процесу і отримання доступу до основного ресурсу. Натомість, як і в прикладі з e-commerce, Аліса повинна надсилати лише код, який пересилає запити до власних процесів і здійснює послаблення там.

## Висновок

RChain це мова, призначена для використання на блокчейні, але ми нічого не згадували про вузли, прості імена, гаманці, Rev та phlogiston, структуру мережі або Casper. У майбутньому документі буде розглянуто всі ці питання та багато іншого.

Ми сподіваємось, що вищенаведені приклади зможуть викликати бажання написати ще більше коду та продемонструвати легкість паралельного проектування.
