syntax = "proto3";
package coop.rchain.casper.protocol;

import "google/protobuf/empty.proto";
import "scalapb/scalapb.proto";
import "RhoTypes.proto";

option (scalapb.options) = {
  package_name: "coop.rchain.casper.protocol"
  flat_package: true
};

// --------- DeployService  --------
service DeployService {
  rpc DoDeploy(DeployString) returns (DeployServiceResponse) {}
  rpc createBlock(google.protobuf.Empty) returns (MaybeBlockMessage) {}
  rpc addBlock(BlockMessage) returns (google.protobuf.Empty) {}
  rpc showBlock(BlockQuery) returns (BlockQueryResponse) {}
  rpc showBlocks(google.protobuf.Empty) returns (BlocksResponse) {}
}

message DeployString {
  bytes  user  = 1; //public key
  int32  nonce = 2; //for uniqueness
  string term  = 3; //rholang source code to deploy (will be parsed into `Par`)
  bytes  sig   = 4; //signature of (hash(resource) + nonce) using private key
}

message BlockRequest {
  //Fields are redundant to allow for validity check.
  //Such a check can definitively distinguish this
  //from other message types with similar serializations.
  string base16Hash = 1;
  bytes  hash       = 2;
}

message BlockQuery {
  string hash = 1;
}

message DeployServiceResponse {
  bool   success = 1;
  string message = 2;
}

message MaybeBlockMessage {
  BlockMessage block = 1;
}

message BlockQueryResponse {
  string status = 1;
  BlockInfo blockInfo = 2;
}

message BlocksResponse {
  string status = 1;
  repeated BlockInfo blocks = 2;
  int64 length = 3;
}

// For node clients, see BlockMessage for actual Casper protocol Block representation
message BlockInfo {
  string blockHash = 1;
  string blockSize = 2;
  int64 blockNumber = 3;
  int64 version = 4;
  int32 deployCount = 5;
  string tupleSpaceHash = 6; // Same as postStateHash of BlockMessage
  string tupleSpaceDump = 7;
  int64 timestamp = 8;
  float faultTolerance = 9;
  string mainParentHash = 10;
  repeated string parentsHashList = 11;
}

// --------- End DeployService  --------

// --------- Core Protocol  --------
message BlockMessage {
  bytes                  blockHash      = 1; // obtained by hashing the information in the header
  Header                 header         = 2;
  Body                   body           = 3;
  repeated Justification justifications = 4; // map of all validators to latest blocks based on current view
  bytes                  sender         = 5; // public key of the validator that created the block
  int32                  seqNum         = 6; // number of blocks created by the validator
  bytes                  sig            = 7; // signature generated by signing `hash(hash(justification) concat blockHash)`.
  string                 sigAlgorithm   = 8; // name of the algorithm used to sign
  bytes extraBytes = 9;
}

message Header {
  repeated bytes parentsHashList = 1; //list of parent block hashes
  bytes postStateHash      = 2;
  bytes newCodeHash        = 3;
  bytes commReductionsHash = 4;
  int64 timestamp = 5;
  int64 version = 6;
  int32 deployCount = 7;
  bytes extraBytes = 8;
}

message Body {
  RChainState     postState      = 1; //will remove sending an explicit postState when history/rollback in tuplespace works
  repeated Deploy newCode        = 2; //new rholang code that was added to the state before processing
  repeated Diff   commReductions = 3; //the comm. rule reductions that occurred to obtain the post-state
  bytes extraBytes = 4;
}

message Justification {
  bytes validator       = 1;
  bytes latestBlockHash = 2;
}

message RChainState {
  bytes tuplespace = 1; //hash of the tuplespace contents

  //Internals of what will be the "blessed" PoS contract
  //(which will be part of the tuplespace in the real implementation).
  repeated Bond bonds        = 2;
  int64         blockNumber  = 3;
}

message Deploy {
  bytes user  = 1; //public key
  int32 nonce = 2; //for uniqueness
  Par   term  = 3; //rholang term to deploy
  bytes sig   = 4; //signature of (hash(resource) + nonce) using private key
}
// --------- End Core Protocol  --------

// --------- Diff Related  --------
// Just a stub until we can do everything in rholang
message Diff {
  oneof diffClass {
    NewTerm    tdiff = 1;
    BondDiff   bdiff = 2;
    UnbondDiff udiff = 3;
  }
}

message NewTerm {
  Par term = 1;
}

message BondDiff {
  Bond added = 1;
}

message UnbondDiff {
  bytes validatorRemoved = 1;
}

message Bond {
  bytes validator = 1;
  int32 stake     = 2;
}
//------------------------------------


