/**
 * The main API is `DeployService`.
 */
syntax = "proto3";
package casper;

// If you are building for other languages "scalapb.proto"
// can be manually obtained here:
// https://raw.githubusercontent.com/scalapb/ScalaPB/master/protobuf/scalapb/scalapb.proto
// make a scalapb directory in this file's location and place it inside

import "scalapb/scalapb.proto";
import "RhoTypes.proto";

option (scalapb.options) = {
  package_name: "coop.rchain.casper.protocol"
  flat_package: true
  single_file: true
  preamble: "sealed trait CasperMessageProto"
  preserve_unknown_fields: false
};

message HasBlockRequestProto {
  option (scalapb.message).extends = "CasperMessageProto";
  bytes  hash       = 1;
}

message HasBlockProto {
  option (scalapb.message).extends = "CasperMessageProto";
  bytes  hash       = 1;
}

message BlockRequestProto {
  option (scalapb.message).extends = "CasperMessageProto";
  bytes  hash       = 1;
}

message ForkChoiceTipRequestProto {
  option (scalapb.message).extends = "CasperMessageProto";
}

// ---------- Signing Protocol ---------
message ApprovedBlockCandidateProto {
  option (scalapb.message).extends = "CasperMessageProto";
  BlockMessageProto block        = 1;
  int32        requiredSigs = 2;
}

message UnapprovedBlockProto {
  option (scalapb.message).extends = "CasperMessageProto";
  ApprovedBlockCandidateProto candidate = 1;
  int64                       timestamp = 2;
  int64                       duration  = 3;
}

message Signature {
  bytes  publicKey = 1;
  string algorithm = 2;
  bytes  sig       = 3;
}

message BlockApprovalProto {
  option (scalapb.message).extends = "CasperMessageProto";
  ApprovedBlockCandidateProto candidate = 1;
  Signature              sig       = 2;
}

message ApprovedBlockProto  {
  option (scalapb.message).extends = "CasperMessageProto";
  ApprovedBlockCandidateProto candidate = 1;
  repeated Signature     sigs      = 2;
}

message ApprovedBlockRequestProto {
  option (scalapb.message).extends = "CasperMessageProto";
  string identifier = 1;
  bool trimState = 2;
}

message NoApprovedBlockAvailableProto {
  option (scalapb.message).extends = "CasperMessageProto";
  string identifier = 1;
  string nodeIdentifer = 2;
}

// ------- End Signing Protocol --------

// --------- Core Protocol  --------
message BlockMessageProto {
  option (scalapb.message).extends = "CasperMessageProto";
  bytes                       blockHash      = 1; // obtained by hashing the information in the header
  HeaderProto                 header         = 2;
  BodyProto                   body           = 3;
  repeated JustificationProto justifications = 4; // map of all validators to latest blocks based on current view
  bytes                       sender         = 5; // public key of the validator that created the block
  int64                       seqNum         = 6; // number of blocks created by the validator
  bytes                       sig            = 7; // signature generated by signing `hash(hash(justification) concat blockHash)`.
  string                      sigAlgorithm   = 8; // name of the algorithm used to sign
  string                      shardId        = 9; // identifier of the shard where the block was created
  bytes                       extraBytes     = 10;
  int64                       finFringeNum   = 11;
}

message BlockHashMessageProto {
  option (scalapb.message).extends = "CasperMessageProto";
  bytes  hash         = 1;
  bytes  blockCreator = 2;
}

message DeployChain {
  repeated bytes deploys       = 1 [(scalapb.field).collection_type="collection.immutable.List"];
}
message BlockMetadataInternal {
  // This message in mapped to a different Scala class because of protobuf's inability to create map<bytes, int64> for
  // bonds.
  option (scalapb.message).type = "coop.rchain.models.BlockMetadata";

  bytes blockHash                       = 1;
  repeated bytes parents                = 2 [(scalapb.field).collection_type="collection.immutable.List"];
  bytes sender                          = 3;
  repeated JustificationProto justifications = 4 [(scalapb.field).collection_type="collection.immutable.List"];
  repeated BondProto bonds                   = 5 [(scalapb.field).collection_type="collection.immutable.List"];
  int64 blockNum                        = 6;
  int64 seqNum                          = 7;
  bool invalid                          = 8; // whether the block was marked as invalid
  bytes postStateHash                    = 11;// whether the block is finalized
  int64 baseFringeNum = 10;
  repeated FringeItemProto finalView                   = 12 [(scalapb.field).collection_type="collection.immutable.List"];
}

message FringeItemProto {
  bytes validator = 1;
  bytes hash     = 2;
}

message HeaderProto {
  repeated bytes parentsHashList = 1; //list of parent block hashes
  int64 timestamp = 5;
  int64 version = 6;
  bytes extraBytes = 7;
}

/**
 * Note: deploys are uniquely keyed by `user`, `timestamp`.
 *
 * **TODO**: details of signatures and payment. See RHOL-781
 */
message DeployDataProto {
  bytes  deployer     = 1; //public key
  string term         = 2; //rholang source code to deploy (will be parsed into `Par`)
  int64  timestamp    = 3; //millisecond timestamp
  bytes  sig          = 4; //signature of (hash(term) + timestamp) using private key
  string sigAlgorithm = 5; //name of the algorithm used to sign
  int64 phloPrice     = 7; //phlo price
  int64 phloLimit     = 8; //phlo limit for the deployment
  int64 validAfterBlockNumber = 10;
}

message ProcessedDeployProto {
    DeployDataProto deploy = 1;
    PCost cost = 2 ;
    repeated EventProto deployLog = 3; //the new terms and comm. rule reductions from this deploy
    bool errored = 5; //true if deploy encountered a user error
    string systemDeployError = 6;
}

message SlashSystemDeployDataProto {
  bytes invalidBlockHash = 1;
  bytes issuerPublicKey = 2;
}

message CloseBlockSystemDeployDataProto{
}

message SystemDeployDataProto{
  oneof systemDeploy{
    SlashSystemDeployDataProto slashSystemDeploy = 1;
    CloseBlockSystemDeployDataProto closeBlockSystemDeploy = 2;
  }
}

message ProcessedSystemDeployProto {
    SystemDeployDataProto systemDeploy = 1;
    repeated EventProto deployLog = 2;
    string errorMsg = 3;
}

message BodyProto {
  RChainStateProto              state    = 1;
  repeated ProcessedDeployProto deploys      = 2;
  repeated ProcessedSystemDeployProto systemDeploys = 3;
  bytes                    extraBytes   = 4;
  repeated RejectedDeployProto rejectedDeploys = 5;
}

message RejectedDeployProto{
  bytes sig = 1;
}

message JustificationProto {
  bytes validator       = 1;
  bytes latestBlockHash = 2;
}

message RChainStateProto {
  bytes preStateHash = 1; //hash of the tuplespace contents before new deploys
  bytes postStateHash = 2; //hash of the tuplespace contents after new deploys

  //Internals of what will be the "blessed" PoS contract
  //(which will be part of the tuplespace in the real implementation).
  repeated BondProto bonds        = 3;
  int64         blockNumber  = 4;
}

message EventProto {
  oneof event_instance {
    ProduceEventProto produce = 1;
    ConsumeEventProto consume = 2;
    CommEventProto comm = 3;
  }
}

message ProduceEventProto {
  bytes channelsHash = 1;
  bytes hash = 2;
  bool persistent = 3;
  int32 timesRepeated = 4;
}

message ConsumeEventProto {
  repeated bytes channelsHashes = 1;
  bytes hash = 2;
  bool persistent = 3;
}

message CommEventProto {
  ConsumeEventProto consume = 1;
  repeated ProduceEventProto produces = 2;
  repeated PeekProto peeks = 3;
}

message PeekProto {
  int32 channelIndex = 1;
}

message BondProto {
  bytes validator = 1;
  int64 stake     = 2;
}
// --------- End Core Protocol  --------

// --------- Last finalized state  --------

message StoreNodeKeyProto {
  bytes hash  = 1;
  int32 index = 2;
}

message StoreItemsMessageRequestProto {
  option (scalapb.message).extends = "CasperMessageProto";
  repeated StoreNodeKeyProto startPath = 1 [(scalapb.field).collection_type="collection.immutable.List"];
  int32 skip                           = 2;
  int32 take                           = 3;
}

message StoreItemProto {
  bytes key   = 1;
  bytes value = 2;
}

message StoreItemsMessageProto {
  option (scalapb.message).extends = "CasperMessageProto";
  repeated StoreNodeKeyProto startPath = 1 [(scalapb.field).collection_type="collection.immutable.List"];
  repeated StoreNodeKeyProto lastPath  = 2 [(scalapb.field).collection_type="collection.immutable.List"];
  repeated StoreItemProto historyItems = 3 [(scalapb.field).collection_type="collection.immutable.List"];
  repeated StoreItemProto dataItems    = 4 [(scalapb.field).collection_type="collection.immutable.List"];
}

// --------- End Last finalized state  --------
