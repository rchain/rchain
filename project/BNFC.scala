import sbt._
import Keys._
import scala.sys.process._
import java.io.File
import java.nio.file.{Files, StandardCopyOption}

object BNFC {

  lazy val BNFCConfig     = config("bnfc")
  lazy val bnfcNamespace  = settingKey[String]("Namespace to prepend to the package/module name")
  lazy val bnfcGrammarDir = settingKey[File]("Directory for BNFC grammar files")
  lazy val bnfcOutputDir  = settingKey[File]("Directory for Java files generated by BNFC")
  lazy val generate       = taskKey[Seq[File]]("Generates Java files from BNFC grammar files")

  def moveFile(source: String, target: String): Unit = {
    val srcPath    = new File(source).toPath
    val targetPath = new File(target).toPath
    Files.move(srcPath, targetPath, StandardCopyOption.REPLACE_EXISTING)
  }

  def nsToPath(ns: String): String =
    ns.replaceAll("\\.", "/")

  def stripSuffix(filename: String): String =
    filename.split("\\.").head

  def makeOutputPath(grammarFile: File, outputDir: File, namespace: String): String =
    s"$outputDir/${nsToPath(namespace)}/${stripSuffix(grammarFile.getName)}"

  def process(cmd: String): Unit = {
    println(s"sys call: $cmd")
    val res = Process(cmd).!
    if (res != 0)
      throw new Error(s"sys call failed: $cmd finished with $res")
  }

  def bnfcGenerateSources(
      fullClasspath: Seq[Attributed[File]],
      grammarFile: File,
      outputDir: File,
      namespace: String
  ): Unit = {
    val targPath: String = makeOutputPath(grammarFile, outputDir, namespace)
    val bnfcCmd: String =
      s"bnfc -l --java --jflex -o ${outputDir.getAbsolutePath} -p $namespace $grammarFile"

    val (classPathSeparator: String, jlexCmd: String) =
      Detector.detect(Seq("fedora")).osName match {
        case "windows" => (";", s"jflex.bat $targPath/Yylex")
        case _         => (":", s"jflex $targPath/Yylex")
      }

    val classpath: String = fullClasspath.map(e => e.data).mkString(classPathSeparator)

    val cupCmd: String =
      s"java -cp $classpath java_cup.Main -locations -expect 100 $targPath/${stripSuffix(grammarFile.getName)}.cup" // TODO: Figure out naming behind _cup.cup

    process(bnfcCmd)
    process(jlexCmd)
    //renaming default _cup
    moveFile(s"$targPath/_cup.cup", s"$targPath/${stripSuffix(grammarFile.getName)}.cup")

    process(cupCmd)

    moveFile("sym.java", s"$targPath/sym.java")
    moveFile("parser.java", s"$targPath/parser.java")
  }

  def bnfcGenerateLaTeX(grammarFile: File, outputDir: File): Unit = {
    val bnfcCmd: String = s"bnfc --latex -o ${outputDir.getAbsolutePath} $grammarFile"
    Process(bnfcCmd) !
  }

  def bnfcFiles(base: File): Seq[File] = (base * "*.cf").get

  lazy val bnfcSettings = {
    inConfig(BNFCConfig)(
      Defaults.configSettings ++ Seq(
        bnfcNamespace  := "coop.rchain.rholang.ast",
        bnfcGrammarDir := baseDirectory.value / "src" / "main" / "bnfc",
        bnfcOutputDir  := (Compile / sourceManaged).value,
        generate := {
          val fullCP = (BNFCConfig / fullClasspath).value
          val genCached = FileFunction.cached(
            streams.value.cacheDirectory / "bnfc",
            inStyle = FilesInfo.hash,
            outStyle = FilesInfo.exists
          ) { (in: Set[File]) =>
            // Take the first BNFC file
            bnfcFiles(in.head).foreach { (f: File) =>
              // Generate Java source files
              bnfcGenerateSources(fullCP, f, bnfcOutputDir.value, bnfcNamespace.value)
              // Generate .tex documentation file
              bnfcGenerateLaTeX(f, bnfcOutputDir.value)
            }
            // Return generated Java files to for sourceGenerators
            (bnfcOutputDir.value ** "*.java").get.toSet
          }
          genCached(Set(bnfcGrammarDir.value)).toSeq
        },
        Compile / sourceGenerators += generate.taskValue
      )
    )
  }
}
