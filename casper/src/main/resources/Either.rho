/*
 The table below describes the required computations and their dependencies

 No. | Dependency | Computation method | Result
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 1.  |            | given              | sk = 5248f8913f8572d8227a3c7787b54bd8263389f7209adc1422e36bb2beb160dc
 2.  |            | given              | timestamp = 1559156217509
 3.  |            | lastNonce          | nonce = 9223372036854775807
 4.  | 1,         | secp256k1          | pk = 04c71f6c7b87edf4bec14f16f715ee49c6fea918549abdf06c734d384b60ba922990317cc4bf68da8c85b455a65595cf7007f1e54bfd6be26ffee53d1ea6d7406b
 5.  | 4, 2,      | genIds             | uname = Unforgeable(0xcaad4e983dedd6c5ae42384b6d87ba6f77997cdf6bb75b8e5f3ffa2133e6b45d)
 6.  | 3, 5,      | registry           | value = (9223372036854775807, bundle+ {   Unforgeable(0xcaad4e983dedd6c5ae42384b6d87ba6f77997cdf6bb75b8e5f3ffa2133e6b45d) })
 7.  | 6,         | protobuf           | toSign = 2a40aa013d0a0d2a0b10feffffffffffffffff010a2c5a2a0a263a240a220a20caad4e983dedd6c5ae42384b6d87ba6f77997cdf6bb75b8e5f3ffa2133e6b45d1001
 8.  | 7, 1,      | secp256k1          | sig = 3045022100aa2bbdd706e157efb6df78156f1520c6422ff651728ccff69d5bffbf901767eb0220799a0451c72c284b1da128f0e4031125dbed9ac8b9de6ce5b0e4d35562ade877
 9.  | 4,         | registry           | uri = rho:id:qrh6mgfp5z6orgchgszyxnuonanz7hw3amgrprqtciia6astt66ypn
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 */
new  Either, rs(`rho:registry:insertSigned:secp256k1`), uriOut, rl(`rho:registry:lookup`), ListOpsCh in {
  for(@(_, ListOps) <- rl!?(`rho:lang:listOps`)) {

    // Like fromNillable, except it takes `valueCh` and reads it to obtain the `value` parameter
    contract Either(return, @"fromNillable <-", valueCh, @nilValue) = {
      for (@value <- valueCh) {
        Either!(*return, "fromNillable", value, nilValue)
      }
    } |

    // Lifts a value into Either, putting Nil-s into Left and using Right otherwise.
    contract Either(return, @"fromNillable", @value, @nilValue) = {
      match value {
        Nil => return!((false, nilValue))
        _   => return!((true, value))
      }
    } |

    // Like fromBoolean, except it takes `successCh` and reads it to obtain the `success` parameter
    contract Either(return, @"fromBoolean <-", successCh, @nilSuccess) = {
      for (@success <- successCh) {
        Either!(*return, "fromBoolean", success, nilSuccess)
      }
    } |

    // Lifts a Boolean into Either, making `false` into Left and using Right otherwise.
    contract Either(return, @"fromBoolean", @success, @failureMessage) = {
      match success {
        false => return!((false, failureMessage))
        true  => return!((true, Nil))
      }
    } |

    // Like fromSingletonList, except it takes `listCh` and reads it to obtain the `list` parameter
    contract Either(return, @"fromSingletonList <-", listCh, @failureMessage) = {
      for (@list <- listCh) {
        Either!(*return, "fromSingletonList", list, failureMessage)
      }
    } |

    // Converts a singleton list into Either, making the single element into Right
    // and using Left if it's not a singleton list.
    contract Either(return, @"fromSingletonList", @list, @failureMessage) = {
      match list {
        []      => return!((false, failureMessage))
        [value] => return!((true, value))
        _       => return!((false, "Invalid argument, expected a list of at most 1 element"))
      }
    } |

    // Like fromNillableError, except it takes `errorCh` and reads it to obtain the `error` parameter
    contract Either(return, @"fromNillableError <-", errorCh) = {
      for (@error <- errorCh) {
        Either!(*return, "fromNillableError", error)
      }
    } |

    // Lifts an error into Either, putting Nil-s into Right and using Left otherwise.
    contract Either(return, @"fromNillableError", @error) = {
      match error {
        Nil => return!((true, Nil))
        _   => return!((false, error))
      }
    } |

    // Like productR, except it takes `aCh` and `bCh` and reads them to obtain the `a` and `b` parameters
    contract Either(return, @"productR <-", aCh, bCh) = {
      for (@a <- aCh) {
        for (@b <- bCh) {
          Either!(*return, "productR", a, b)
        }
      }
    } |

    // Combines two eithers, discarding the first Right value and keeping the second.  Propagates Lefts.
    contract Either(return, @"productR", @a, @b) = {
      match (a, b) {
        ((false, _), _) => return!(a)
        _ => return!(b)
      }
    } |

    // Like map2, except it takes `aCh` and `bCh` and reads them to obtain the `a` and `b` parameters
    contract Either(return, @"map2 <-", aCh, bCh, @f) = {
      for (@a <- aCh) {
        for (@b <- bCh) {
          Either!(*return, "map2", a, b, f)
        }
      }
    } |

    // Like map2Clean, except it takes `aCh` and `bCh` and reads them to obtain the `a` and `b` parameters
    contract Either(return, @"map2Clean <-", aCh, bCh, @f, @state) = {
      for (@a <- aCh) {
        for (@b <- bCh) {
          Either!(*return, "map2Clean", a, b, f, state)
        }
      }
    } |

    // Composes two eithers `a: A` and `b: B` using the function `f`. See cats.Apply.map2 for details.`
    contract Either(return, @"map2", @a, @b, @f) = {
      match (a, b) {
        ((false, _), _)          => return!(a)
        (_, (false, _))          => return!(b)
        ((true, va), (true, vb)) => {
          match f {
            { for (r, x, y  <- fName) { _ } } => {
              f |
              for (@v <- fName!?(va, vb)) {
                return!((true, v))
              }
            }
          }
        }
      }
    } |

    // Like map2, but allows passing state to f instead of making f close over it.
    contract Either(return, @"map2Clean", @a, @b, @f, @state) = {
      match (a, b) {
        ((false, _), _)          => return!(a)
        (_, (false, _))          => return!(b)
        ((true, va), (true, vb)) => {
          match f {
            { for (r, @state, x, y  <- fName) { _ } } => {
              f |
              for (@v <- fName!?(state, va, vb)) {
                return!((true, v))
              }
            }
          }
        }
      }
    } |

    // Like flatMap, except it takes `eitherCh` and reads it to obtain the `either` parameter
    contract Either(return, @"flatMap <-", eitherCh, f) = {
      for (@either <- eitherCh) {
        Either!(*return, "flatMap", either, *f)
      }
    } |

    // Like flatMapClean, except it takes `eitherCh` and reads it to obtain the `either` parameter
    contract Either(return, @"flatMapClean <-", eitherCh, f, @state) = {
      for (@either <- eitherCh) {
        Either!(*return, "flatMapClean", either, *f, state)
      }
    } |

    // Right-biased flatMap; f must also return an Either
    contract Either(return, @"flatMap", @either, f) = {
      match either {
        (true, value) => { f!(*return, value) }
        (false, _)    => { return!(either) }
      }
    } |

    // Like flatMap, except it allows passing state to f instead of making f close over it.
    contract Either(return, @"flatMapClean", @either, f, @state) = {
      match either {
        (true, value) => { f!(*return, state, value) }
        (false, _)    => { return!(either) }
      }
    } |

    // Like map, except it takes `eitherCh` and reads it to obtain the `either` parameter
    contract Either(return, @"map <-", eitherCh, f) = {
      for (@either <- eitherCh) {
        Either!(*return, "map", either, *f)
      }
    } |

    // Like mapClean, except it takes `eitherCh` and reads it to obtain the `either` parameter
    contract Either(return, @"mapClean <-", eitherCh, f, @state) = {
      for (@either <- eitherCh) {
        Either!(*return, "mapClean", either, *f, state)
      }
    } |

    // Right-biased map to transform an Either
    contract Either(return, @"map", @either, f) = {
      match either {
        (true, value) => {
          for(@mappedResult <- f!?(value) ) {
            return!((true, mappedResult))
          }
        }
        (false, _) => return!(either)
      }
    } |

    // Like map, except it allows passing state to f instead of making f close over it.
    contract Either(return, @"mapClean", @either, f, @state) = {
      match either {
        (true, value) => {
          for(@mappedResult <- f!?(state, value)) {
            return!((true, mappedResult))
          }
        }
        (false, _) => return!(either)
      }
    } |

    new combinator in {
      contract combinator(return, _, @head, @accumulatedValue) = {
        Either!(*return, "flatMap", accumulatedValue, head)
      } |

      // Composes a list of functions returning Either into a
      // single result by using flatMap. Similar to following Scala code:
      // for {
      //   r0 <- Right(input)
      //   r1 <- f1(r0)
      //   r2 <- f2(r1)
      //   ...
      // } yield fn
      contract Either(return, @"compose", @input, @functions) = {
        @ListOps!(*return, "foldClean", functions, (true, input), *combinator, Nil)
      }
    } |

    new combinator in {
      contract combinator(return, _, @(function, state), @accumulatedValue) = {
        Either!(*return, "flatMapClean", accumulatedValue, function, state)
      } |

      // Like compose, but allows passing state to each f in the list instead of making f close over it
      contract Either(return, @"composeClean", @input, @functionStatePairs) = {
        @ListOps!(*return, "foldClean", functionStatePairs, (true, input), *combinator, Nil)
      }
    }
  } |
  
  rs!(
    *uriOut,
    "04c71f6c7b87edf4bec14f16f715ee49c6fea918549abdf06c734d384b60ba922990317cc4bf68da8c85b455a65595cf7007f1e54bfd6be26ffee53d1ea6d7406b".hexToBytes(),
    (9223372036854775807, bundle+{*Either}),
    "3045022100aa2bbdd706e157efb6df78156f1520c6422ff651728ccff69d5bffbf901767eb0220799a0451c72c284b1da128f0e4031125dbed9ac8b9de6ce5b0e4d35562ade877".hexToBytes(),
  )
}
  
  
