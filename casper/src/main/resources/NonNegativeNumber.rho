/*
 The table below describes the required computations and their dependencies

 No. | Dependency | Computation method | Result
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 1.  |            | given              | sk = e33c9f1e925819d04733db4ec8539a84507c9e9abd32822059349449fe03997d
 2.  |            | given              | timestamp = 1559156251792
 3.  |            | lastNonce          | nonce = 9223372036854775807
 4.  | 1,         | secp256k1          | pk = 04e1559d809924e564dce57e34646e155b144d2a504ce7ee519d7a5108fd42f1038d08d745e5ea21cb53d6aa7c7174a768fa373207a83bc947a20c6a02ece7a60e
 5.  | 4, 2,      | genIds             | uname = Unforgeable(0x61657f51076320deb7358dfcfc1f703be818ee08876c8b8efbfdf6e9d3020bcd)
 6.  | 3, 5,      | registry           | value = (9223372036854775807, bundle+ {   Unforgeable(0x61657f51076320deb7358dfcfc1f703be818ee08876c8b8efbfdf6e9d3020bcd) })
 7.  | 6,         | protobuf           | toSign = 2a40aa013d0a0d2a0b10feffffffffffffffff010a2c5a2a0a263a240a220a2061657f51076320deb7358dfcfc1f703be818ee08876c8b8efbfdf6e9d3020bcd1001
 8.  | 7, 1,      | secp256k1          | sig = 304402202b27c904bcecd83a7355db7f235fbe447c692079325deeefacba62c8ee236eb9022077b97df4e21784897e6da490b4b60c420a1db64b5807ad98acefa0a38c7f6f22
 9.  | 4,         | registry           | uri = rho:id:hxyadh1ffypra47ry9mk6b8r1i33ar1w9wjsez4khfe9huzrfcytx9
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 */

new
  NonNegativeNumber,
  NonNegativeNumberLoc,
  NonNegativeNumberDispatcher,
  rb(`rho:registry:insertBlessed`),
  rs(`rho:registry:insertSigned:secp256k1`),
  uriOut
in {
  contract NonNegativeNumber(@init, return) = {
    new this, valueStore in {
      contract this(@"add", @x, success) = {
        if (x >= 0) {
          for(@v <- valueStore){
            if (v + x >= v) {
              valueStore!(v + x) | success!(true)
            } else {
              //overflow
              valueStore!(v) | success!(false)
            }
          }
        } else {
          success!(false)
        }
      } |
      contract this(@"sub", @x, success) = {
        if (x >= 0) {
          for(@v <- valueStore) {
            if (x <= v) {
              valueStore!(v - x) | success!(true)
            } else {
              valueStore!(v) | success!(false)
            }
          }
        } else {
          success!(false)
        }
      } |
      contract this(@"value", return) = {
        for(@v <- valueStore) {
          valueStore!(v) | return!(v)
        }
      } |
      return!(bundle+{*this}) |
      match init { //Initial balance is zero if given is negative on non-integer
        Int => {
          if (init > 0) {
            valueStore!(init)
          } else {
            valueStore!(0)
          }
        }
         _ => { valueStore!(0) }
      }
    }
  } |
  // No internal state to return.
  // Method required for updates.
  contract NonNegativeNumber(@"extractState", ret) = {
    ret!([])
  } |
  // Dispatcher contract
  // for use with 1-9 arguments
  contract NonNegativeNumberDispatcher(@arg1) = {
    for (realNNN <<- NonNegativeNumberLoc) {
      realNNN!(arg1)
    }
  } |
  contract NonNegativeNumberDispatcher(@arg1, @arg2) = {
    for (realNNN <<- NonNegativeNumberLoc) {
      realNNN!(arg1, arg2)
    }
  } |
  contract NonNegativeNumberDispatcher(@arg1, @arg2, @arg3) = {
    for (realNNN <<- NonNegativeNumberLoc) {
      realNNN!(arg1, arg2, arg3)
    }
  } |
  contract NonNegativeNumberDispatcher(@arg1, @arg2, @arg3, @arg4) = {
    for (realNNN <<- NonNegativeNumberLoc) {
      realNNN!(arg1, arg2, arg3, arg4)
    }
  } |
  contract NonNegativeNumberDispatcher(@arg1, @arg2, @arg3, @arg4, @arg5) = {
    for (realNNN <<- NonNegativeNumberLoc) {
      realNNN!(arg1, arg2, arg3, arg4, arg5)
    }
  } |
  contract NonNegativeNumberDispatcher(@arg1, @arg2, @arg3, @arg4, @arg5, @arg6) = {
    for (realNNN <<- NonNegativeNumberLoc) {
      realNNN!(arg1, arg2, arg3, arg4, arg5, arg6)
    }
  } |
  contract NonNegativeNumberDispatcher(@arg1, @arg2, @arg3, @arg4, @arg5, @arg6, @arg7) = {
    for (realNNN <<- NonNegativeNumberLoc) {
      realNNN!(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
    }
  } |
  contract NonNegativeNumberDispatcher(@arg1, @arg2, @arg3, @arg4, @arg5, @arg6, @arg7, @arg8) = {
    for (realNNN <<- NonNegativeNumberLoc) {
      realNNN!(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
    }
  } |
  contract NonNegativeNumberDispatcher(@arg1, @arg2, @arg3, @arg4, @arg5, @arg6, @arg7, @arg8, @arg9) = {
    for (realNNN <<- NonNegativeNumberLoc) {
      realNNN!(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
    }
  } |
  // Put NNN contract on the location channel
  NonNegativeNumberLoc!(bundle+{*NonNegativeNumber}) |
  // Insert the contract location in the registry location map
  rb!(`rho:lang:nonNegativeNumber`, *NonNegativeNumberLoc) |
  // Inserts signed write-only dispatcher contract into the registry
  rs!(
    "04e1559d809924e564dce57e34646e155b144d2a504ce7ee519d7a5108fd42f1038d08d745e5ea21cb53d6aa7c7174a768fa373207a83bc947a20c6a02ece7a60e".hexToBytes(),
    (9223372036854775807, bundle+{*NonNegativeNumberDispatcher}),
    "304402202b27c904bcecd83a7355db7f235fbe447c692079325deeefacba62c8ee236eb9022077b97df4e21784897e6da490b4b60c420a1db64b5807ad98acefa0a38c7f6f22".hexToBytes(),
    *uriOut
  )
}
  
  
