new _registryStore,
    lookupCh,
    bootstrapLookup(`rho:registry:lookup`),
    insertArbitraryCh,
    bootstrapInsertArbitrary(`rho:registry:insertArbitrary`),
    insertSignedCh,
    bootstrapInsertSigned(`rho:registry:insertSigned:secp256k1`),
    buildUri,
    ops(`rho:registry:ops`),
    secpVerify(`rho:crypto:secp256k1Verify`),
    blake2b256(`rho:crypto:blake2b256Hash`),
    TreeHashMap
in {

  // TreeHashMap is defined here because the registry uses it internally.
  // We can't define it in another file like MakeMint or NonNegativeNumber because
  // that method assumes the registry already exists.

  // Rholang map desiderata: speedy insert & lookup,  no conflicts on lookup, no conflicts on inserts to different keys
  // This implementation: O(log n) insert & lookup; also provides O(1) lookup when it is known that the value at a key exists.
  // Conflict analysis
  //   Lookup
  //     When looking up a value, only peeks are used, so lookups will not conflict.
  //   Insert
  //     When inserting, only peeks are used on existing nodes (except the last
  //     shared one in the path), while newly created nodes have a different name.
  //     So there's conflict only if the keys share a common prefix that hadn't
  //     already been populated.
  // Usage
  // new o(`rho:io:stdout`), mapCh in {
  //   o!("Initializing map") |
  //   // Use 3 * 8 = 24 bits of parallelization
  //   TreeHashMap!("init", 3, *mapCh) |
  //   for (@map <- mapCh) {
  //     o!("Map initialized, setting") |
  //     new ret1, ret2, ret3, ret4, ret5, ret6, ret7 in {
  //       TreeHashMap!("set", map, "some key", "some val", *ret1) |
  //       TreeHashMap!("set", map, "monkey", "some other val", *ret2) |
  //       TreeHashMap!("set", map, "donkey", Nil, *ret3) |
  //       for (_ <- ret1 & _ <- ret2 & _ <- ret3) {
  //         o!("Value set, getting") |
  //         TreeHashMap!("get", map, "some key", *ret1) |             // "some val"
  //         TreeHashMap!("fastUnsafeGet", map, "monkey", *ret2) |     // "some other val"
  //         TreeHashMap!("get", map, "some unused key", *ret3) |      // Nil
  //         TreeHashMap!("fastUnsafeGet", map, "donkey", *ret4) |     // Nil
  //         TreeHashMap!("contains", map, "donkey", *ret5) |          // true
  //         TreeHashMap!("contains", map, "monkey", *ret6) |          // true
  //         TreeHashMap!("contains", map, "some unused key", *ret7) | // false
  //         for (@val1 <- ret1 & @val2 <- ret2 & @val3 <- ret3 & @val4 <- ret4 & @val5 <- ret5 & @val6 <- ret6 & @val7 <- ret7) {
  //           o!(["Got these from the map: ", val1, val2, val3, val4, val5, val6, val7])
  //         }
  //       }
  //     }
  //   }
  // }

  new MakeNode, ByteArrayToNybbleList,
      TreeHashMapSetter, TreeHashMapGetter, TreeHashMapContains, TreeHashMapUpdater,
      powersCh, storeToken, nodeGet in {
    let @powers <- [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536] in {
      contract MakeNode(@initVal, @node) = {
        @[node, *storeToken]!(initVal)
      } |

      contract nodeGet(ret, @node) = {
        for (@val <<- @[node, *storeToken]) {
          ret!(val)
        }
      } |

      contract ByteArrayToNybbleList(ret, @ba, @n, @len, @acc) = {
        if (n == len) {
          ret!(acc)
        } else {
          ByteArrayToNybbleList!(*ret, ba, n+1, len, acc ++ [ ba.nth(n) % 16, ba.nth(n) / 16 ])
        }
      } |

      contract TreeHashMap(ret, @"init", @depth) = {
        new map in {
          MakeNode!(0, (*map, [])) |
          @(*map, "depth")!!(depth) |
          ret!(*map)
        }
      } |

      contract TreeHashMapGetter(ret, @map, @nybList, @n, @len, @suffix) = {
        // Look up the value of the node at (map, nybList.slice(0, n + 1))
        for (@val <- nodeGet!?((map, nybList.slice(0, n)))) {
          if (n == len) {
            ret!(val.get(suffix))
          } else {
            // Otherwise check if the rest of the path exists.
            // Bit k set means node k exists.
            // nybList.nth(n) is the node number
            // val & powers.nth(nybList.nth(n)) is nonzero if the node exists
            // (val / powers.nth(nybList.nth(n))) % 2 is 1 if the node exists
            if ((val / powers.nth(nybList.nth(n))) % 2 == 0) {
              ret!(Nil)
            } else {
              TreeHashMapGetter!(*ret, map, nybList, n + 1, len, suffix)
            }
          }
        }
      } |

      contract TreeHashMap(ret, @"get", @map, @key) = {
        new keccak256Hash(`rho:crypto:keccak256Hash`) in {
          // Hash the key to get a 256-bit array
          for (@hash <- keccak256Hash!?(key.toByteArray()); @depth <<- @(map, "depth")) {
            // Get the bit list
            for (@nybList <- ByteArrayToNybbleList!?(hash, 0, depth, [])) {
              TreeHashMapGetter!(*ret, map, nybList, 0, 2 * depth, hash.slice(depth, 32))
            }
          }
        }
      } |

      // Doesn't walk the path, just tries to fetch it directly.
      // Will hang if there's no key with that 64-bit prefix.
      // Returns Nil like "get" does if there is some other key with
      // the same prefix but no value there.
      contract TreeHashMap(ret, @"fastUnsafeGet", @map, @key) = {
        new keccak256Hash(`rho:crypto:keccak256Hash`) in {
          // Hash the key to get a 256-bit array
          for (@hash <- keccak256Hash!?(key.toByteArray()); @depth <<- @(map, "depth")) {
            // Get the bit list
            for (@nybList <- ByteArrayToNybbleList!?(hash, 0, depth, [])) {
              for (@rest <- nodeGet!?((map, nybList))) {
                ret!(rest.get(hash.slice(depth, 32)))
              }
            }
          }
        }
      } |

      contract TreeHashMapSetter(ret, @map, @nybList, @n, @len, @newVal, @suffix) = {
        // Look up the value of the node at (map, nybList.slice(0, n + 1))
        let @node <- (map, nybList.slice(0, n)) in { 
          for (@val <<- @[node, *storeToken]) {
            if (n == len) {
              // Acquire the lock on this node
              for (@val <- @[node, *storeToken]) {
                // If we're at the end of the path, set the node to newVal.
                if (val == 0) {
                  // Release the lock
                  @[node, *storeToken]!({suffix: newVal}) |
                  // Return
                  ret!(Nil)
                }
                else {
                  // Release the lock
                  @[node, *storeToken]!(val.set(suffix, newVal)) |
                  // Return
                  ret!(Nil)
                }
              }
            } else {
              // Otherwise make the rest of the path exist.
              // Bit k set means child node k exists.
              if ((val/powers.nth(nybList.nth(n))) % 2 == 0) {
                // Child node missing
                // Acquire the lock
                for (@val <- @[node, *storeToken]) {
                  // Re-test value
                  if ((val/powers.nth(nybList.nth(n))) % 2 == 0) {
                    // Child node still missing
                    // Create node, set node to 0
                    MakeNode!(0, (map, nybList.slice(0, n + 1))) |
                    // Update current node to val | (1 << nybList.nth(n))
                    match nybList.nth(n) {
                      bit => {
                        // val | (1 << bit)
                        // Bitwise operators would be really nice to have!
                        // Release the lock
                        @[node, *storeToken]!((val % powers.nth(bit)) +
                          (val / powers.nth(bit + 1)) * powers.nth(bit + 1) +
                          powers.nth(bit))
                      }
                    } |
                    // Child node now exists, loop
                    TreeHashMapSetter!(*ret, map, nybList, n + 1, len, newVal, suffix)
                  } else {
                    // Child node created between reads
                    // Release lock
                    @[node, *storeToken]!(val) |
                    // Loop
                    TreeHashMapSetter!(*ret, map, nybList, n + 1, len, newVal, suffix)
                  }
                }
              } else {
                // Child node exists, loop
                TreeHashMapSetter!(*ret, map, nybList, n + 1, len, newVal, suffix)
              }
            }
          }
        }
      } |

      contract TreeHashMap(ret, @"set", @map, @key, @newVal) = {
        new keccak256Hash(`rho:crypto:keccak256Hash`) in {
          // Hash the key to get a 256-bit array
          for (@hash <- keccak256Hash!?(key.toByteArray()); @depth <<- @(map, "depth")) {
            // Get the bit list
            for (@nybList <- ByteArrayToNybbleList!?(hash, 0, depth, [])) {
              TreeHashMapSetter!(*ret, map, nybList, 0, 2 * depth, newVal, hash.slice(depth, 32))
            }
          }
        }
      } |

      contract TreeHashMapContains(ret, @map, @nybList, @n, @len, @suffix) = {
      // Look up the value of the node at [map, nybList.slice(0, n + 1)]
        for (@val <- nodeGet!?((map, nybList.slice(0, n)))) {
          if (n == len) {
            ret!(val.contains(suffix))
          } else {
            // See getter for explanation of formula
            if ((val/powers.nth(nybList.nth(n))) % 2 == 0) {
              ret!(false)
            } else {
              TreeHashMapContains!(*ret, map, nybList, n + 1, len, suffix)
            }
          }
        }
      } |

      contract TreeHashMap(ret, @"contains", @map, @key) = {
        new keccak256Hash(`rho:crypto:keccak256Hash`) in {
          // Hash the key to get a 256-bit array
          for (@hash <- keccak256Hash!?(key.toByteArray()); @depth <<- @(map, "depth")) {
            // Get the bit list
            for (@nybList <- ByteArrayToNybbleList!?(hash, 0, depth, [])) {
              TreeHashMapContains!(*ret, map, nybList, 0, 2 * depth, hash.slice(depth, 32))
            }
          }
        }
      } |

      contract TreeHashMapUpdater(ret, @map, @nybList, @n, @len, update, @suffix) = {
        // Look up the value of the node at [map, nybList.slice(0, n + 1)
        let @node <- (map, nybList.slice(0, n)) in {
          for (@val <<- @[node, *storeToken]) {
            if (n == len) {
              // We're at the end of the path.
              if (val == 0) {
                // There's nothing here.
                // Return
                ret!(Nil)
              } else {
                // Acquire the lock on this node
                for (@val <- @[node, *storeToken]; @newVal <- update!?(val.get(suffix))) {
                  // Release the lock
                  @[node, *storeToken]!(val.set(suffix, newVal)) |
                  // Return
                  ret!(Nil)
                }
              }
            } else {
              // Otherwise try to reach the end of the path.
              // Bit k set means child node k exists.
              if ((val/powers.nth(nybList.nth(n))) % 2 == 0) {
                // If the path doesn't exist, there's no value to update.
                // Return
                ret!(Nil)
              } else {
                // Child node exists, loop
                TreeHashMapUpdater!(*ret, map, nybList, n + 1, len, *update, suffix)
              }
            }
          }
        }
      } |
      contract TreeHashMap(ret , @"update", @map, @key, update) = {
        new keccak256Hash(`rho:crypto:keccak256Hash`) in {
          // Hash the key to get a 256-bit array
          for (@hash <- keccak256Hash!?(key.toByteArray()); @depth <<- @(map, "depth")) {
            // Get the bit list
            for (@nybList <- ByteArrayToNybbleList!?(hash, 0, depth, [])) {
              TreeHashMapUpdater!(*ret, map, nybList, 0, 2 * depth, *update, hash.slice(depth, 32))
            }
          }
        }
      }
    }
  } |

  // Use 4 * 8 = 32-bit paths to leaf nodes.
  TreeHashMap!(*_registryStore, "init", 4) |
  for (@map <<- _registryStore) {
    for (_ <- TreeHashMap!?("set", map, `rho:lang:treeHashMap`, bundle+{*TreeHashMap})) {
      bootstrapLookup!(*lookupCh) | // this will work only once
      for (lookup <- lookupCh) {
        contract lookup(ret, @uriOrShorthand) = {
          match {
            `rho:lang:either` : `rho:id:qrh6mgfp5z6orgchgszyxnuonanz7hw3amgrprqtciia6astt66ypn`,
            `rho:lang:listOps` : `rho:id:6fzorimqngeedepkrizgiqms6zjt76zjeciktt1eifequy4osz35ks`,
            `rho:lang:nonNegativeNumber` : `rho:id:hxyadh1ffypra47ry9mk6b8r1i33ar1w9wjsez4khfe9huzrfcytx9`,
            `rho:rchain:authKey` : `rho:id:1qw5ehmq1x49dey4eadr1h4ncm361w3536asho7dr38iyookwcsp6i`,
            `rho:rchain:makeMint` : `rho:id:asysrwfgzf8bf7sxkiowp4b3tcsy4f8ombi3w96ysox4u3qdmn1wbc`,
            `rho:rchain:pos` : `rho:id:m3xk7h8r54dtqtwsrnxqzhe81baswey66nzw6m533nyd45ptyoybqr`,
            `rho:rchain:revVault` : `rho:id:6zcfqnwnaqcwpeyuysx1rm48ndr6sgsbbgjuwf45i5nor3io7dr76j`,
            `rho:rchain:multiSigRevVault` : `rho:id:b9s6j3xeobgset4ndn64hje64grfcj7a43eekb3fh43yso5ujiecfn`
          } {
            shorthands => {
              for (@map <<- _registryStore) {
                TreeHashMap!(*ret, "get", map, shorthands.getOrElse(uriOrShorthand, uriOrShorthand))
              }
            }
          }
        }
      }
    }
  } |



  bootstrapInsertArbitrary!(*insertArbitraryCh) | // this will work only once
  for (insertArbitrary <- insertArbitraryCh) {
    contract insertArbitrary(ret, @data) = {
      new seed in {
        for (@uri <- ops!?("buildUri", *seed.toByteArray()); @map <<- _registryStore) {
          TreeHashMap!?("set", map, uri, data); ret!(uri)
        }
      }
    }
  } |

  bootstrapInsertSigned!(*insertSignedCh) | // this will work only once
  for (insertSigned <- insertSignedCh) {

    contract insertSigned(ret, @pubKeyBytes, @value, @sig) = {
      let  @(nonce, data) <- value in  {
        for (@hash <- blake2b256!?((nonce, data).toByteArray());
              @verified <- secpVerify!?(hash, sig, pubKeyBytes)) {
          if (verified) {
            for (@uri <- ops!?("buildUri", pubKeyBytes); @map <<- _registryStore) {
              for (@response <- TreeHashMap!?("get", map, uri)) {
                match response {
                  Nil => {
                    TreeHashMap!?("set", map, uri, (nonce, data)); ret!(uri)
                  }
                  (oldNonce, _) => {
                    if (nonce > oldNonce) {
                      TreeHashMap!?("set", map, uri, (nonce, data)); ret!(uri)
                    } else {
                      ret!(Nil)
                    }
                  }
                }
              }
            }
          } else {
            ret!(Nil)
          }
        }
      }
    }
  }
}