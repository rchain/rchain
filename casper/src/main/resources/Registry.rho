new
  _registryStore,
  lookupCh,
  bootstrapLookup(`rho:registry:lookup`),
  insertArbitraryCh,
  bootstrapInsertArbitrary(`rho:registry:insertArbitrary`),
  insertSignedCh,
  bootstrapInsertSigned(`rho:registry:insertSigned:secp256k1`),
  insertBlessedCh,
  bootstrapInsertBlessed(`rho:registry:insertBlessed`),
  blessedContractLocMapCh,
  buildUri,
  ops(`rho:registry:ops`),
  secpVerify(`rho:crypto:secp256k1Verify`),
  blake2b256(`rho:crypto:blake2b256Hash`),
  TreeHashMap,
  TreeHashMapLoc,
  TreeHashMapDispatcher,
  MultiSig,
  msRet,
  secpVerify(`rho:crypto:secp256k1Verify`),
  blake2b256(`rho:crypto:blake2b256Hash`),
  hashVerify
in {
  contract hashVerify(@data, @sig, @pubKey, ret) = {
    new hashCh in {
      // hash the data
      blake2b256!(data.toByteArray(), *hashCh) |
      for (@hash <- hashCh) {
        // verify the signature
        secpVerify!(hash, sig, pubKey, *ret)
      }
    }
  } |
  // TreeHashMap is defined here because the registry uses it internally.
  // We can't define it in another file like MakeMint or NonNegativeNumber because
  // that method assumes the registry already exists.

  // Rholang map desiderata: speedy insert & lookup,  no conflicts on lookup, no conflicts on inserts to different keys
  // This implementation: O(log n) insert & lookup; also provides O(1) lookup when it is known that the value at a key exists.
  // Conflict analysis
  //   Lookup
  //     When looking up a value, only peeks are used, so lookups will not conflict.
  //   Insert
  //     When inserting, only peeks are used on existing nodes (except the last
  //     shared one in the path), while newly created nodes have a different name.
  //     So there's conflict only if the keys share a common prefix that hadn't
  //     already been populated.
  // Usage
  // new o(`rho:io:stdout`), mapCh in {
  //   o!("Initializing map") |
  //   // Use 3 * 8 = 24 bits of parallelization
  //   TreeHashMap!("init", 3, *mapCh) |
  //   for (@map <- mapCh) {
  //     o!("Map initialized, setting") |
  //     new ret1, ret2, ret3, ret4, ret5, ret6, ret7 in {
  //       TreeHashMap!("set", map, "some key", "some val", *ret1) |
  //       TreeHashMap!("set", map, "monkey", "some other val", *ret2) |
  //       TreeHashMap!("set", map, "donkey", Nil, *ret3) |
  //       for (_ <- ret1 & _ <- ret2 & _ <- ret3) {
  //         o!("Value set, getting") |
  //         TreeHashMap!("get", map, "some key", *ret1) |             // "some val"
  //         TreeHashMap!("fastUnsafeGet", map, "monkey", *ret2) |     // "some other val"
  //         TreeHashMap!("get", map, "some unused key", *ret3) |      // Nil
  //         TreeHashMap!("fastUnsafeGet", map, "donkey", *ret4) |     // Nil
  //         TreeHashMap!("contains", map, "donkey", *ret5) |          // true
  //         TreeHashMap!("contains", map, "monkey", *ret6) |          // true
  //         TreeHashMap!("contains", map, "some unused key", *ret7) | // false
  //         for (@val1 <- ret1 & @val2 <- ret2 & @val3 <- ret3 & @val4 <- ret4 & @val5 <- ret5 & @val6 <- ret6 & @val7 <- ret7) {
  //           o!(["Got these from the map: ", val1, val2, val3, val4, val5, val6, val7])
  //         }
  //       }
  //     }
  //   }
  // }

  new MakeNode, ByteArrayToNybbleList,
      TreeHashMapSetter, TreeHashMapGetter, TreeHashMapContains, TreeHashMapUpdater,
      powersCh, storeToken, nodeGet in {
    match [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536] {
      powers => {
        contract MakeNode(@initVal, @node) = {
          @[node, *storeToken]!(initVal)
        } |

        contract nodeGet(@node, ret) = {
          for (@val <<- @[node, *storeToken]) {
            ret!(val)
          }
        } |

        contract ByteArrayToNybbleList(@ba, @n, @len, @acc, ret) = {
          if (n == len) {
            ret!(acc)
          } else {
            ByteArrayToNybbleList!(ba, n+1, len, acc ++ [ ba.nth(n) % 16, ba.nth(n) / 16 ], *ret)
          }
        } |

        contract TreeHashMap(@"init", @depth, ret) = {
          new map in {
            MakeNode!(0, (*map, [])) |
            @(*map, "depth")!!(depth) |
            ret!(*map)
          }
        } |
        // Internal, recursive TreeHashMap get method
        contract TreeHashMapGetter(@map, @nybList, @n, @len, @suffix, ret) = {
          // Look up the value of the node at (map, nybList.slice(0, n + 1))
          new valCh in {
            nodeGet!((map, nybList.slice(0, n)), *valCh) |
            for (@val <- valCh) {
              if (n == len) {
                ret!(val.get(suffix))
              } else {
                // Otherwise check if the rest of the path exists.
                // Bit k set means node k exists.
                // nybList.nth(n) is the node number
                // val & powers.nth(nybList.nth(n)) is nonzero if the node exists
                // (val / powers.nth(nybList.nth(n))) % 2 is 1 if the node exists
                if ((val / powers.nth(nybList.nth(n))) % 2 == 0) {
                  ret!(Nil)
                } else {
                  TreeHashMapGetter!(map, nybList, n + 1, len, suffix, *ret)
                }
              }
            }
          }
        } |

        contract TreeHashMap(@"get", @map, @key, ret) = {
          new hashCh, nybListCh, keccak256Hash(`rho:crypto:keccak256Hash`) in {
            // Hash the key to get a 256-bit array
            keccak256Hash!(key.toByteArray(), *hashCh) |
            for (@hash <- hashCh) {
              for (@depth <<- @(map, "depth")) {
                // Get the bit list
                ByteArrayToNybbleList!(hash, 0, depth, [], *nybListCh) |
                for (@nybList <- nybListCh) {
                  TreeHashMapGetter!(map, nybList, 0, 2 * depth, hash.slice(depth, 32), *ret)
                }
              }
            }
          }
        } |

        // Doesn't walk the path, just tries to fetch it directly.
        // Will hang if there's no key with that 64-bit prefix.
        // Returns Nil like "get" does if there is some other key with
        // the same prefix but no value there.
        contract TreeHashMap(@"fastUnsafeGet", @map, @key, ret) = {
          new hashCh, nybListCh, keccak256Hash(`rho:crypto:keccak256Hash`) in {
            // Hash the key to get a 256-bit array
            keccak256Hash!(key.toByteArray(), *hashCh) |
            for (@hash <- hashCh) {
              for(@depth <<- @(map, "depth")) {
                // Get the bit list
                ByteArrayToNybbleList!(hash, 0, depth, [], *nybListCh) |
                for (@nybList <- nybListCh) {
                  new restCh, valCh in {
                    nodeGet!((map, nybList), *restCh) |
                    for (@rest <- restCh) {
                      ret!(rest.get(hash.slice(depth, 32)))
                    }
                  }
                }
              }
            }
          }
        } |

        contract TreeHashMapSetter(@map, @nybList, @n, @len, @newVal, @suffix, ret) = {
          // Look up the value of the node at (map, nybList.slice(0, n + 1))
          new valCh, restCh in {
            match (map, nybList.slice(0, n)) {
              node => {
                for (@val <<- @[node, *storeToken]) {
                  if (n == len) {
                    // Acquire the lock on this node
                    for (@val <- @[node, *storeToken]) {
                      // If we're at the end of the path, set the node to newVal.
                      if (val == 0) {
                        // Release the lock
                        @[node, *storeToken]!({suffix: newVal}) |
                        // Return
                        ret!(Nil)
                      }
                      else {
                        // Release the lock
                        @[node, *storeToken]!(val.set(suffix, newVal)) |
                        // Return
                        ret!(Nil)
                      }
                    }
                  } else {
                    // Otherwise make the rest of the path exist.
                    // Bit k set means child node k exists.
                    if ((val/powers.nth(nybList.nth(n))) % 2 == 0) {
                      // Child node missing
                      // Acquire the lock
                      for (@val <- @[node, *storeToken]) {
                        // Re-test value
                        if ((val/powers.nth(nybList.nth(n))) % 2 == 0) {
                          // Child node still missing
                          // Create node
                          // if child node is leaf node
                          // set node to empty {} 
                          // else set node to 0
                          if (n + 1 == len){
                            MakeNode!({}, (map, nybList.slice(0, n + 1)))
                          }  else {
                            MakeNode!(0, (map, nybList.slice(0, n + 1)))
                          } |
                          // Update current node to val | (1 << nybList.nth(n))
                          match nybList.nth(n) {
                            bit => {
                              // val | (1 << bit)
                              // Bitwise operators would be really nice to have!
                              // Release the lock
                              @[node, *storeToken]!((val % powers.nth(bit)) +
                                (val / powers.nth(bit + 1)) * powers.nth(bit + 1) +
                                powers.nth(bit))
                            }
                          } |
                          // Child node now exists, loop
                          TreeHashMapSetter!(map, nybList, n + 1, len, newVal, suffix, *ret)
                        } else {
                          // Child node created between reads
                          // Release lock
                          @[node, *storeToken]!(val) |
                          // Loop
                          TreeHashMapSetter!(map, nybList, n + 1, len, newVal, suffix, *ret)
                        }
                      }
                    } else {
                      // Child node exists, loop
                      TreeHashMapSetter!(map, nybList, n + 1, len, newVal, suffix, *ret)
                    }
                  }
                }
              }
            }
          }
        } |

        contract TreeHashMap(@"set", @map, @key, @newVal, ret) = {
          new hashCh, nybListCh, keccak256Hash(`rho:crypto:keccak256Hash`) in {
            // Hash the key to get a 256-bit array
            keccak256Hash!(key.toByteArray(), *hashCh) |
            for (@hash <- hashCh) {
              for (@depth <<- @(map, "depth")) {
                // Get the bit list
                ByteArrayToNybbleList!(hash, 0, depth, [], *nybListCh) |
                for (@nybList <- nybListCh) {
                  TreeHashMapSetter!(map, nybList, 0, 2 * depth, newVal, hash.slice(depth, 32), *ret)
                }
              }
            }
          }
        } |

        contract TreeHashMapContains(@map, @nybList, @n, @len, @suffix, ret) = {
          // Look up the value of the node at [map, nybList.slice(0, n + 1)]
          new valCh in {
            nodeGet!((map, nybList.slice(0, n)), *valCh) |
            for (@val <- valCh) {
              if (n == len) {
                ret!(val.contains(suffix))
              } else {
                // See getter for explanation of formula
                if ((val/powers.nth(nybList.nth(n))) % 2 == 0) {
                  ret!(false)
                } else {
                  TreeHashMapContains!(map, nybList, n + 1, len, suffix, *ret)
                }
              }
            }
          }
        } |

        contract TreeHashMap(@"contains", @map, @key, ret) = {
          new hashCh, nybListCh, keccak256Hash(`rho:crypto:keccak256Hash`) in {
            // Hash the key to get a 256-bit array
            keccak256Hash!(key.toByteArray(), *hashCh) |
            for (@hash <- hashCh) {
              for (@depth <<- @(map, "depth")) {
                // Get the bit list
                ByteArrayToNybbleList!(hash, 0, depth, [], *nybListCh) |
                for (@nybList <- nybListCh) {
                  TreeHashMapContains!(map, nybList, 0, 2 * depth, hash.slice(depth, 32), *ret)
                }
              }
            }
          }
        } |

        contract TreeHashMapUpdater(@map, @nybList, @n, @len, update, @suffix, ret) = {
          // Look up the value of the node at [map, nybList.slice(0, n + 1)
          new valCh in {
            match (map, nybList.slice(0, n)) {
              node => {
                for (@val <<- @[node, *storeToken]) {
                  if (n == len) {
                    // We're at the end of the path.
                    if (val == 0) {
                      // There's nothing here.
                      // Return
                      ret!(Nil)
                    } else {
                      new resultCh in {
                        // Acquire the lock on this node
                        for (@val <- @[node, *storeToken]) {
                          // Update the current value
                          update!(val.get(suffix), *resultCh) |
                          for (@newVal <- resultCh) {
                            // Release the lock
                            @[node, *storeToken]!(val.set(suffix, newVal)) |
                            // Return
                            ret!(Nil)
                          }
                        }
                      }
                    }
                  } else {
                    // Otherwise try to reach the end of the path.
                    // Bit k set means child node k exists.
                    if ((val/powers.nth(nybList.nth(n))) % 2 == 0) {
                      // If the path doesn't exist, there's no value to update.
                      // Return
                      ret!(Nil)
                    } else {
                      // Child node exists, loop
                      TreeHashMapUpdater!(map, nybList, n + 1, len, *update, suffix, *ret)
                    }
                  }
                }
              }
            }
          }
        } |
        contract TreeHashMap(@"update", @map, @key, update, ret) = {
          new hashCh, nybListCh, keccak256Hash(`rho:crypto:keccak256Hash`) in {
            // Hash the key to get a 256-bit array
            keccak256Hash!(key.toByteArray(), *hashCh) |
            for (@hash <- hashCh) {
              for (@depth <<- @(map, "depth")) {
                // Get the bit list
                ByteArrayToNybbleList!(hash, 0, depth, [], *nybListCh) |
                for (@nybList <- nybListCh) {
                  TreeHashMapUpdater!(map, nybList, 0, 2 * depth, *update, hash.slice(depth, 32), *ret)
                }
              }
            }
          }
        } |
        // Returns the current map
        contract TreeHashMap(@"extractState", ret) = {
          for (@map <<- _registryStore) {
            ret!(map)
          }
        } |
        // TreeHashMap dispatcher contract
        // for use with 1-9 arguments
        contract TreeHashMapDispatcher(@arg1) = {
          for (realThm <<- TreeHashMapLoc) {
            realThm!(arg1)
          }
        } |
        contract TreeHashMapDispatcher(@arg1, @arg2) = {
          for (realThm <<- TreeHashMapLoc) {
            realThm!(arg1, arg2)
          }
        } |
        contract TreeHashMapDispatcher(@arg1, @arg2, @arg3) = {
          for (realThm <<- TreeHashMapLoc) {
            realThm!(arg1, arg2, arg3)
          }
        } |
        contract TreeHashMapDispatcher(@arg1, @arg2, @arg3, @arg4) = {
          for (realThm <<- TreeHashMapLoc) {
            realThm!(arg1, arg2, arg3, arg4)
          }
        } |
        contract TreeHashMapDispatcher(@arg1, @arg2, @arg3, @arg4, @arg5) = {
          for (realThm <<- TreeHashMapLoc) {
            realThm!(arg1, arg2, arg3, arg4, arg5)
          }
        } |
        contract TreeHashMapDispatcher(@arg1, @arg2, @arg3, @arg4, @arg5, @arg6) = {
          for (realThm <<- TreeHashMapLoc) {
            realThm!(arg1, arg2, arg3, arg4, arg5, arg6)
          }
        } |
        contract TreeHashMapDispatcher(@arg1, @arg2, @arg3, @arg4, @arg5, @arg6, @arg7) = {
          for (realThm <<- TreeHashMapLoc) {
            realThm!(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
          }
        } |
        contract TreeHashMapDispatcher(@arg1, @arg2, @arg3, @arg4, @arg5, @arg6, @arg7, @arg8) = {
          for (realThm <<- TreeHashMapLoc) {
            realThm!(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
          }
        } |
        contract TreeHashMapDispatcher(@arg1, @arg2, @arg3, @arg4, @arg5, @arg6, @arg7, @arg8, @arg9) = {
          for (realThm <<- TreeHashMapLoc) {
            realThm!(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
          }
        }
      }
    }
  } |
  // blessed contract uri shorthand map
  match {
    `rho:lang:either`             : `rho:id:qrh6mgfp5z6orgchgszyxnuonanz7hw3amgrprqtciia6astt66ypn`,
    `rho:lang:listOps`            : `rho:id:6fzorimqngeedepkrizgiqms6zjt76zjeciktt1eifequy4osz35ks`,
    `rho:lang:nonNegativeNumber`  : `rho:id:hxyadh1ffypra47ry9mk6b8r1i33ar1w9wjsez4khfe9huzrfcytx9`,
    `rho:rchain:authKey`          : `rho:id:1qw5ehmq1x49dey4eadr1h4ncm361w3536asho7dr38iyookwcsp6i`,
    `rho:rchain:makeMint`         : `rho:id:asysrwfgzf8bf7sxkiowp4b3tcsy4f8ombi3w96ysox4u3qdmn1wbc`,
    `rho:rchain:pos`              : `rho:id:m3xk7h8r54dtqtwsrnxqzhe81baswey66nzw6m533nyd45ptyoybqr`,
    `rho:rchain:revVault`         : `rho:id:6zcfqnwnaqcwpeyuysx1rm48ndr6sgsbbgjuwf45i5nor3io7dr76j`,
    `rho:rchain:multiSigRevVault` : `rho:id:b9s6j3xeobgset4ndn64hje64grfcj7a43eekb3fh43yso5ujiecfn`
    } {
    shorthands => {
      // Use 4 * 8 = 32-bit paths to leaf nodes.
      TreeHashMap!("init", 4, *_registryStore) |
      new ack in {
        // Store write-only `TreeHashMap` bundle on the node with prefix ``rho:lang:treeHashMap``
        for (@map <<- _registryStore) {
          TreeHashMap!("set", map, `rho:lang:treeHashMap`, bundle+{*TreeHashMapDispatcher}, *ack)
        } |
        // Wait for the set to finish, then register `lookupCh` as the uri/shorthand lookup channel
        for (_ <- ack) {
          // add TreeHashMap location to location map
          for (@blessedContractLocMap <- blessedContractLocMapCh) {
            blessedContractLocMapCh!(blessedContractLocMap.set(`rho:lang:treeHashMap`, *TreeHashMapLoc)) |
            TreeHashMapLoc!(bundle+{*TreeHashMap})
          } |
          // Registers `lookupCh` as a lookup channel for the registry
          bootstrapLookup!(*lookupCh) | // this will work only once
          for (lookup <- lookupCh) {
            contract lookup(@uriOrShorthand, ret) = {
              for (@map <<- _registryStore) {
                TreeHashMap!("get", map, shorthands.getOrElse(uriOrShorthand, uriOrShorthand), *ret)
              }
            }
          }
        }
      } |
      // Registers `insertArbitraryCh` as an insertArbitrary channel for the registry
      bootstrapInsertArbitrary!(*insertArbitraryCh) | // this will work only once
      for (insertArbitrary <- insertArbitraryCh) {
        // Generates uri and seed to store and access `data` in the registry, returns the generated uri on `ret`
        contract insertArbitrary(@data, ret) = {
          new
            seed,
            uriCh
          in {
            ops!("buildUri", *seed.toByteArray(), *uriCh) |
            for (@uri <- uriCh) {
              for (@map <<- _registryStore) {
                new ack in {
                  TreeHashMap!("set", map, uri, data, *ack) |
                  for (_ <- ack) {
                    ret!(uri)
                  }
                }
              }
            }
          }
        }
      } |
      // Registers `insertSignedCh` as an insertSigned channel in the registry
      bootstrapInsertSigned!(*insertSignedCh) | // this will work only once
      for (insertSigned <- insertSignedCh) {
        // Verifies signature and inserts data into registry
        // Returns generated uri on `ret`
        contract insertSigned(@pubKeyBytes, @(nonce, data), @sig, ret) = {
          new
            uriCh,
            hashCh,
            verifyCh
          in {
            hashVerify!((nonce, data), sig, pubKeyBytes, *verifyCh) |
            for (@verified <- verifyCh) {
              if (verified) {
                ops!("buildUri", pubKeyBytes, *uriCh) |
                for (@uri <- uriCh) {
                  for (@map <<- _registryStore) {
                    new responseCh in {
                      TreeHashMap!("get", map, uri, *responseCh) |
                      for (@response <- responseCh) {
                        match response {
                          Nil => {
                            new ack in {
                              TreeHashMap!("set", map, uri, (nonce, data), *ack) |
                              for (_ <- ack) {
                                ret!(uri)
                              }
                            }
                          }
                          (oldNonce, _) => {
                            if (nonce > oldNonce) {
                              new ack in {
                                TreeHashMap!("set", map, uri, (nonce, data), *ack) |
                                for (_ <- ack) {
                                  ret!(uri)
                                }
                              }
                            } else {
                              ret!(Nil)
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                ret!(Nil)
              }
            }
          }
        }
      } |
      // blessedContractMap: uriShorthand -> location
      blessedContractLocMapCh!({}) |
      // Registers `insertBlessedCh` as an insertBlessed channel in the registry
      bootstrapInsertBlessed!(*insertBlessedCh) |
      for (insertBlessed <- insertBlessedCh) {
        // A consume is included for each (updatable) blessed contract
        new newInsert in {
          contract newInsert(@lib, @uri, dispatcher) = {
            new loc in {
              loc!(lib) |
              contract dispatcher(@arg1) = {
                for (realAK <<- loc) {
                  realAK!(arg1)
                }
              } |
              contract dispatcher(@arg1, @arg2) = {
                for (realAK <<- loc) {
                  realAK!(arg1, arg2)
                }
              } |
              contract dispatcher(@arg1, @arg2, @arg3) = {
                for (realAK <<- loc) {
                  realAK!(arg1, arg2, arg3)
                }
              } |
              contract dispatcher(@arg1, @arg2, @arg3, @arg4) = {
                for (realAK <<- loc) {
                  realAK!(arg1, arg2, arg3, arg4)
                }
              } |
              contract dispatcher(@arg1, @arg2, @arg3, @arg4, @arg5) = {
                for (realAK <<- loc) {
                  realAK!(arg1, arg2, arg3, arg4, arg5)
                }
              } |
              contract dispatcher(@arg1, @arg2, @arg3, @arg4, @arg5, @arg6) = {
                for (realAK <<- loc) {
                  realAK!(arg1, arg2, arg3, arg4, arg5, arg6)
                }
              } |
              contract dispatcher(@arg1, @arg2, @arg3, @arg4, @arg5, @arg6, @arg7) = {
                for (realAK <<- loc) {
                  realAK!(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
                }
              } |
              contract dispatcher(@arg1, @arg2, @arg3, @arg4, @arg5, @arg6, @arg7, @arg8) = {
                for (realAK <<- loc) {
                  realAK!(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
                }
              } |
              contract dispatcher(@arg1, @arg2, @arg3, @arg4, @arg5, @arg6, @arg7, @arg8, @arg9) = {
                for (realAK <<- loc) {
                  realAK!(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
                }
              } |
              for (@bcMap <- blessedContractLocMapCh) {
                blessedContractLocMapCh!(bcMap.set(uri, *loc))
              } 
            } 
          }|
          for (@`rho:rchain:authKey`, @lib, @dispatcher <- insertBlessed) {
            newInsert!(lib, `rho:rchain:authKey`, dispatcher)
          } |
          for (@`rho:rchain:makeMint`, @lib, @dispatcher <- insertBlessed) {
            newInsert!(lib, `rho:rchain:makeMint`, dispatcher)
          } |
          for (@`rho:rchain:multiSigRevVault`, @lib, @dispatcher <- insertBlessed) {
            newInsert!(lib, `rho:rchain:multiSigRevVault`, dispatcher)
          } |
          for (@`rho:lang:nonNegativeNumber`, @lib, @dispatcher <- insertBlessed) {
            newInsert!(lib, `rho:lang:nonNegativeNumber`, dispatcher)
          } |
          for (@`rho:rchain:pos`, @lib, @dispatcher <- insertBlessed) {
            newInsert!(lib, `rho:rchain:pos`, dispatcher)
          } |
          for (@`rho:rchain:revVault`, @lib, @dispatcher <- insertBlessed) {
            newInsert!(lib, `rho:rchain:revVault`, dispatcher)
          }
        } 
      } |
      // --------
      // MultiSig
      // -------------------------------------------------------------------------------------
      // MultiSig enables similiar functionality to a multisig vault. 
      // pubKeys = set of public keys which have the privilege to propose and approve upgrades
      // quorumSize = number of pubKeys member approvals needed to upgrade a contract's data
      // -------------------------------------------------------------------------------------
      {
        let @quorumSize, @pubKeys <- 2, Set(
          // The private keys and public keys are here just for testing now
          // fc743bd08a822d544bfbe05a5663fc325039a44c8f0c7fbea95a85517da5c36b private
          "04e2eb6b06058d10b30856043c29076e2d2d7c374d2beedded6ecb8d1df585dfa583bd7949085ac6b0761497b0cfd056eb3d0db97efb3940b14c00fff4e53c85bf".hexToBytes(),
          // 6e88cf274735f3f7f73ec3d7f0362c439ab508427682b5bd788007aca665d810 private
          "043405f36c6cc2327fbbdf1af442a99e9a04f650ccb415bc23d4379e63a5cb5d53f7c7861d5937db32700b001ab2024f1c078b0ba90f47af46c8c4dea33f972d7c".hexToBytes(),
          // 87369d132ed6a7626dc4c5dfbaf41e954dd0ec55830e613a3f868c74d64a7a22 private
          "0412eea943c13ed3e99d2de048a57dbaf4c977df83a50bf7ec79ae58255cf8d891a1cbe3cd51aeafec34241a1a9c9a54e861aa5b373667793c617c0310eab26653".hexToBytes()
        ) in {
          new
            multisig,           // MultiSig contract's method entry point
            agreementMapCh,     // channel on which the agreement map is stored
            proposalMapCh,      // channel on which the propose map is stored
            multisigLoc,        // MultiSig contract's location channel
            multisigDispatcher  // MultiSig contract's dispatcher
          in {
            // Initialize propose map
            // uri -> (contractData, methodData)
            proposalMapCh!({}) |
            // Initialize agreement map
            // (uri, contractData, methodData) -> agreement set
            agreementMapCh!({}) |
            // -------
            // Propose
            // --------------------------------------------------------------------------------
            // pubKeyBytes: Privileged public keys, i.e. members of `pubKeys`, can propose contract updates.
            //              There is only one proposal per uri possible at a time.
            // uri: The uri which is going to be proposed to change
            // con: A contract which would used in `con!(oldData, *ret)` on working on the old data
            // meth: The target contract unf handle the loc ch would replace
            // sig: Signature of (uri, con, meth) signed by pubKeyBytes
            // --------------------------------------------------------------------------------
            contract multisig(@"propose", @pubKeyBytes, @uri, @con, @meth, @sig, ret) = {
              new verifyCh in {
                if (pubKeys.contains(pubKeyBytes)) {
                  // `pubKey` has the privilege to propose updates
                  for (@bcMap <<- blessedContractLocMapCh) {
                    if (bcMap.contains(uri)) {
                      // `uri` belongs to a blessed contract
                      match (uri, con, meth) {
                        key => {
                          for (@proposalMap <- proposalMapCh) {
                            if (not proposalMap.contains(uri)) {
                              // the update proposal is unique
                              // check the signature of (uri, con, meth) = key
                              hashVerify!(key, sig, pubKeyBytes, *verifyCh) |
                              for (@verified <- verifyCh) {
                                if (verified) {
                                  // signature is valid
                                  proposalMapCh!(proposalMap.set(uri, (con, meth))) |
                                  for (@agreeMap <- agreementMapCh) {
                                    // the proposer is the first to agree with a proposal
                                    agreementMapCh!(agreeMap.set(key, Set(pubKeyBytes))) |
                                    ret!((true, uri, con, meth))
                                  }
                                } else {
                                  // signature is invalid
                                  proposalMapCh!(proposalMap) |
                                  ret!((false, "invalid signature"))
                                }
                              }
                            } else {
                              // an update has already been proposed for this uri
                              proposalMapCh!(proposalMap) |
                              ret!((false, "location already exists"))
                            }
                          }
                        }
                      }
                    } else {
                      // `uri` does not belong to a blessed contract
                      ret!((false, "uri does not exist"))
                    }
                  }
                } else {
                  // `pubKeyBytes` does not have the privilege to propose updates
                  ret!((false, "invalid public key"))
                }
              }
            } |
            // Agree
            // --------------------------------------------------------------------------------------
            // Privileged public keys can agree with update proposals.
            // Manages the `agreementMap`: (uri, contractData, methodData) -> set of agreeing pubKeys
            // --------------------------------------------------------------------------------------
            contract multisig(@"agree", @pubKeyBytes, @uri, @con, @meth, @sig, ret) = {
              new verifyCh in {
                match (uri, con, meth) {
                  agreedTuple => {
                    if (pubKeys.contains(pubKeyBytes)) {
                      // `pubKey` is a member of `pubKeys`
                      hashVerify!(agreedTuple, sig, pubKeyBytes, *verifyCh) |
                      for (@verified <- verifyCh) {
                        if (verified) {
                          // valid signature
                          for (@map <- agreementMapCh) {
                            match map.getOrElse(agreedTuple, Set()).add(pubKeyBytes) {
                              agreeing => {
                                // add `pubKeyBytes` to the set of supporters
                                agreementMapCh!(map.set(agreedTuple, agreeing)) |
                                ret!((true, uri, con, meth, agreeing))
                              }
                            }
                          }
                        } else {
                          // invalvid signature
                          ret!((false, "invalid signature"))
                        }
                      }
                    } else {
                      // `pubKeyBytes` is not in `pubKeys`
                      ret!((false, "invalid public key"))
                    }
                  }
                }
              }
            } |
            // ------
            // Update
            // ------------------------------------------------------------------------------------
            // if there is a quorum of privileged public keys agreeing on the update for `uri`,
            // then this method updates the contract data and manages the internal maps accordingly
            // ------------------------------------------------------------------------------------
            contract multisig(@"update", @uri, ret) = {
              for (@proposalMap <- proposalMapCh) {
                if (proposalMap.contains(uri)) {
                  // there is an update proposal for `uri`
                  for (@blessedContractLocMap <<- blessedContractLocMapCh) {
                    match (blessedContractLocMap.get(uri), proposalMap.get(uri)) {
                      (loc, (con, meth)) => {
                        for (@agreementMap <- agreementMapCh) {
                          if (agreementMap.getOrElse((uri, con, meth), Set()).size() >= quorumSize) {
                            // sufficiently many keys agree to update
                            // consume data on location channel in order to replace contract data
                            for (oldData <- @loc) {
                              new tmp, newRet in {
                                oldData!("extractState", *tmp) |
                                for (@oldState <- tmp) {
                                  // launch new contract instance with initial state extracted from the old instance
                                  @con!(oldState, *newRet) |
                                  // manage agreement and proposal maps
                                  agreementMapCh!(agreementMap.delete((uri, con, meth))) |
                                  proposalMapCh!(proposalMap.delete(uri)) |
                                  // write new method entry point to location channel
                                  @loc!(meth) |
                                  ret!((true, *newRet))
                                }
                              }
                            }
                          } else {
                            // there isn't a quorum of support for the update
                            agreementMapCh!(agreementMap) |
                            proposalMapCh!(proposalMap) |
                            ret!((false, "quorum does not exist"))
                          }
                        }
                      }
                    }
                  }
                } else {
                  // there isn't an update proposal for `uri`
                  proposalMapCh!(proposalMap) |
                  ret!((false, "invalid proposal uri"))
                }
              }
            } |
            // ExtractState
            // --------------------------------------------
            // Returns a map containing the current maps:
            // "blessed"   - blessed contract location map
            // "agreement" - agreement map
            // "propose"   - proposals map
            // --------------------------------------------
            contract multisig(@"extractState", ret) = {
              for (@agreementMap <<- agreementMapCh;
                    @blessedMap   <<- blessedContractLocMapCh;
                    @proposalMap  <<- proposalMapCh) {
                ret!({ "blessed" : blessedMap, "agreement" : agreementMap, "proposals" : proposalMap })
              }
            } |
            msRet!(bundle+{*multisigDispatcher}, pubKeys, quorumSize) |
            new ack in {
              for (@map <<- _registryStore) {
                // add multisig dispatcher to the uri map
                TreeHashMap!("set", map, `rho:registry:multisig`, bundle+{*multisigDispatcher}, *ack)
              } |
              for (_ <- ack) {
                // add multisig location to location map and the methods' entry point to the location channel
                for (@blessedContractLocMap <- blessedContractLocMapCh) {
                  blessedContractLocMapCh!(blessedContractLocMap.set(`rho:registry:multisig`, *multisigLoc)) |
                  multisigLoc!(bundle+{*multisig})
                }
              }
            } |
            // multisig dispatcher contract
            // for use with 1-9 arguments
            contract multisigDispatcher(@arg1) = {
              for (realMS <<- multisigLoc) {
                realMS!(arg1)
              }
            } |
            contract multisigDispatcher(@arg1, @arg2) = {
              for (realMS <<- multisigLoc) {
                realMS!(arg1, arg2)
              }
            } |
            contract multisigDispatcher(@arg1, @arg2, @arg3) = {
              for (realMS <<- multisigLoc) {
                realMS!(arg1, arg2, arg3)
              }
            } |
            contract multisigDispatcher(@arg1, @arg2, @arg3, @arg4) = {
              for (realMS <<- multisigLoc) {
                realMS!(arg1, arg2, arg3, arg4)
              }
            } |
            contract multisigDispatcher(@arg1, @arg2, @arg3, @arg4, @arg5) = {
              for (realMS <<- multisigLoc) {
                realMS!(arg1, arg2, arg3, arg4, arg5)
              }
            } |
            contract multisigDispatcher(@arg1, @arg2, @arg3, @arg4, @arg5, @arg6) = {
              for (realMS <<- multisigLoc) {
                realMS!(arg1, arg2, arg3, arg4, arg5, arg6)
              }
            } |
            contract multisigDispatcher(@arg1, @arg2, @arg3, @arg4, @arg5, @arg6, @arg7) = {
              for (realMS <<- multisigLoc) {
                realMS!(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
              }
            } |
            contract multisigDispatcher(@arg1, @arg2, @arg3, @arg4, @arg5, @arg6, @arg7, @arg8) = {
              for (realMS <<- multisigLoc) {
                realMS!(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
              }
            } |
            contract multisigDispatcher(@arg1, @arg2, @arg3, @arg4, @arg5, @arg6, @arg7, @arg8, @arg9) = {
              for (realMS <<- multisigLoc) {
                realMS!(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
              }
            }
          }
        }
      }
    }
  }
}
