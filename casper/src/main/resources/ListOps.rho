/*
 The table below describes the required computations and their dependencies

 No. | Dependency | Computation method | Result
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 1.  |            | given              | sk = 867c21c6a3245865444d80e49cac08a1c11e23b35965b566bbe9f49bb9897511
 2.  |            | given              | timestamp = 1559156082324
 3.  |            | lastNonce          | nonce = 9223372036854775807
 4.  | 1,         | secp256k1          | pk = 040126690519dc9b0f52876cb13458e15697794dd87d7c6477707c7efa4cce8a36b634eab5056bd4e3ba385ab14a638e4ac7d3b3e4968da3d66933fc04bc7038b5
 5.  | 4, 2,      | genIds             | uname = Unforgeable(0x95fcdae5d4db7cf5aa0022bf6dba3f7c21b506fed8f3f4698a570d048ea758bd)
 6.  | 3, 5,      | registry           | value = (9223372036854775807, bundle+ {   Unforgeable(0x95fcdae5d4db7cf5aa0022bf6dba3f7c21b506fed8f3f4698a570d048ea758bd) })
 7.  | 6,         | protobuf           | toSign = 2a40aa013d0a0d2a0b10feffffffffffffffff010a2c5a2a0a263a240a220a2095fcdae5d4db7cf5aa0022bf6dba3f7c21b506fed8f3f4698a570d048ea758bd1001
 8.  | 7, 1,      | secp256k1          | sig = 3045022100dc97997d235773957dc6610491441707c64f9f23efeee6fb6ba8ac04003cd1d302201aa4cfd144dfc866d7c92673dddaa86436609c4df61a8a512ac2dd34e131b3ee
 9.  | 4,         | registry           | uri = rho:id:6fzorimqngeedepkrizgiqms6zjt76zjeciktt1eifequy4osz35ks
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 */
new  ListOps, rs(`rho:registry:insertSigned:secp256k1`), uriOut in {
  contract ListOps(return, @"prepend", @head, @tail) = {
    return!([head] ++ tail)
  } |

  contract ListOps(return, @"append", @list, @element) = {
    return!(list ++ [element])
  } |

  //A fold over the list which breaks early if a condition is met.
  //Both the condition and combinator are are combined into a single
  //function which returns a [boolean, value] pair.
  //Use cases: see get and indexOf
  new loop in {
    contract loop(return, @accumulatedValue, @lst, combinatorAndCondition) = {
      match lst {
        [head ...tail] => {
          for (@done, @newValue <- combinatorAndCondition!?(head, accumulatedValue)) {
            if (done){ return!(done, newValue) }
            else     { loop!(*return, newValue, tail, *combinatorAndCondition)   }
          }
        }
        _ => { return!(false, accumulatedValue)}
      }
    } | 
    contract ListOps(return, @"partialFold", @list, @start, combinatorAndCondition) = {

      loop!(*return, start, list, *combinatorAndCondition, )
    }
  } |

  //A fold over the list which breaks early if a condition is met.
  //Both the condition and combinator are are combined into a single
  //function which returns a [boolean, value] pair.
  //Use cases: see get and indexOf
  new loop in {
    contract loop(return, @accumulatedValue, @lst, combinatorAndCondition, @state) = {
      match lst {
        [head ...tail] => {
          for (@done, @newValue <- combinatorAndCondition!?(state, head, accumulatedValue)) {
            if (done){ return!(done, newValue) }
            else     { loop!(*return, newValue, tail, *combinatorAndCondition, state, )   }
          }
        }
        _ => { return!(false, accumulatedValue) }
      }
    } | 
    contract ListOps(return, @"partialFoldClean", @list, @start, combinatorAndCondition, @state) = {
      loop!(*return, start, list, *combinatorAndCondition, state)
    }
  } |

  contract ListOps(return, @"fold", @list, @start, combinator) = {

    new combinatorAndCondition in {
      contract combinatorAndCondition(return, @head, @accumulatedValue) = {

        for(@r <- combinator!?(head, accumulatedValue)){ return!(false, r) }
      } |
      for(_, @value <- ListOps!?("partialFold", list, start, *combinatorAndCondition)) {
        return!(value)
      }
    }
  } |

  new combinatorAndCondition in {
    contract combinatorAndCondition(return, @(combinator, state), @head, @accumulatedValue) = {
      for(@r <- @combinator!?(state, head, accumulatedValue)){ return!(false, r) }
    } |
    contract ListOps(return, @"foldClean", @list, @start, combinator, @state) = {
      for(_, @value <- ListOps!?("partialFoldClean", list, start, *combinatorAndCondition, (*combinator, state))) {
        return!(value)
      }
    }
  } |

  new prepend in {
    contract prepend(return, _, @head, @tail) = {
      return!([head] ++ tail)
    } |
    contract ListOps(return, @"reverse", @list) = {
      ListOps!(*return, "foldClean", list, [], *prepend, Nil)
    }
  } |

  contract ListOps(@"map", @list, function, return) = {
    new combinator in {
      contract combinator(return, @head, @accumulatedValue) = {
        for(@x <- function!?(head)) {
          return!(accumulatedValue ++ [x])
        }
      } |
      ListOps!(*return, "fold", list, [], *combinator)
    }
  } |

  new combinator in {
    contract combinator(return, @(function, state), @head, @accumulatedValue) = {
      for(@x <- @function!?(state, head)) {
        return!(accumulatedValue ++ [x])
      }
    } |
    contract ListOps(return, @"mapClean", @list, function, @state) = {
      ListOps!(*return, "foldClean", list, [], *combinator, (*function, state))
    }
  } |

  new getOutput in {
    contract getOutput(ret, name)  = { for(@result <- name){ ret!(result) } } |
    contract ListOps(return, @"parMap", @list, function) = {
      new startProcess in {
        contract startProcess(ret, @x) = { 
          new outCh in { 
            function!(x, *outCh) | 
            ret!(*outCh) 
            } 
          } |
        //map each element to a name listening for the result of the function
        for(@namesList <- ListOps!?("map", list, *startProcess)) {
          //map each name to its result
          ListOps!(*return, "map", namesList, *getOutput, )
        }
      }
    }
  } |

  new getOutput, startProcess in {
    contract getOutput(ret, _, name)  = { for(@result <- name){ ret!(result) } } |
    contract startProcess(ret, @(function, state), @x) = {
        @function!(*ret, state, x)
    } |
    contract ListOps(return, @"parMapClean", @list, function, @state) = {
      for(@namesList <- ListOps!?("mapClean", list, *startProcess, (*function, state))) {
        //map each name to its result
        ListOps!(*return, "mapClean", namesList, *getOutput, Nil)
      }
    }
  } |

  new mapLoop in {
    contract mapLoop(@l, @count, function, collect, startCount)= {
      match l {
        [hd ...tl] => {
          function!(hd, *collect) | 
          mapLoop!(tl, count + 1, *function, *collect, *startCount)
        }
        _  => { startCount!(count) }
      }
    } |

    contract ListOps(return, @"unorderedParMap", @list, function) = {
      new collect, startCount, completeCount, accCh in {
        //Spawn processes, each computing one element
        //also processes listening for the result
        //add a result to our accumulating list
        contract collect(@result) = {
          for(@sc <- startCount; @cc <- completeCount; @acc <- accCh) {
            startCount!(sc) |
            if (sc == cc + 1) { //all started processes completed!
              return!([result] ++ acc)
            } else {            //still waiting on some
              completeCount!(cc + 1) |
              accCh!([result] ++ acc)
            }
          }
        } |
        match list {
          [] => { return!([]) }
          _  => { mapLoop!(list, 0, *function, *collect, *startCount) | completeCount!(0) | accCh!([]) }
        }
      }
    }
  } |

  new mapLoop in {
    contract mapLoop(@l, @count, function, @state, collect, startCount)= {
      match l {
        [hd ...tl] => {
          function!(state, hd, *collect) | 
          mapLoop!(tl, count + 1, *function, state, *collect, *startCount)
        }
        _  => { startCount!(count) }
      }
    } |

    contract ListOps(return, @"unorderedParMapClean", @list, function, @state) = {
      new collect, startCount, completeCount, accCh in {
        //Spawn processes, each computing one element
        //also processes listening for the result
        //add a result to our accumulating list
        contract collect(@result) = {
          for(@sc <- startCount; @cc <- completeCount; @acc <- accCh) {
            startCount!(sc) |
            if (sc == cc + 1) { //all started processes completed!
              return!([result] ++ acc)
            } else {            //still waiting on some
              completeCount!(cc + 1) |
              accCh!([result] ++ acc)
            }
          }
        } |
        match list {
          [] => { return!([]) }
          _  => { mapLoop!(list, 0, *function, state, *collect, *startCount) | completeCount!(0) | accCh!([]) }
        }
      }
    }
  } |

  contract ListOps(return, @"foreach", @list, proc) = { 
    new combinator in {
      contract combinator(return, @head, @accumulatedValue) = {
        //Need return flag from `proc` in order to guarantee execution order   
        for(_ <- proc!?(head)){ return!(Nil) } 
      } |
      for(_ <- ListOps!?("fold", list, Nil, *combinator)){ 
        return!(true) 
      }
    }
  } |

  new combinator in {
    contract combinator(return, @(proc, state), @head, @accumulatedValue) = {
      //Need return flag from `proc` in order to guarantee execution order
      for(_ <- @proc!?(state, head)){ 
        return!(Nil) 
      }
    } |
    contract ListOps(return, @"foreachClean", @list, proc, @state) = {
      for(_ <- ListOps!?("foldClean", list, Nil, *combinator, (*proc, state))){ 
        return!(true) 
      }
    }
  } |

  new combinatorAndCondition in {
    contract combinatorAndCondition(return, @value, @head, @accumulatedValue) = {
      return!(head == value, accumulatedValue + 1)
    } |
    contract ListOps(return, @"indexOf", @list, @value) = {
      for(@valueFound, @i <- ListOps!?("partialFoldClean", list, -1, *combinatorAndCondition, value) ) {
        if (valueFound) { return!(i)  }
        else            { return!(-1) }
      }
    }
  } |

  new loop in {
    contract loop(return, @pair, @acc) = {
      match pair {
        ([h1 ...t1], [h2 ...t2]) => {
          loop!(*return, (t1, t2), acc ++ [(h1, h2)])
        }
        _ => {
          return!(acc)
        }
      }
    } |
    contract ListOps(return, @"zip", @list1, @list2) = {
      loop!(*return, (list1, list2), [])
    }
  } |

  new loop in {
    contract loop(return, @start, @i, @list) = {
      if(i < start) {
        return!(list)
      } else {
        loop!(*return, start, i - 1, [i] ++ list)
      }
    } |
    contract ListOps(return, @"range", @start, @end) = {
      loop!(*return, start, end - 1, [])
    }
  } |

  contract ListOps(returnCh, @"forall", @list, predicate) = {
    new combine in {
      contract combine(accResultCh, @item, @acc) = {
        for (@isSatisfied <- predicate!?(item)) {
          accResultCh!(not isSatisfied, isSatisfied)
        }
      } |

      for (_, @result <- ListOps!?("partialFold", list, true, *combine)) {
        returnCh!(result)
      }
    }
  } |

  new combine in {
    contract combine(accResultCh, @(predicate, state), @item, @acc) = {
      for (@isSatisfied <- @predicate!?(state, item)) {
        accResultCh!(not isSatisfied, isSatisfied)
      }
    } |
    contract ListOps(returnCh, @"forallClean", @list, predicate, @state) = {
      for (_, @result <- ListOps!?("partialFoldClean", list, true, *combine, (*predicate, state))) {
        returnCh!(result)
      }
    }
  } |

  contract ListOps(returnCh, @"exists", @list, predicate) = {
    new combine in {
      contract combine(accResultCh, @item, @acc) = {
        for (@isSatisfied <- predicate!?(item)) {
          accResultCh!(isSatisfied, isSatisfied)
        }
      } |

      for (_, @result <- ListOps!?("partialFold", list, false, *combine)) {
        returnCh!(result)
      }
    }
  } |

  new combine in {
    contract combine(accResultCh, @(predicate, state), @item, @acc) = {
      for (@isSatisfied <- @predicate!?(state, item)) {
        accResultCh!(isSatisfied, isSatisfied)
      }
    } |
    contract ListOps(returnCh, @"existsClean", @list, predicate, @state) = {
      for (_, @result <- ListOps!?("partialFoldClean", list, false, *combine, (*predicate, state))) {
        returnCh!(result)
      }
    }
  } |

  new sum in {
    contract sum(resultCh, _, @n, @acc) = { resultCh!(n + acc)  } |
    contract ListOps(returnCh, @"sum", @list) = {
      ListOps!(*returnCh, "foldClean", list, 0, *sum, Nil)| new stdlog(`rho:io:stdlog`) in { stdlog!("info", ("sumWWW!!!  "))}
    }
  } |

  contract ListOps(returnCh, @"filter", @list, predicate) = {
    new accumulate in {
      for (@reversed <- ListOps!?("reverse", list)) {
        ListOps!(*returnCh, "fold", reversed, [], *accumulate) |
        contract accumulate(resultCh, @x, @acc) = {
          for (@matchesPredicate <- predicate!?(x)) {
            if (matchesPredicate) {
              resultCh!([x] ++ acc)
            } else {
              resultCh!(acc)
            }
          }
        }
      }
    }
  } |

  new accumulate in {
    contract accumulate(resultCh, @(predicate, state), @x, @acc) = {
      for (@matchesPredicate <- @predicate!?(state, x)) {
        if (matchesPredicate) {
          resultCh!([x] ++ acc)
        } else {
          resultCh!(acc)
        }
      }
    } |
    contract ListOps(returnCh, @"filterClean", @list, predicate, @state) = {
      for (@reversed <- ListOps!?("reverse", list)) {
        ListOps!( *returnCh, "foldClean", reversed, [], *accumulate, (*predicate, state))
      }
    }
  } |
  rs!(
    *uriOut,
    "040126690519dc9b0f52876cb13458e15697794dd87d7c6477707c7efa4cce8a36b634eab5056bd4e3ba385ab14a638e4ac7d3b3e4968da3d66933fc04bc7038b5".hexToBytes(),
    (9223372036854775807, bundle+{*ListOps}),
    "3045022100dc97997d235773957dc6610491441707c64f9f23efeee6fb6ba8ac04003cd1d302201aa4cfd144dfc866d7c92673dddaa86436609c4df61a8a512ac2dd34e131b3ee".hexToBytes(),
  )
}
