// Rholang macro parameters:
// minimumBond - the minimum bond allowed by the PoS
// maximumBond - the maximum bond allowed by PoS
// initialBonds - the initial bonds map
// epochLength - the length of the validation epoch in blocks
// quarantineLength - the length of the quarantine time in blocks

/*
 The table below describes the required computations and their dependencies

 No. | Dependency | Computation method | Result
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 1.  |            | given              | sk = a9585a0687761139ab3587a4938fb5ab9fcba675c79fefba889859674046d4a5
 2.  |            | given              | timestamp = 1559156420651
 3.  |            | lastNonce          | nonce = 9223372036854775807
 4.  | 1,         | secp256k1          | pk = 047b43d6548b72813b89ac1b9f9ca67624a8b372feedd71d4e2da036384a3e1236812227e524e6f237cde5f80dbb921cac12e6500791e9a9ed1254a745a816fe1f
 5.  | 4, 2,      | genIds             | uname = Unforgeable(0xa32c1649f1700469f125ea85f9c2a220072e593ae617213782d738e389639d3b)
 6.  | 3, 5,      | registry           | value = (9223372036854775807, bundle+ {   Unforgeable(0xa32c1649f1700469f125ea85f9c2a220072e593ae617213782d738e389639d3b) })
 7.  | 6,         | protobuf           | toSign = 2a40aa013d0a0d2a0b10feffffffffffffffff010a2c5a2a0a263a240a220a20a32c1649f1700469f125ea85f9c2a220072e593ae617213782d738e389639d3b1001
 8.  | 7, 1,      | secp256k1          | sig = 3044022054ff4bae3984252b116e41e28d98bb5533eaa39aec2729228159166e2784f641022066a0fd99e7ea33df812fab095cbe61250f9548bce6da3ec4c6a90c741b94087f
 9.  | 4,         | registry           | uri = rho:id:m3xk7h8r54dtqtwsrnxqzhe81baswey66nzw6m533nyd45ptyoybqr
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
*/

new PoS,
    registryLookup(`rho:registry:lookup`),
    revAddressOps(`rho:rev:address`),
    revVaultCh, listOpsCh,
    getUser,
    pickActiveValidators,
    runMVar,
    fst,
    deposit, distributeRewards,
    perActiveValidatorPosVaultsCh,
    rs(`rho:registry:insertSigned:secp256k1`),
    posId(`rho:rchain:deployerId`),
    PendingRewards, MergeIntMaps, treeHashMapCh,
    sysAuthTokenOps(`sys:authToken:ops`),
    multiSigRevVaultCh, coopVaultCh,
    uriOut, sumFromPair
in {
  // Simultaneously retrieves RevVault, ListOps, TreeHashMap, and MultiSigRevVault contracts from the registry.
  registryLookup!(`rho:rchain:revVault`, *revVaultCh) |
  registryLookup!(`rho:lang:listOps`, *listOpsCh) |
  registryLookup!(`rho:lang:treeHashMap`, *treeHashMapCh) |
  registryLookup!(`rho:rchain:multiSigRevVault`, *multiSigRevVaultCh) |
  for (@(_, RevVault)         <- revVaultCh;
       @(_, ListOps)          <- listOpsCh;
       TreeHashMap            <- treeHashMapCh;
       @(_, MultiSigRevVault) <- multiSigRevVaultCh) {
    new posRevAddressCh, posAuthKeyCh, posVaultCh,
        initialActiveCh, pendingRewardsMapCh
    in {
      // Creates the auth key and Rev vault associated with the PoS contract.
      new posPkCh in {
        @RevVault!("deployerAuthKey", *posId, *posAuthKeyCh) |
        getUser!(*posId, *posPkCh) |
        for (@posPk <- posPkCh) {
          revAddressOps!("fromPublicKey", posPk, *posRevAddressCh) |
          // Creates Coop multisig vault for slashed funds.
          // Either (false, errorMsg) or (true, (multiSigVault, revAddress, revVault)) are returned on coopVaultCh.
          @MultiSigRevVault!(
            "create",
            [
              "04db91a53a2b72fcdcb201031772da86edad1e4979eb6742928d27731b1771e0bc40c9e9c9fa6554bdec041a87cee423d6f2e09e9dfb408b78e85a4aa611aad20c".hexToBytes(),
              "042a736b30fffcc7d5a58bb9416f7e46180818c82b15542d0a7819d1a437aa7f4b6940c50db73a67bfc5f5ec5b5fa555d24ef8339b03edaa09c096de4ded6eae14".hexToBytes(),
              "047f0f0f5bbe1d6d1a8dac4d88a3957851940f39a57cd89d55fe25b536ab67e6d76fd3f365c83e5bfe11fe7117e549b1ae3dd39bfc867d1c725a4177692c4e7754".hexToBytes()
            ],
            [],
            2,
            *coopVaultCh
          )
        }
      } |
      for (@posRevAddress <- posRevAddressCh;
           @posAuthKey    <- posAuthKeyCh) {
        for (@(true, coopVault) <<- coopVaultCh) {
          // Creates PoS Rev vault with sum of initial bonds.
          new bondSumCh in {
            @ListOps!("fold", $$initialBonds$$.toList(), 0, *sumFromPair, *bondSumCh) |
            for (@bondSum <- bondSumCh) {
              @RevVault!("createWithBalance", posRevAddress, bondSum, *posVaultCh)
            }
          } |
          // Selects the initial active validators.
          pickActiveValidators!($$initialBonds$$, {}, *initialActiveCh) |
          for (@(true, posVault)  <- posVaultCh;
               @initialActive     <- initialActiveCh) {
            new stateCh, pendingRewardsInitializedCh in {
              // Initializes PoS state structure.
              stateCh!({
                // Map[PublicKey, Int] - each validator stake
                "allBonds"        : $$initialBonds$$,
                // List[PublicKey]     - the active validators
                "activeValidators": initialActive,
                // Map[PublicKey, Int] - are moved from pendingRewards on epoch change or slashing
                "committedRewards": {},
                // Map[PublicKey, Int] - the validators wishing to withdraw and the block number when their quarantine ends
                //                       This begins at the start of the next epoch + quarantineLength.
                "withdrawers"     : {},
                "randomImages"    : {},
                "randomNumbers"   : {},
              }) |
              // Peeks at bonds map.
              contract PoS(@"getBonds", returnCh) = {
                for (@state <<- stateCh) {
                  returnCh!(state.get("allBonds"))
                }
              } |
              // Peeks at active validator list.
              contract PoS(@"getActiveValidators", returnCh) = {
                for (@state <<- stateCh) {
                  returnCh!(state.get("activeValidators"))
                }
              } |
              // Peeks at active validator list.
              contract PoS(@"getWithdrawers", returnCh) = {
                for (@state <<- stateCh) {
                  returnCh!(state.get("withdrawers"))
                }
              } |
              // Peeks at active validator vaults.
              contract PoS(@"getActiveValidatorVaults", returnCh) = {
                for (@vaults <<- perActiveValidatorPosVaultsCh) {
                  returnCh!(vaults)
                }
              } |
              // Peeks at the accumulated rewards map, i.e. "committed rewards".
              // The returned map contains only the rewards committed up to the last closeBlock.
              contract PoS(@"getRewards", returnCh) = {
                for (@state <<- stateCh) {
                  returnCh!(state.get("committedRewards"))
                }
              } |
              // Exposes Coop multisig vault on returnCh.
              contract PoS(@"getCoopVault", returnCh) = {
                for (@(_, coopVault) <<- coopVaultCh) {
                  returnCh!(coopVault)
                }
              } |
              // Exposes initial PoS vault on returnCh.
              contract PoS(@"getInitialPosVault", returnCh) = {
                returnCh!(posVault)
              } |
              // Exposes epochLength parameter to PoSTest.
              contract PoS(@"getEpochLength", returnCh) = {
                returnCh!($$epochLength$$)
              } |
              // Exposes quarantineLength parameter to PoSTest.
              contract PoS(@"getQuarantineLength", returnCh) = {
                returnCh!($$quarantineLength$$)
              } |
              // Public method allowing users to bond and become validators.
              contract PoS(@"bond", @deployerId, @amount, returnCh) = {
                new userCh, depositCh,
                    processCh
                in {
                  runMVar!(*stateCh, *processCh, *returnCh) |
                  getUser!(deployerId, *userCh) |
                  for (@state, resultCh <- processCh;
                       @userPk          <- userCh) {
                    if (state.get("allBonds").contains(userPk)) {
                      resultCh!(state, (false, "Public key is already bonded."))
                    } else if (amount < $$minimumBond$$) {
                      resultCh!(state, (false, "Bond is less than minimum!"))
                    } else if (amount > $$maximumBond$$) {
                      resultCh!(state, (false, "Bond is greater than maximum!"))
                    } else {
                      // Transfers user's bond amount to the PoS vault.
                      deposit!(deployerId, amount, posRevAddress, *depositCh) |
                      for (@depositResult <- depositCh) {
                        match depositResult {
                          // If deposit is successful, the user becomes a bonded validator.
                          (true, _) => {
                            resultCh!(state.set("allBonds", state.get("allBonds").set(userPk, amount)), depositResult)
                          }
                          // If deposit is unsuccessful, the user is not bonded.
                          (false, errorMsg) => {
                            resultCh!(state, (false, "Bond deposit failed: " ++ errorMsg))
                          }
                        }
                      }
                    }
                  }
                }
              } |
              // Public method allowing validators to withdraw their bonded and accumulated funds.
              contract PoS(@"withdraw", @deployerId, returnCh) = {
                new userCh, processCh, blockDataCh,
                    getBlockData(`rho:block:data`)
                in {
                  // Consumes state and updates withdrawers map.
                  runMVar!(*stateCh, *processCh, *returnCh) |
                  getBlockData!(*blockDataCh) |
                  getUser!(deployerId, *userCh) |
                  for (@state, resultCh   <- processCh;
                       @userPk            <- userCh;
                       @blockNumber, _, _ <- blockDataCh) {
                    if (state.get("allBonds").contains(userPk)) {
                      // The withdrawal goes into effect at the start of the next epoch.
                      resultCh!(
                        state.set("withdrawers",
                                  state.get("withdrawers")
                                       .set(userPk,
                                         $$quarantineLength$$ + $$epochLength$$ * (1 + blockNumber / $$epochLength$$))),
                        (true, Nil))
                    } else {
                      resultCh!(state, (false, "User is not bonded"))
                    }
                  }
                }
              } |
              // Private method which charges a deployer for a deploy.
              // Deployer's funds are deposited into the block sender's vault.
              // Return expects (Boolean, Either[Nil, String])
              new currentDeployerData in {
                contract PoS(@"chargeDeploy", @deployerId, @amount, @sysAuthToken, return) = {
                  new isValidTokenCh in {
                    sysAuthTokenOps!("check", sysAuthToken, *isValidTokenCh) |
                    for (@isValid <- isValidTokenCh) {
                      if (isValid) {
                        new depositCh in {
                          deposit!(deployerId, amount, posRevAddress, *depositCh) |
                          for (@depositResult <- depositCh){
                            match depositResult {
                              (true, _) => {
                                currentDeployerData!((deployerId, amount)) |
                                return!(depositResult)
                              }
                              (_, errorMessage) => {
                                return!((false, "Deploy payment failed: " ++ errorMessage))
                              }
                            }
                          }
                        }
                      } else {
                        return!((false, "Invalid system auth token"))
                      }
                    }
                  }
                } |
                // Private method which refunds a deployer if too much was charged in chargeDeploy.
                // Funds are transferred from the block sender's vault to the deployer.
                // Return expects (Boolean, Either[Nil, String])
                contract PoS(@"refundDeploy", @refundAmount, @sysAuthToken, return) = {
                  new isValidTokenCh in {
                    sysAuthTokenOps!("check", sysAuthToken, *isValidTokenCh) |
                    for (@isValid <- isValidTokenCh) {
                      if (isValid) {
                        for (@(deployerId, initialPaymentAmount) <- currentDeployerData){
                          if (refundAmount > 0) {
                            new revAddressCh, transferCh in {
                              revAddressOps!("fromDeployerId", deployerId, *revAddressCh) |
                              for (@deployerRevAddress <- revAddressCh) {
                                // Transfer (from sender to deployer) called in refundDeploy.
                                @posVault!("transfer", deployerRevAddress, refundAmount, posAuthKey, *transferCh) |
                                for (@transferResult <- transferCh) {
                                  match transferResult {
                                    (true, _) => {
                                      return!((true, Nil))
                                    }
                                    (_, errorMessage) => {
                                      return!((false, "(Bug found) Deploy refund failed: " ++ errorMessage))
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            return!((true, Nil))
                          }
                        }
                      } else {
                        return!((false, "Invalid system auth token"))
                      }
                    }
                  }
                }
              } |
              new accumulateDeposits, commitRewards, moveFunds in {
                // Private method which transfers all of a validator's rewards + bond to the Coop vault.
                // Slash expects (Boolean, Either[Nil, String]) on returnCh.
                contract PoS(@"slash", @deployerId, @blockHash, @sysAuthToken, returnCh) = {
                  new isValidTokenCh in {
                    sysAuthTokenOps!("check", sysAuthToken, *isValidTokenCh) |
                    for (@isValid <- isValidTokenCh) {
                      if (isValid) {
                        new invalidBlocksCh, stateProcessCh, userCh,
                            getInvalidBlocks(`rho:casper:invalidBlocks`)
                        in {
                          getInvalidBlocks!(*invalidBlocksCh) |
                          getUser!(deployerId, *userCh) |
                          runMVar!(*stateCh, *stateProcessCh, *returnCh) |
                          for (@invalidBlocks        <- invalidBlocksCh;
                               @userPk               <- userCh;
                               @state, stateUpdateCh <- stateProcessCh) {
                            match coopVault {
                              (_, coopRevAddress, _) => {
                                new toBeSlashed, valBondCh, valRewardCh in {
                                  // Flow of logic:
                                  // 0. check if blockHash is the hash of an invalid block
                                  // 1. transfer stake of slashed validator from PoS to Coop vault
                                  // 2. update state
                                  // Retrieves either public key of sender of invalid block or the deployer public key.
                                  toBeSlashed!(invalidBlocks.getOrElse(blockHash, userPk)) |
                                  for (@validator <- toBeSlashed) {
                                    // Takes the stake of slashed validator
                                    valBondCh!(state.get("allBonds").get(validator)) |
                                    for (@valBond <- valBondCh) {
                                      // Transfers slashed funds from PoS vault to Coop vault, then updates state.
                                      new transferDoneCh in {
                                        @posVault!(
                                          "transfer",
                                          coopRevAddress,
                                          valBond,
                                          posAuthKey,
                                          *transferDoneCh
                                        ) |
                                        for (_ <- transferDoneCh) {
                                          // Moves slashed validator to withdrawers map to unbond at next epoch change.
                                          new blockDataCh,
                                              getBlockData(`rho:block:data`)
                                          in {
                                            getBlockData!(*blockDataCh) |
                                            for (@blockNumber, _, _ <- blockDataCh) {
                                              // Sets slashed validator's committed rewards and bond to 0 in state.
                                              // Moves slashed validator to withdrawers map with no quarantine period.
                                              stateUpdateCh!({
                                                "allBonds"        : state.get("allBonds").set(validator, 0),
                                                "activeValidators": state.get("activeValidators"),
                                                "withdrawers"     : state.get("withdrawers")
                                                                          .set(validator,
                                                                            $$quarantineLength$$ + $$epochLength$$ * (1 + blockNumber / $$epochLength$$)),
                                                "randomImages"    : state.get("randomImages"),
                                                "randomNumbers"   : state.get("randomNumbers")
                                              },
                                              (true, Nil))
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        returnCh!((false, "Invalid system auth token"))
                      }
                    }
                  }
                } |
                // Private method which signals the end of block processing.
                contract PoS(@"closeBlock", @sysAuthToken, ackCh) = {
                  new isValidTokenCh in {
                    sysAuthTokenOps!("check", sysAuthToken, *isValidTokenCh) |
                    for (@isValid <- isValidTokenCh) {
                      if (isValid) {
                        new blockDataCh, getBlockData(`rho:block:data`) in {
                          getBlockData!(*blockDataCh) |
                          for (@blockNumber, _, _ <- blockDataCh) {
                            if (blockNumber % $$epochLength$$ != 0) {
                              // Epoch change does not occur.
                              ackCh!((true, Nil))
                            } else {
                              // Epoch change occurs.
                              new payWithdrawers, removeQuarantinedWithdrawers,
                                  stateProcessCh, paymentDoneCh,
                                  accDepositsDoneCh, commitRewardsCh,
                                  newValidatorsCh, removeQuarantinedCh
                              in {
                                runMVar!(*stateCh, *stateProcessCh, *ackCh) |
                                for (@state, stateUpdateCh <- stateProcessCh) {
                                  // New active validators will be choosen from set of bonded validators who have not withdrawn.
                                  pickActiveValidators!(state.get("allBonds"), state.get("withdrawers"), *newValidatorsCh) |

                                  // Remove quarantined withdrawers from the bonds and withdrawers maps.
                                  removeQuarantinedWithdrawers!(
                                    blockNumber,
                                    state.get("allBonds"),
                                    state.get("withdrawers"),
                                    *removeQuarantinedCh) |
                                  // After new active validators are selected, deposits are accumulated, and
                                  // quarantined withdrawers are removed from the bonds map,
                                  // these withdrawing validators are paid out, then the state is updated.
                                  for (@newValidators                        <- newValidatorsCh;
                                       @(payments, newBonds, newWithdrawers) <- removeQuarantinedCh) {
                                    payWithdrawers!(payments, *paymentDoneCh) |
                                    for (_ <- paymentDoneCh) {
                                      stateUpdateCh!({
                                        "allBonds"        : newBonds,
                                        "activeValidators": newValidators,
                                        "withdrawers"     : newWithdrawers,
                                        "randomImages"    : {},
                                        "randomNumbers"   : {},
                                      },
                                      (true, Nil))
                                    }
                                  }
                                } |
                                // Transfers withdrawing validator's bond + accumulated rewards from PoS vault to their vault.
                                new payWithdrawer in {
                                  contract payWithdrawer(@(pk, amount), returnCh) = {
                                    new vaultCh, revAddressCh in {
                                      revAddressOps!("fromPublicKey", pk, *revAddressCh) |
                                      for (@toRevAddress <- revAddressCh) {
                                        @posVault!("transfer", toRevAddress, amount, posAuthKey, *returnCh)
                                      }
                                    }
                                  } |
                                  contract payWithdrawers(@payments, returnCh) = {
                                    @ListOps!("unorderedParMap", payments, *payWithdrawer, *returnCh)
                                  }
                                } |
                                // Checks withdrawer's quarantine period against current block number,
                                // then computes their payment, removes them from the bonds and withdrawers maps, and
                                // updates the committed rewards map.
                                contract removeQuarantinedWithdrawers(@currentBlockNumber, @allBonds, @withdrawers, returnCh) = {
                                  new quarantinedValidatorsCh, validatorsToWithdrawListCh,
                                      isQuarantineFinished, notWithdrawn,
                                      paymentsCh, computePay,
                                      newBondsListCh, newWithdrawersListCh,
                                      newRewardsListCh
                                  in {
                                    // Calculate rewards by taking PoS balance on PoS vault and subtract all active stake + newly bonded
                                    match {"<val_pub_key>": 0 /* reward */} {
                                      rewards => {
                                        @ListOps!("filter", withdrawers.toList(), *isQuarantineFinished, *quarantinedValidatorsCh) |
                                        for (@quarantinedValidators <- quarantinedValidatorsCh) {
                                          @ListOps!("map", quarantinedValidators, *fst, *validatorsToWithdrawListCh) |
                                          for (@validatorsToWithdrawList <- validatorsToWithdrawListCh) {
                                            @ListOps!("map", validatorsToWithdrawList, *computePay, *paymentsCh) |
                                            contract computePay(@pk, resultCh) = {
                                              resultCh!((pk, allBonds.get(pk) + rewards.getOrElse(pk, 0)))
                                            } |
                                            match validatorsToWithdrawList.toSet() {
                                              validatorsToWithdrawSet => {
                                                @ListOps!("filter", allBonds.toList(), *notWithdrawn, *newBondsListCh) |
                                                @ListOps!("filter", withdrawers.toList(), *notWithdrawn, *newWithdrawersListCh) |
                                                @ListOps!("filter", rewards.toList(), *notWithdrawn, *newRewardsListCh) |
                                                for (@newWithdrawersList <- newWithdrawersListCh;
                                                    @newBondsList       <- newBondsListCh;
                                                    @newRewardsList     <- newRewardsListCh;
                                                    @payments           <- paymentsCh) {
                                                  returnCh!((
                                                    payments,
                                                    newBondsList.toMap(),
                                                    newWithdrawersList.toMap(),
                                                    // newRewardsList.toMap()
                                                  ))
                                                } |
                                                // Checks that the validator is not a withdrawer.
                                                contract notWithdrawn(@(pk, _), resultCh) = {
                                                  resultCh!(not validatorsToWithdrawSet.contains(pk))
                                                }
                                              }
                                            }
                                          }
                                        } |
                                        // Check whether quarantine period is finished.
                                        contract isQuarantineFinished(@(_, blockNumber), resultCh) = {
                                          resultCh!(currentBlockNumber >= blockNumber)
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        ackCh!((false, "Invalid system auth token"))
                      }
                    }
                  }
                } |
                // Moves the entire contents of a validator's vault to the PoS vault.
                contract moveFunds(@(unf, revAddr, vault), returnCh) = {
                  new balanceCh, unfAuthKeyCh, transferDoneCh in {
                    @vault!("balance", *balanceCh) |
                    for (@balance <- balanceCh) {
                      if (balance > 0) {
                        @RevVault!("unforgeableAuthKey", unf, *unfAuthKeyCh) |
                        for (@authKey <- unfAuthKeyCh) {
                          // Transfer funds from validator vault to the PoS vault.
                          @vault!("transfer", posRevAddress, balance, authKey, *transferDoneCh) |
                          for (@(true, _) <- transferDoneCh) {
                            returnCh!(true)
                          }
                        }
                      } else {
                        returnCh!(true)
                      }
                    }
                  }
                } |
                // Transfers all accumulated funds to the PoS vault.
                contract accumulateDeposits(returnCh) = {
                  for (@vaults <<- perActiveValidatorPosVaultsCh) {
                    @ListOps!("parMap", vaults, *moveFunds, *returnCh)
                  }
                }
              } |
              //
              contract PoS(@"commitRandomImage", @deployerId, @hash, ackCh) = {
                new userCh, mvarCh in {
                  getUser!(deployerId, *userCh) |
                  runMVar!(*stateCh, *mvarCh, *ackCh) |
                  for (@validator       <- userCh;
                       @state, resultCh <- mvarCh) {
                    if (state.get("randomImages").contains(validator)) {
                      resultCh!(state, (false, "Image already committed"))
                    } else {
                      resultCh!(
                        state.set("randomImages", state.get("randomImages").set(validator, hash)), true)
                    }
                  }
                }
              } |
              //
              contract PoS(@"revealRandom", @deployerId, @random, ackCh) = {
                new userCh, mvarCh, computeHash(`rho:crypto:keccak256Hash`), hashCh in {
                  getUser!(deployerId, *userCh) |
                  runMVar!(*stateCh, *mvarCh, *ackCh) |
                  computeHash!(random, *hashCh) |
                  for (@validator       <- userCh;
                       @state, resultCh <- mvarCh;
                       @hash            <- hashCh) {
                    if (state.get("randomImages").contains(validator)) {
                      if (hash == state.get("randomImages").get(validator)) {
                        resultCh!(
                          state.set("randomNumbers",state.get("randomNumbers").set(validator, random)), true)
                      } else {
                        resultCh!(state, (false, "Previously committed image doesn't match the random number"))
                      }
                    } else {
                      resultCh!(state, (false, "Previously committed random image not found"))
                    }
                  }
                }
              }
            }
          }
        } |
        // Transfers funds from deployer to block sender.
        contract deposit(@deployerId, @amount, @toTargetAddress, returnCh) = {
          new vaultCh, revAddressCh,
              indexSender, authKeyCh
          in {
            @RevVault!("deployerAuthKey", deployerId, *authKeyCh) |
            revAddressOps!("fromDeployerId", deployerId, *revAddressCh) |
            for (@authKey        <- authKeyCh;
                 @fromRevAddress <- revAddressCh) {
              @RevVault!("findOrCreate", fromRevAddress, *vaultCh) |
              for (@(true, fromVault) <- vaultCh) {
                // Transfers from deployer to PoS vault
                @fromVault!("transfer", toTargetAddress, amount, authKey, *returnCh)
              }
            }
          }
        } |
        // Stake-weighted distribution of final deployment cost for bookkeeping in validator state.
        contract distributeRewards(@amount, @activeValidators, @bonds, returnCh) = {
          new computeSum, computeDelta, totalActiveStakeCh in {
            @ListOps!("fold", activeValidators, 0, *computeSum, *totalActiveStakeCh) |
            contract computeSum(@pk, @acc, resultCh) = {
              resultCh!(acc + bonds.get(pk))
            } |
            // Computes the rewards delta for each active validator.
            for (@totalActiveStake <- totalActiveStakeCh) {
              @ListOps!("fold", activeValidators, {}, *computeDelta, *returnCh) |
              // Stake-weighted rewards delta map.
              contract computeDelta(@pk, @acc, resultCh) = {
                resultCh!(acc.set(pk, (amount * bonds.get(pk)) / totalActiveStake))
              }
            }
          }
        }
      } |
      // Updates value stored on varCh and sends (Bool) acknowledgement on returnCh.
      contract runMVar(varCh, processCh, returnCh) = {
        new resultCh in {
          for (@v <- varCh) {
            processCh!(v, *resultCh) |
            for (@newV, @result <- resultCh) {
              varCh!(newV) |
              returnCh!(result)
            }
          }
        }
      } |
      // Discards second element of a pair.
      contract fst(@(first, _), resultCh) = {
        resultCh!(first)
      } |
      // For computing some of initial validator bonds.
      contract sumFromPair(@(_, a), @b, resultCh) = {
        resultCh!(a + b)
      } |
      // Retrieves deployer's public key.
      contract getUser(@deployerId, returnCh) = {
        new deployerIdOps(`rho:rchain:deployerId:ops`) in {
          deployerIdOps!("pubKeyBytes", deployerId, *returnCh)
        }
      } |
      // Selects set of active validators from the set of available validators.
      contract pickActiveValidators(@allBonds, @withdrawers, returnCh) = {
        new availableValidatorsCh,
            isAvailable, pksCh
        in {
          @ListOps!("filter", allBonds.toList(), *isAvailable, *availableValidatorsCh) |
          contract isAvailable(@(pk, _), resultCh) = {
            resultCh!(not withdrawers.contains(pk))
          } |
          for (@availableValidators <- availableValidatorsCh) {
            @ListOps!("map", availableValidators, *fst, *pksCh) |
            for (@pks <- pksCh) {
              // TODO: Randomly select 100 active validators once we have on-chain randomness
              returnCh!(pks.take($$numberOfActiveValidators$$))
            }
          }
        }
      }
    } |
    // Registers signed write-only PoS contract bundle.
    rs!(
      "047b43d6548b72813b89ac1b9f9ca67624a8b372feedd71d4e2da036384a3e1236812227e524e6f237cde5f80dbb921cac12e6500791e9a9ed1254a745a816fe1f".hexToBytes(),
      (9223372036854775807, bundle+{*PoS}),
      "3044022054ff4bae3984252b116e41e28d98bb5533eaa39aec2729228159166e2784f641022066a0fd99e7ea33df812fab095cbe61250f9548bce6da3ec4c6a90c741b94087f".hexToBytes(),
      *uriOut)
  }
}
