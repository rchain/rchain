// Rholang macro parameters:
// minimumBond - the minimum bond allowed by the PoS
// maximumBond - the maximum bond allowed by PoS
// initialBonds - the initial bonds map
// epochLength - the length of the validation epoch in blocks
// quarantineLength - the length of the quarantine time in blocks

/*
 The table below describes the required computations and their dependencies

 No. | Dependency | Computation method | Result
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 1.  |            | given              | sk = a9585a0687761139ab3587a4938fb5ab9fcba675c79fefba889859674046d4a5
 2.  |            | given              | timestamp = 1559156420651
 3.  |            | lastNonce          | nonce = 9223372036854775807
 4.  | 1,         | secp256k1          | pk = 047b43d6548b72813b89ac1b9f9ca67624a8b372feedd71d4e2da036384a3e1236812227e524e6f237cde5f80dbb921cac12e6500791e9a9ed1254a745a816fe1f
 5.  | 4, 2,      | genIds             | uname = Unforgeable(0xa32c1649f1700469f125ea85f9c2a220072e593ae617213782d738e389639d3b)
 6.  | 3, 5,      | registry           | value = (9223372036854775807, bundle+ {   Unforgeable(0xa32c1649f1700469f125ea85f9c2a220072e593ae617213782d738e389639d3b) })
 7.  | 6,         | protobuf           | toSign = 2a40aa013d0a0d2a0b10feffffffffffffffff010a2c5a2a0a263a240a220a20a32c1649f1700469f125ea85f9c2a220072e593ae617213782d738e389639d3b1001
 8.  | 7, 1,      | secp256k1          | sig = 3044022054ff4bae3984252b116e41e28d98bb5533eaa39aec2729228159166e2784f641022066a0fd99e7ea33df812fab095cbe61250f9548bce6da3ec4c6a90c741b94087f
 9.  | 4,         | registry           | uri = rho:id:m3xk7h8r54dtqtwsrnxqzhe81baswey66nzw6m533nyd45ptyoybqr
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 */
new  PoS,
    registryLookup(`rho:registry:lookup`),
    revAddressOps(`rho:rev:address`),
    revVaultCh, listOpsCh,
    getUser,
    getCurrentUserAddress,
    pickActiveValidators,
    runMVar,
    fst,
    deposit, distributeRewards,
    perActiveValidatorPosVaultsCh,
    transferFromBlockSender,
    rs(`rho:registry:insertSigned:secp256k1`),
    posId(`rho:rchain:deployerId`),
    PendingRewards, MergeIntMaps, treeHashMapCh,
    sysAuthTokenOps(`sys:authToken:ops`),
    uriOut
in {
  registryLookup!(`rho:rchain:revVault`, *revVaultCh) |
  registryLookup!(`rho:lang:listOps`, *listOpsCh) |
  registryLookup!(`rho:lang:treeHashMap`, *treeHashMapCh) |

  for(@(_, RevVault) <- revVaultCh;
      @(_, ListOps) <- listOpsCh;
      TreeHashMap <- treeHashMapCh) {
    new posRevAddressCh, posAuthKeyCh, posVaultCh, initialActiveCh, pendingRewardsMapCh in {

      @RevVault!("deployerAuthKey", *posId, *posAuthKeyCh) |
      getCurrentUserAddress!(*posId, *posRevAddressCh) |

      new rangeCh, makeVault in {
        contract makeVault(_, returnCh) = {
          new unf, revAddressCh, vaultCh in {
            revAddressOps!("fromUnforgeable", *unf, *revAddressCh) |
            for (@revAddress <- revAddressCh) {
              @RevVault!("findOrCreate", revAddress, *vaultCh) |
              for (@(true, vault) <- vaultCh) {
                returnCh!((*unf, revAddress, vault))
              }
            }
          }
        } |

        @ListOps!("range", 0, $$numberOfActiveValidators$$, *rangeCh) |
        for (@range <- rangeCh) {
          @ListOps!("parMap", range, *makeVault, *perActiveValidatorPosVaultsCh)
        }
      } |

      for(@posRevAddress <- posRevAddressCh;
          @posAuthKey <- posAuthKeyCh) {

        @RevVault!("findOrCreate", posRevAddress, *posVaultCh) |
        pickActiveValidators!($$initialBonds$$, {}, *initialActiveCh) |

        // Initialize pending rewards Tree Hash map
        // - each key in pending rewards state is Map[PublickKey, Int] accummulated by calling "refundDeploy"
        TreeHashMap!("init", 3, *pendingRewardsMapCh) |

        for (@(true, posVault) <- posVaultCh;
             @initialActive <- initialActiveCh;
             @pendingRewardsMap <- pendingRewardsMapCh) {
          new stateCh, pendingRewardsInitializedCh in {
            // Initialize empty pending rewards state for each validator
            // - states must be initialized to prevent conflicts when are "set" (only lookup can be conflict free)
            PendingRewards!("init", initialActive, *pendingRewardsInitializedCh) |
            for (_ <- pendingRewardsInitializedCh) {
              // Initialize PoS state structure
              stateCh!({
                // Map[PublickKey, Int] - each validator stake
                "allBonds"        : $$initialBonds$$,
                // List[PublicKey] - the active validators
                "activeValidators": initialActive,
                // Map[PublickKey, Int] - are moved from pendingRewards on epoch change or slashing
                "committedRewards": {},
                // Map[PublicKey, Int] - the validators willing to withdraw and the blocknumber when their quarantine ends
                //                       This is the beggining of the next epoch after their withdrawal + quarantineLength
                "withdrawers"     : {},
                "randomImages"    : {},
                "randomNumbers"   : {},
              })
            } |

            contract PoS (@"getBonds", returnCh) = {
              for (@state <<- stateCh) {
                returnCh!(state.get("allBonds"))
              }
            } |

            contract PoS (@"getActiveValidators", returnCh) = {
              for (@state <<- stateCh) {
                returnCh!(state.get("activeValidators"))
              }
            } |

            contract PoS (@"getActiveValidatorVaults", returnCh) = {
              for(@vaults <<- perActiveValidatorPosVaultsCh) {
                returnCh!(vaults)
              }
            } |

            /**
             * Returns a Map[PublidKey, Int] containing the rewards accumulated for each validator.
             * The returned map contains only the committed rewards after the last closeBlock
             */
            contract PoS (@"getRewards", returnCh) = {
              for (@state <<- stateCh) {
                returnCh!(state.get("committedRewards"))
              }
            } |

            contract PoS (@"bond", @deployerId, @amount, returnCh) = {
              new userCh, depositCh, processCh in {
                runMVar!(*stateCh, *processCh, *returnCh) |
                getUser!(deployerId, *userCh) |
                for(@state, resultCh <- processCh;
                    @userPk <- userCh) {
                  if (state.get("allBonds").contains(userPk)) {
                    resultCh!(state, (false, "Public key is already bonded."))
                  } else if (amount < $$minimumBond$$) {
                    resultCh!(state, (false, "Bond is less than minimum!"))
                  } else if (amount > $$maximumBond$$) {
                    resultCh!(state, (false, "Bond is greater than maximum!"))
                  } else {
                    deposit!(deployerId, amount, state.get("activeValidators"), *depositCh) |
                    for(@depositResult <- depositCh) {
                      match depositResult {
                        (true, _) => {
                          resultCh!(
                            state.set(
                              "allBonds",
                              state.get("allBonds").set(userPk,amount)),
                            depositResult
                          )
                        }
                        (false, errorMsg) => {
                          resultCh!(state, (false, "Bond deposit failed: " ++ errorMsg))
                        }
                      }
                    }
                  }
                }
              }
            } |

            contract PoS (@"withdraw", @deployerId, returnCh) = {
              new userCh, processCh,
                  getBlockData(`rho:block:data`),
                  blockDataCh
              in {
                runMVar!(*stateCh, *processCh, *returnCh) |

                getBlockData!(*blockDataCh) |
                getUser!(deployerId, *userCh) |
                for(@state, resultCh <- processCh;
                    @userPk <- userCh;
                    @blockNumber, _, _ <- blockDataCh) {
                  if (state.get("allBonds").contains(userPk)) {
                    // the withdwal is in effect starting from the next epoch
                    resultCh!(
                      state.set("withdrawers",
                                state.get("withdrawers")
                                     .set(userPk,
                                       $$quarantineLength$$ + $$epochLength$$ * (1 + blockNumber / $$epochLength$$))),
                      (true, Nil))
                  } else {
                    resultCh!(state, (false, "User is not bonded"))
                  }
                }
              }
            } |

            new currentDeployerData in {
              contract PoS (@"chargeDeploy", @deployerId, @amount, @sysAuthToken, return) = {
                new isValidTokenCh in {
                  sysAuthTokenOps!("check", sysAuthToken, *isValidTokenCh) |
                  for (@isValid <- isValidTokenCh) {
                    if (isValid) {
                      new depositCh in {
                        for (@state <<- stateCh) {
                          deposit!(deployerId, amount, state.get("activeValidators"), *depositCh) |
                          for(@depositResult <- depositCh){
                            match depositResult {
                              (true, _) => {
                                currentDeployerData!((deployerId, amount)) |
                                return!(depositResult)
                              }
                              (_, errorMessage) => {
                                return!((false, "Deploy payment failed: " ++ errorMessage))
                              }
                            }
                          }
                        }
                      }
                    } else {
                      return!((false, "Invalid system auth token"))
                    }
                  }
                }
              } |

              contract transferFromBlockSender(@deployerRevAddress, @refundAmount, returnCh) = {
                new getBlockData(`rho:block:data`),
                    blockDataCh,
                    indexSender,
                    unfAuthKeyCh,
                    tmpCh in {
                  getBlockData!(*blockDataCh) |
                  for (_, _, @sender <- blockDataCh) {
                    for (@state <<- stateCh) {
                      @ListOps!("indexOf", state.get("activeValidators"), sender, *indexSender) |
                      for (@idx <- indexSender) {
                        for (@vaults <<- perActiveValidatorPosVaultsCh) {
                          if (idx == -1) {
                            returnCh!((false, "Sender is not an active validator"))
                          } else {
                            match vaults.nth(idx) {
                              (unf, _, activeValidatorVault) => {
                                @RevVault!("unforgeableAuthKey", unf, *unfAuthKeyCh) |
                                for (@authKey <- unfAuthKeyCh) {
                                  @activeValidatorVault!("transfer", deployerRevAddress, refundAmount, authKey, *returnCh)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } |

              contract PoS (@"refundDeploy", @refundAmount, @sysAuthToken, return) = {
                new isValidTokenCh in {
                  sysAuthTokenOps!("check", sysAuthToken, *isValidTokenCh) |
                  for (@isValid <- isValidTokenCh) {
                    if (isValid) {
                      for(@(deployerId, initialPaymentAmount) <- currentDeployerData){
                        new revAddressCh in {
                          revAddressOps!("fromDeployerId", deployerId, *revAddressCh) |
                          for(@deployerRevAddress <- revAddressCh){
                            new transferCh in {
                              transferFromBlockSender!(deployerRevAddress, refundAmount, *transferCh) |
                              for(@transferResult <- transferCh){
                                match transferResult {
                                  (true, _) => {
                                    new newRewardsCh, pendingUpdatedCh, blockDataCh, getBlockData(`rho:block:data`) in {
                                      for (@state <<- stateCh) {
                                        distributeRewards!(
                                          initialPaymentAmount - refundAmount,
                                          state.get("activeValidators"),
                                          state.get("allBonds"),
                                          *newRewardsCh)
                                      } |
                                      getBlockData!(*blockDataCh) |
                                      for(@newRewards <- newRewardsCh;
                                          _, _, @sender <- blockDataCh) {
                                        // Add new pending rewards to validator pending rewards state
                                        PendingRewards!("append", sender, newRewards, *pendingUpdatedCh) |
                                        for (_ <- pendingUpdatedCh) {
                                          return!((true, Nil))
                                        }
                                      }
                                    }
                                  }
                                  (_, errorMessage) => {
                                    return!((false, "(Bug found) Deploy refund failed: " ++ errorMessage))
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      return!((false, "Invalid system auth token"))
                    }
                  }
                }
              }
            } |

            contract PoS(@"slash", @deployerId, @blockHash, @sysAuthToken, returnCh) = {
              new isValidTokenCh in {
                sysAuthTokenOps!("check", sysAuthToken, *isValidTokenCh) |
                for (@isValid <- isValidTokenCh) {
                  if (isValid) {
                    new userCh, invalidBlocksCh, doSlashCh,
                        getInvalidBlocks(`rho:casper:invalidBlocks`) in {
                      getInvalidBlocks!(*invalidBlocksCh) |
                      getUser!(deployerId, *userCh) |

                      runMVar!(*stateCh, *doSlashCh, *returnCh) |
                      for (@invalidBlocks <- invalidBlocksCh;
                           @userPk <- userCh;
                           @state, slashResultCh <- doSlashCh) {
                        new toBeSlashed in {
                          toBeSlashed!(invalidBlocks.getOrElse(blockHash, userPk)) |
                          for (@validator <- toBeSlashed) {
                            new valPendingRewardsCh in {
                              // Collect and reset slashed validator pending rewards (from per validator states)
                              PendingRewards!("collectValue", validator, state.get("activeValidators"), *valPendingRewardsCh) |
                              for (@validatorPendingRewards <- valPendingRewardsCh) {
                                // TODO: Transfer to coop wallet instead of just simply setting bonds to 0
                                // Slashed rewards:
                                // + validatorPendingRewards
                                // + state.get("committedRewards")
                                slashResultCh!(
                                  state.set("committedRewards",
                                            state.get("committedRewards").set(validator, 0))
                                      .set("allBonds",
                                            state.get("allBonds").set(validator, 0)),
                                  true)
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    returnCh!((false, "Invalid system auth token"))
                  }
                }
              }
            } |

            contract PoS(@"closeBlock", @sysAuthToken, ackCh) = {
              new isValidTokenCh in {
                sysAuthTokenOps!("check", sysAuthToken, *isValidTokenCh) |
                for (@isValid <- isValidTokenCh) {
                  if (isValid) {
                    new accumulateDeposits,
                        commitRewards,
                        changeEpoch,
                        removeQuarantinedWithdrawers,
                        payValidators
                    in {
                      new blockDataCh, mvarProcessCh,
                          getBlockData(`rho:block:data`),
                          accDepositsDoneCh,
                          commitRewardsCh,
                          newValidatorsCh, removeQuarantinedCh, paymentDoneCh
                      in {
                        getBlockData!(*blockDataCh) |

                        runMVar!(*stateCh, *mvarProcessCh, *ackCh) |
                        for(@blockNumber, _, _ <- blockDataCh;
                            @state, mvarResultCh <- mvarProcessCh) {
                          // Before choosing new active validators and paying out any withdrawers,
                          // deposits have to be accumulated into one vault for now.
                          accumulateDeposits!(posRevAddress, *accDepositsDoneCh) |

                          changeEpoch!(
                            blockNumber,
                            state.get("allBonds"),
                            state.get("activeValidators"),
                            state.get("withdrawers"),
                            *newValidatorsCh)|

                          new pendingRewardsAllCh in {
                            // Collect pending rewards from all validators and reset state to zero
                            PendingRewards!("collect", state.get("activeValidators"), *pendingRewardsAllCh) |
                            for (@pendingRewards <- pendingRewardsAllCh) {
                              for (@newValidatorKeys <<- newValidatorsCh) {
                                new ackInitCh in {
                                  // Initialize empty pending rewards state with new set of validators
                                  PendingRewards!("init", newValidatorKeys, *ackInitCh) |
                                  for (_ <- ackInitCh) {
                                    // Sum of pending rewards to committed rewards
                                    commitRewards!(pendingRewards, state.get("committedRewards"), *commitRewardsCh)
                                  }
                                }
                              }
                            }
                          } |

                          for (@committedRewards <- commitRewardsCh) {

                            removeQuarantinedWithdrawers!(
                              blockNumber,
                              state.get("allBonds"),
                              state.get("withdrawers"),
                              committedRewards,
                              *removeQuarantinedCh)
                          } |

                          for(@newValidators <- newValidatorsCh;
                              @(payments, newBonds, newWithdrawers, newRewards) <- removeQuarantinedCh;
                              _ <- accDepositsDoneCh) {

                            payValidators!(payments, *paymentDoneCh) |

                            for (_ <- paymentDoneCh) {

                              mvarResultCh!({
                                "allBonds"        : newBonds,
                                "activeValidators": newValidators,
                                "committedRewards": newRewards,
                                "withdrawers"     : newWithdrawers,
                                "randomImages"    : {},
                                "randomNumbers"   : {},
                              }, (true, Nil))
                            }
                          }
                        }
                      } |

                      new moveFunds in {
                        contract moveFunds(@(unf, _, vault), returnCh) = {
                          new balanceCh, unfAuthKeyCh, transferDoneCh in {
                            @vault!("balance", *balanceCh) |
                            for (@balance <- balanceCh) {
                              if (balance > 0) {
                                @RevVault!("unforgeableAuthKey", unf, *unfAuthKeyCh) |
                                for (@authKey <- unfAuthKeyCh) {
                                  @vault!("transfer", posRevAddress, balance, authKey, *transferDoneCh) |
                                  for (@(true, Nil) <- transferDoneCh) {
                                    returnCh!(true)
                                  }
                                }
                              } else {
                                returnCh!(true)
                              }
                            }
                          }
                        } |

                        contract accumulateDeposits(destRevAddress, ackCh) = {
                          for(@vaults <<- perActiveValidatorPosVaultsCh) {
                            @ListOps!("parMap", vaults, *moveFunds, *ackCh)
                          }
                        }
                      } |

                      new payValidator in {
                        contract payValidator (@(pk, amount), returnCh) = {
                          new vaultCh, revAddressCh in {
                            revAddressOps!("fromPublicKey", pk, *revAddressCh) |
                            for (@toRevAddress <- revAddressCh) {
                              @posVault!("transfer", toRevAddress, amount, posAuthKey, *returnCh)
                            }
                          }
                        } |
                        contract payValidators(@payments, ackCh) = {
                          @ListOps!("unorderedParMap", payments, *payValidator, *ackCh)
                        }
                      } |

                      new commitReward in {
                        contract commitReward(@(pk, pending), @acc, resultCh) = {
                          resultCh!(acc.set(pk, acc.getOrElse(pk, 0) + pending))
                        } |
                        contract commitRewards(@pendingRewards, @rewards, newRewardsCh) = {
                          @ListOps!("fold", pendingRewards.toList(), rewards, *commitReward, *newRewardsCh)
                        }
                      } |

                      contract changeEpoch(@currentBlockNumber, @allBonds, @activeValidators, @withdrawers, resultCh) = {
                        if (currentBlockNumber % $$epochLength$$ == 0) {
                          pickActiveValidators!(allBonds, withdrawers, *resultCh)
                        } else {
                          resultCh!(activeValidators)
                        }
                      } |

                      contract removeQuarantinedWithdrawers(@currentBlockNumber, @allBonds, @withdrawers, @rewards, returnCh) = {
                        new quarantinedValidatorsCh,
                            validatorsToWithdrawListCh,
                            isQuarantineFinished,
                            notWithdrawn,
                            newBondsListCh,
                            newWithdrawersListCh,
                            newRewardsListCh,
                            paymentsCh, computePay
                        in {
                          @ListOps!("filter", withdrawers.toList(), *isQuarantineFinished, *quarantinedValidatorsCh) |
                          for (@quarantinedValidators <- quarantinedValidatorsCh) {
                            @ListOps!("map", quarantinedValidators, *fst, *validatorsToWithdrawListCh) |
                            for (@validatorsToWithdrawList <- validatorsToWithdrawListCh) {
                              @ListOps!("map", validatorsToWithdrawList, *computePay, *paymentsCh) |
                              contract computePay(@pk, resultCh) = {
                                resultCh!((pk, allBonds.get(pk) + rewards.getOrElse(pk, 0)))
                              } |

                              match validatorsToWithdrawList.toSet() {
                                validatorsToWithdrawSet => {
                                  @ListOps!("filter", allBonds.toList(), *notWithdrawn, *newBondsListCh) |
                                  @ListOps!("filter", withdrawers.toList(), *notWithdrawn, *newWithdrawersListCh) |
                                  @ListOps!("filter", rewards.toList(), *notWithdrawn, *newRewardsListCh) |

                                  for (@newWithdrawersList <- newWithdrawersListCh;
                                       @newBondsList <- newBondsListCh;
                                       @newRewardsList <- newRewardsListCh;
                                       @payments <- paymentsCh) {
                                    returnCh!((payments, newBondsList.toMap(), newWithdrawersList.toMap(), newRewardsList.toMap()))
                                  } |

                                  contract notWithdrawn(@(pk, _), resultCh) = { resultCh!(not validatorsToWithdrawSet.contains(pk))}
                                }
                              }
                            }
                          } |

                          contract isQuarantineFinished(@(_, blockNumber), resultCh) = {
                            resultCh!(blockNumber >= currentBlockNumber)
                          }
                        }
                      }
                    }
                  } else {
                    ackCh!((false, "Invalid system auth token"))
                  }
                }
              }
            } |

            contract PoS(@"commitRandomImage", @deployerId, @hash, ackCh) = {
              new userCh, mvarCh in {
                getUser!(deployerId, *userCh) |

                runMVar!(*stateCh, *mvarCh, *ackCh) |
                for (@validator <- userCh;
                     @state, resultCh <- mvarCh) {
                  if (state.get("randomImages").contains(validator)) {
                    resultCh!(state, (false, "Image already committed"))
                  }
                  else {
                    resultCh!(
                      state.set("randomImages",
                               state.get("randomImages").set(validator, hash)),
                      true)
                  }
               }
             }
            } |

            contract PoS(@"revealRandom", @deployerId, @random, ackCh) = {
              new userCh, mvarCh, computeHash(`rho:crypto:keccak256Hash`), hashCh in {
                getUser!(deployerId, *userCh) |

                runMVar!(*stateCh, *mvarCh, *ackCh) |
                computeHash!(random, *hashCh) |
                for (@validator <- userCh;
                     @state, resultCh <- mvarCh;
                     @hash <- hashCh) {
                  if (state.get("randomImages").contains(validator)) {
                    if (hash == state.get("randomImages").get(validator))
                    {
                      resultCh!(
                        state.set("randomNumbers",
                          state.get("randomNumbers").set(validator, random)),
                        true)
                    } else
                    {
                      resultCh!(state, (false, "Previously committed image doesn't match the random number"))
                    }
                  }
                  else {
                      resultCh! (state, (false, "Previously committed random image not found"))
                  }
               }
             }
            } |

            // Initialize pending rewards state for each validator
            contract PendingRewards(@"init", @validatorKeys, @return) = {
              new createStateKeyCh in {
                @ListOps!("map", validatorKeys, *createStateKeyCh, return) |
                contract createStateKeyCh(@key, @ackCh) = {
                  TreeHashMap!("set", pendingRewardsMap, key, {}, ackCh)
                }
              }
            } |

            // Sum of new pending rewards with existing state
            contract PendingRewards(@"append", @validatorKey, @newRewards, @return) = {
              new currentRewardsCh in {
                // Get existing pending rewards (per validator)
                // - validator key is always initialized so here we can use unsafe get
                TreeHashMap!("fastUnsafeGet", pendingRewardsMap, validatorKey, *currentRewardsCh) |
                for (@currentRewards <- currentRewardsCh) {
                  new mergeResultCh in {
                    // Merge (sum) current pending rewards with new pending rewards
                    MergeIntMaps!(currentRewards, newRewards, *mergeResultCh) |
                    for (@mergeResult <- mergeResultCh) {
                      // Update pending rewards state
                      TreeHashMap!("set", pendingRewardsMap, validatorKey, mergeResult, return)
                    }
                  }
                }
              }
            } |

            // Collect pending rewards from all validators (in a map) / reset state to zero
            contract PendingRewards(@"collect", @validatorKeys, @return) = {
              new collectMaps, mapsListCh in {
                // Get pending rewards (maps) for list of validators (public keys)
                @ListOps!("fold", validatorKeys, [], *collectMaps, *mapsListCh) |
                contract collectMaps(@validatorKey, @acc, mergeRet) = {
                  new updateCh, updateAckCh in {
                    // Update (per validator) pending rewards
                    // - collect existing values and reset to empty map
                    TreeHashMap!("update", pendingRewardsMap, validatorKey, *updateCh, *updateAckCh) |
                    for (@rewardsMap, rewardsRet <- updateCh) {
                      // Reset per validator pending rewards state
                      rewardsRet!({}) |
                      // Accumulate all reward maps
                      for (_ <- updateAckCh) {
                        mergeRet!(acc ++ [rewardsMap])
                      }
                    }
                  }
                } |

                // Merge pending rewards (maps) to one map of pending rewards
                for (@mapsList <- mapsListCh) {
                  @ListOps!("fold", mapsList, {}, *MergeIntMaps, return)
                }
              }
            } |

            // Collect rewards for one validator from all validators / reset this validator state to zero
            contract PendingRewards(@"collectValue", @collectValidatorKey, @validatorKeys, @return) = {
              new collectRewards in {
                // Get pending rewards (maps) for list of validators (public keys)
                @ListOps!("fold", validatorKeys, 0, *collectRewards, return) |
                contract collectRewards(@validatorKey, @acc, sumReturn) = {
                  new updateCh, updateAckCh in {
                    // Update validator pending rewards
                    // - collect existing values and reset to zero
                    TreeHashMap!("update", pendingRewardsMap, validatorKey, *updateCh, *updateAckCh) |
                    for (@rewardsMap, rewardsRet <- updateCh) {
                      // Reset validator pending rewards state
                      rewardsRet!(rewardsMap.set(collectValidatorKey, 0)) |
                      // Sum of validator pending rewards from all validators states
                      for (_ <- updateAckCh) {
                        match rewardsMap.get(collectValidatorKey) {
                          Nil => sumReturn!(acc)
                          val => sumReturn!(acc + rewardsMap.get(collectValidatorKey))
                        }
                      }
                    }
                  }
                }
              }
            }

          }
        } |

        contract deposit (@deployerId, @amount, @activeValidators, returnCh) = {
          new vaultCh,
              revAddressCh,
              indexSender,
              getBlockData(`rho:block:data`), blockDataCh,
              authKeyCh in {
            @RevVault!("deployerAuthKey", deployerId, *authKeyCh) |
            revAddressOps!("fromDeployerId", deployerId, *revAddressCh) |
            for (@authKey <- authKeyCh; @fromRevAddress <- revAddressCh) {
              @RevVault!("findOrCreate", fromRevAddress, *vaultCh) |
              getBlockData!(*blockDataCh) |
              for (@(true, fromVault) <- vaultCh; _, _, @sender <- blockDataCh) {
                @ListOps!("indexOf", activeValidators, sender, *indexSender) |
                for (@idx <- indexSender) {
                  for (@vaults <<- perActiveValidatorPosVaultsCh) {
                    if (idx == -1) {
                      returnCh!((false, "Sender is not an active validator"))
                    } else {
                      match vaults.nth(idx) {
                        (_, activeValidatorVault, _) => {
                          @fromVault!("transfer", activeValidatorVault, amount, authKey, *returnCh)
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } |

        contract distributeRewards(@amount, @activeValidators, @bonds, returnCh) = {
          new computeSum, computeDelta, totalActiveStakeCh in {
            @ListOps!("fold", activeValidators, 0, *computeSum, *totalActiveStakeCh) |
            contract computeSum(@pk, @acc, resultCh) = {
              resultCh!(acc + bonds.get(pk))
            } |

            for(@totalActiveStake <- totalActiveStakeCh) {
              @ListOps!("fold", activeValidators, {}, *computeDelta, *returnCh) |
              contract computeDelta(@pk, @acc, resultCh) = {
                resultCh!(acc.set(pk, (amount * bonds.get(pk)) / totalActiveStake))
              }
            }
          }
        }
      } |

      contract runMVar(varCh, processCh, returnCh) = {
        new resultCh in {
          for (@v <- varCh) {
            processCh!(v, *resultCh) |
            for (@newV, @result <- resultCh) {
              varCh!(newV) |
              returnCh!(result)
            }
          }
        }
      } |

      contract fst(@(first, _), resultCh) = {
        resultCh!(first)
      } |

      contract getUser (@deployerId, returnCh) = {
        new deployerIdOps(`rho:rchain:deployerId:ops`) in {
          deployerIdOps!("pubKeyBytes", deployerId, *returnCh)
        }
      } |

      contract getCurrentUserAddress(@deployerId, returnCh) = {
        new userCh in {
          getUser!(deployerId, *userCh) |
          for (@userPk <- userCh) {
            revAddressOps!("fromPublicKey", userPk, *returnCh)
          }
        }
      } |

      contract pickActiveValidators(@allBonds, @withdrawers, returnCh) = {
        new availableValidatorsCh, isAvailable, pksCh in {
          @ListOps!("filter", allBonds.toList(), *isAvailable, *availableValidatorsCh) |
          contract isAvailable(@(pk, _), resultCh) = { resultCh!(not withdrawers.contains(pk))} |

          for (@availableValidators <- availableValidatorsCh) {
            @ListOps!("map", availableValidators, *fst, *pksCh) |
            for (@pks <- pksCh) {
              // TODO: Randomly select 100 active validators once we have on-chain randomness
              returnCh!(pks.take($$numberOfActiveValidators$$))
            }
          }
        }
      }
    } |

    // Merge (sum) maps with integer values
    // MergeIntMaps({"a": 1, "b": 4}, {"a": 2, "c": 5, "d": Nil})
    //            = {"a": 3, "b": 4, "c": 5}
    contract MergeIntMaps(@map1, @map2, return) = {
      new mergeKey in {
        @ListOps!("fold", map2.toList(), map1, *mergeKey, *return) |
        contract mergeKey(@(key, v1), @acc, ret) = {
          match (v1, acc.get(key)) {
            (Int, v2 /\ Int) => ret!(acc.set(key, v1 + v2))
            (Int, _)         => ret!(acc.set(key, v1))
            (_, v2 /\ Int)   => ret!(acc.set(key, v2))
            _                => ret!(acc)
          }
        }
      }
    } |

    rs!("047b43d6548b72813b89ac1b9f9ca67624a8b372feedd71d4e2da036384a3e1236812227e524e6f237cde5f80dbb921cac12e6500791e9a9ed1254a745a816fe1f".hexToBytes(),
    (9223372036854775807, bundle+{*PoS}),
    "3044022054ff4bae3984252b116e41e28d98bb5533eaa39aec2729228159166e2784f641022066a0fd99e7ea33df812fab095cbe61250f9548bce6da3ec4c6a90c741b94087f".hexToBytes(),
    *uriOut)
  }
}
