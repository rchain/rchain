// Rholang macro parameters:
// minimumBond - the minimum bond allowed by the PoS
// maximumBond - the maximum bond allowed by PoS
// initialBonds - the initial bonds map
// epochLength - the length of the validation epoch in blocks
// quarantineLength - the length of the quarantine time in blocks
/*

Life circle in POS

POS internal state:
"allBonds"        : Map[Validator, bonds],
"activeValidators": Set[Validator],
"withdrawers"     : Map[Validator, (bonds, quantinue)],
"comittedRewards" : Map[Validator, rewards], 
"pendingWithdrawers": Map[Validator, quantinue]

**There are two vaults `posVault` and `coopMultiSigVault` while pos contract have no controll on `coopMultiSigVault` but `posVault`**

Several crucial calculate points:

## UserDeploy

* precharge -> user transfer the precharge funding to posVault
* refund -> posVault transfer the refund amount back to userVault

## Bonding

User transfer the bonding amount directly to posVault. `allBonds` would update with {Validator: bondAmount}.

## Withdraw(Unbond)

`pendingWithdrawers` would update with {Validator: quantinue}


## EpochChange(CloseBlock)

1. Calculate all the validator current epoch rewards based on active validator bonding proportion
2. Accumulate `comittedRewards` with the result of step 1
4. Update `withdrawers` according to `allBonds` and `pendingWithdrawers` when pendingWithdrawers is not empty, remove the validator in `allBonds`
5. When the block number reaches the quantinue of `withdrawers` , transfer the corresponding bonds+ rewards to the corresponding validator from posVault. 
6. update `pendingWithdrawers` to empty Map {}.
5. Pick new `activeValidators`


## Slashing
1. Transfer the bonding amount of the slashed validator based on `allBonds` from posVault to coopMultiSigVault.
2. Set the bonding amount in `allBonds` of the slashed validator to 0
3. remove the slashed validator in `activeValidators`

*/

/*
 The table below describes the required computations and their dependencies

 No. | Dependency | Computation method | Result
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 1.  |            | given              | sk = a9585a0687761139ab3587a4938fb5ab9fcba675c79fefba889859674046d4a5
 2.  |            | given              | timestamp = 1559156420651
 3.  |            | lastNonce          | nonce = 9223372036854775807
 4.  | 1,         | secp256k1          | pk = 047b43d6548b72813b89ac1b9f9ca67624a8b372feedd71d4e2da036384a3e1236812227e524e6f237cde5f80dbb921cac12e6500791e9a9ed1254a745a816fe1f
 5.  | 4, 2,      | genIds             | uname = Unforgeable(0xa32c1649f1700469f125ea85f9c2a220072e593ae617213782d738e389639d3b)
 6.  | 3, 5,      | registry           | value = (9223372036854775807, bundle+ {   Unforgeable(0xa32c1649f1700469f125ea85f9c2a220072e593ae617213782d738e389639d3b) })
 7.  | 6,         | protobuf           | toSign = 2a40aa013d0a0d2a0b10feffffffffffffffff010a2c5a2a0a263a240a220a20a32c1649f1700469f125ea85f9c2a220072e593ae617213782d738e389639d3b1001
 8.  | 7, 1,      | secp256k1          | sig = 3044022054ff4bae3984252b116e41e28d98bb5533eaa39aec2729228159166e2784f641022066a0fd99e7ea33df812fab095cbe61250f9548bce6da3ec4c6a90c741b94087f
 9.  | 4,         | registry           | uri = rho:id:m3xk7h8r54dtqtwsrnxqzhe81baswey66nzw6m533nyd45ptyoybqr
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
*/

new PoS,
    registryLookup(`rho:registry:lookup`),
    revAddressOps(`rho:rev:address`),
    revVaultCh, listOpsCh,
    getUser,
    pickActiveValidators,
    runMVar,
    fst,
    deposit, distributeRewards,
    perActiveValidatorPosVaultsCh,
    rs(`rho:registry:insertSigned:secp256k1`),
    posId(`rho:rchain:deployerId`),
    PendingRewards, MergeIntMaps, treeHashMapCh,
    sysAuthTokenOps(`sys:authToken:ops`),
    multiSigRevVaultCh, coopVaultCh,
    uriOut, sumFromPair, stdlog(`rho:io:stdout`)
in {
  // Simultaneously retrieves RevVault, ListOps, TreeHashMap, and MultiSigRevVault contracts from the registry.
  registryLookup!(`rho:rchain:revVault`, *revVaultCh) |
  registryLookup!(`rho:lang:listOps`, *listOpsCh) |
  registryLookup!(`rho:lang:treeHashMap`, *treeHashMapCh) |
  registryLookup!(`rho:rchain:multiSigRevVault`, *multiSigRevVaultCh) |
  for (@(_, RevVault)         <- revVaultCh;
       @(_, ListOps)          <- listOpsCh;
       TreeHashMap            <- treeHashMapCh;
       @(_, MultiSigRevVault) <- multiSigRevVaultCh) {
    new posDeployerRevAddressCh, posDeployerAuthKeyCh, posDeployerVaultCh, posVaultCh, 
        initialActiveCh, pendingRewardsMapCh, createUnfVault, moveInitialBondCh, posAuthKeyCh
    in {
      // Creates the auth key and Rev vault associated with the PoS contract.
      new posPkCh in {
        @RevVault!("deployerAuthKey", *posId, *posDeployerAuthKeyCh) |
        getUser!(*posId, *posPkCh) |
        for (@posPk <- posPkCh) {
          revAddressOps!("fromPublicKey", posPk, *posDeployerRevAddressCh) |
          // Creates Coop multisig vault for slashed funds.
          // Either (false, errorMsg) or (true, (multiSigVault, revAddress, revVault)) are returned on coopVaultCh.
          @MultiSigRevVault!(
            "create",
            [
              "04db91a53a2b72fcdcb201031772da86edad1e4979eb6742928d27731b1771e0bc40c9e9c9fa6554bdec041a87cee423d6f2e09e9dfb408b78e85a4aa611aad20c".hexToBytes(),
              "042a736b30fffcc7d5a58bb9416f7e46180818c82b15542d0a7819d1a437aa7f4b6940c50db73a67bfc5f5ec5b5fa555d24ef8339b03edaa09c096de4ded6eae14".hexToBytes(),
              "047f0f0f5bbe1d6d1a8dac4d88a3957851940f39a57cd89d55fe25b536ab67e6d76fd3f365c83e5bfe11fe7117e549b1ae3dd39bfc867d1c725a4177692c4e7754".hexToBytes()
            ],
            [],
            2,
            *coopVaultCh
          )
        }
      } |
      // create unforgeable name vault with the provided pub key
      // ret: the return channel of the create
      // pubKey: the pubkey which controll the unforgeable name
      contract createUnfVault(ret, @pubkey) = {
        new unf, unfAddrRet, createRetCh, pubKeyChainUnfVault, unfVaultHandle, stdout(`rho:io:stdout`) in {
          revAddressOps!("fromUnforgeable", *unf, *unfAddrRet) |
          for (@unfAddr <- unfAddrRet){
            @RevVault!("findOrCreate", unfAddr, *createRetCh) |
            for (@(true, vault) <- createRetCh){
              contract unfVaultHandle(@"transfer", @targetAddress, @amount, deployerID, transferRet) = {
                new deployerPubKeyBytesCh, DeployerIdOps(`rho:rchain:deployerId:ops`) in {
                  DeployerIdOps!("pubKeyBytes", *deployerID, *deployerPubKeyBytesCh) |
                  for (@deployerPubKeyBytes <- deployerPubKeyBytesCh) {
                    if (deployerPubKeyBytes ==  pubkey.hexToBytes()){
                      new unfAuthKeyCh in {
                        @RevVault!("unforgeableAuthKey", *unf, *unfAuthKeyCh) |
                        for (@unfAuthKey <- unfAuthKeyCh){
                          @vault!("transfer", targetAddress, amount, unfAuthKey, *transferRet)
                        }
                      }
                    } else {
                      transferRet!((false, "You have not permission to transfer."))
                    }
                  }
                }
              } |
              ret!((*unf, unfAddr, vault ,*unfVaultHandle))
            }
          }
        }
      }|
      createUnfVault!(*posVaultCh, "$$posPubKey$$") |
      for (@(posVaultUnf, posVaultAddr, posVault, humanControllHandle) <- posVaultCh){
      @RevVault!("unforgeableAuthKey", posVaultUnf, *posAuthKeyCh) |
      for (@posDeployerRevAddress <- posDeployerRevAddressCh;
           @posDeployerAuthKey    <- posDeployerAuthKeyCh;
           @posAuthKey <- posAuthKeyCh)  {
        for (@(true, (coopMultiVault, coopMultiVaultAddr, coopVaultHd)) <<- coopVaultCh) {
          // Creates PoS Rev vault with sum of initial bonds.
          new bondSumCh in {
            @ListOps!("fold", $$initialBonds$$.toList(), 0, *sumFromPair, *bondSumCh) |
            for (@bondSum <- bondSumCh) {
              @RevVault!("createWithBalance", posDeployerRevAddress, bondSum, *posDeployerVaultCh)|
              for (@(true, posDeployerVault)  <- posDeployerVaultCh) {
                // move all the fund from deployer addr to POS unforgeable vault
                @posDeployerVault!("transfer", posVaultAddr, bondSum, posDeployerAuthKey, *moveInitialBondCh)
              }
            }
          } |
          // Selects the initial active validators.
          pickActiveValidators!($$initialBonds$$.toList(), *initialActiveCh) |
          for (@initialActive     <- initialActiveCh; 
               @(true, _) <- moveInitialBondCh) {
            new stateCh, pendingRewardsInitializedCh, rewardsInfo, calTotalActiveBonds, calTotalBonds, calTotalWithdraw, calTotalCommittedRewards in {
              // Initializes PoS state structure.
              stdlog!(("initial active", initialActive))|
              stateCh!({
                // Map[PublicKey, Int] - each validator stake
                "allBonds"        : $$initialBonds$$,
                // Set[PublicKey]     - the active validators
                "activeValidators": initialActive,
                // Map[PublicKey, (Int, Int)] - the validators wishing to withdraw and the block number when their quarantine ends
                //                              This begins at the start of the next epoch + quarantineLength.
                //                              Value(Int, Int) represents (original bond, reward, quantinue length)
                "withdrawers"     : {},
                // Map[PublicKey, Int]
                "comittedRewards" : {}, 
                // Map[PublicKey, Int] - the validators wishing to withdraw and the block number when their quarantine ends 
                "pendingWithdrawers": {},
                "randomImages"    : {},
                "randomNumbers"   : {},
              }) |
              contract rewardsInfo(retCh) = {
                new posBalanceCh, totalActiveBondCh, totalBondCh, totalWithdrawCh, committedRewardsCh in {
                  @posVault!("balance", *posBalanceCh) |
                  calTotalBonds!(*totalBondCh) |
                  calTotalActiveBonds!(*totalActiveBondCh) |
                  calTotalWithdraw!(*totalWithdrawCh) |
                  calTotalCommittedRewards!(*committedRewardsCh) |
                  for (@posBalance <- posBalanceCh; @totalBond <- totalBondCh; @activeBonds <- totalActiveBondCh; 
                       @totalWithdraw <- totalWithdrawCh; @totalCommittedRewards <- committedRewardsCh){
                    for (@state <<- stateCh) {
                      retCh!((posBalance , totalBond , activeBonds, totalWithdraw, totalCommittedRewards, state.get("allBonds")))
                    }
                  }
                }
              } |
              contract calTotalActiveBonds(returnCh) = {
                new computeSum, computeDelta in {
                  for (@state <<- stateCh){
                    @ListOps!("fold", state.get("allBonds").toList(), 0, *computeSum, *returnCh) |
                    contract computeSum(@(pk, bondAmount), @acc, resultCh) = {
                      if (state.get("activeValidators").contains(pk)){
                        resultCh!(acc + bondAmount)
                      } else {
                        resultCh!(acc)
                      }
                    }
                  }
                }
              } |
              contract calTotalBonds(returnCh) = {
                new computeSum, computeDelta in {
                  for (@state <<- stateCh){
                    @ListOps!("fold", state.get("allBonds").toList(), 0, *computeSum, *returnCh) |
                    contract computeSum(@(pk, bondAmount), @acc, resultCh) = {
                      resultCh!(acc + bondAmount)
                    }
                  }
                }
              } |
              contract calTotalWithdraw(returnCh) = {
                new computeSum in {
                  for (@state <<- stateCh){
                    @ListOps!("fold", state.get("withdrawers").toList(), 0, *computeSum, *returnCh) |
                    contract computeSum(@(pk, (previousBonding, quantinue)), @acc, resultCh) = {
                      resultCh!(acc + previousBonding)
                    }
                  }
                }
              } |
              contract calTotalCommittedRewards(returnCh) = {
                new computeSum, computeDelta in {
                  for (@state <<- stateCh){
                    @ListOps!("fold", state.get("comittedRewards").toList(), 0, *computeSum, *returnCh) |
                    contract computeSum(@(pk, reward), @acc, resultCh) = {
                      resultCh!(acc + reward)
                    }
                  }
                }
              } |
              contract PoS(@"getCurrentEpochRewards", returnCh) = {
                new rewardCh, computeReward in {
                  rewardsInfo!(*rewardCh)|
                  for (@(posBalance, totalBond, activeBonds, totalWithdraw, totalCommittedRewards, bondsMap) <- rewardCh){
                    @ListOps!("fold", bondsMap.toList(), {}, *computeReward, *returnCh) |
                    contract computeReward(@(pk, bonds),@acc,  outCh) = {
                      //  someAmount / minimumBond to reduce the possibility on overflow long
                      outCh!(acc.set(pk, (posBalance - totalBond - totalWithdraw - totalCommittedRewards) * (bonds / $$minimumBond$$) / (activeBonds / $$minimumBond$$)))
                    }
                  }
                }
              } |
              contract PoS(@"getRewards", returnCh) = {
                new currentEpochRewardCh, accumulateReward in {
                  for (@state <<- stateCh) {
                    PoS!("getCurrentEpochRewards", *currentEpochRewardCh)| 
                    for (@currentEpochReward <- currentEpochRewardCh) {
                      @ListOps!("fold", currentEpochReward.toList(), state.get("comittedRewards"), *accumulateReward, *returnCh) |
                      contract accumulateReward(@(pk, reward), @acc, outCh) = {
                        outCh!(acc.set(pk, acc.getOrElse(pk, 0) + reward))
                      }
                    }
                  }
                }
              } |
              // Peeks at bonds map.
              contract PoS(@"getBonds", returnCh) = {
                for (@state <<- stateCh) {
                  returnCh!(state.get("allBonds"))
                }
              } |
              // Peeks at active validator list.
              contract PoS(@"getActiveValidators", returnCh) = {
                for (@state <<- stateCh) {
                  returnCh!(state.get("activeValidators"))
                }
              } |
              // Peeks at active validator list.
              contract PoS(@"getWithdrawers", returnCh) = {
                for (@state <<- stateCh) {
                  returnCh!(state.get("withdrawers"))
                }
              } |
              contract PoS(@"getPendingWithdrawer", returnCh) = {
                for (@state <<- stateCh) {
                  returnCh!(state.get("pendingWithdrawers"))
                }
              } |
              // Exposes Coop multisig vault on returnCh.
              contract PoS(@"getCoopVault", returnCh) = {
                for (@(_, coopVault) <<- coopVaultCh) {
                  returnCh!((coopMultiVault, coopMultiVaultAddr, coopVaultHd))
                }
              } |
              // Exposes initial PoS vault on returnCh.
              contract PoS(@"getInitialPosVault", returnCh) = {
                returnCh!((posVaultAddr, posVault))
              } |
              // Exposes epochLength parameter to PoSTest.
              contract PoS(@"getEpochLength", returnCh) = {
                returnCh!($$epochLength$$)
              } |
              // Exposes quarantineLength parameter to PoSTest.
              contract PoS(@"getQuarantineLength", returnCh) = {
                returnCh!($$quarantineLength$$)
              } |
              contract PoS(@"humanTransfer", @targetAddress, @amount, @deployerID, @transferRet) = {
                // human transfer would just use this method
                @humanControllHandle!("transfer", targetAddress, amount, deployerID, transferRet)
              } |
              // Public method allowing users to bond and become validators.
              contract PoS(@"bond", @deployerId, @amount, returnCh) = {
                new userCh, depositCh,
                    processCh
                in {
                  runMVar!(*stateCh, *processCh, *returnCh) |
                  getUser!(deployerId, *userCh) |
                  for (@state, resultCh <- processCh;
                       @userPk          <- userCh) {
                    if (state.get("allBonds").contains(userPk)) {
                      resultCh!(state, (false, "Public key is already bonded."))
                    } else if (amount < $$minimumBond$$) {
                      resultCh!(state, (false, "Bond is less than minimum!"))
                    } else if (amount > $$maximumBond$$) {
                      resultCh!(state, (false, "Bond is greater than maximum!"))
                    } else {
                      // Transfers user's bond amount to the PoS vault.
                      deposit!(deployerId, amount, posVaultAddr, *depositCh) |
                      for (@depositResult <- depositCh) {
                        match depositResult {
                          // If deposit is successful, the user becomes a bonded validator.
                          (true, _) => {
                            stdlog!(("after bonds", state.get("allBonds"), userPk, amount))|
                            resultCh!(state.set("allBonds", state.get("allBonds").set(userPk, amount)), depositResult)
                          }
                          // If deposit is unsuccessful, the user is not bonded.
                          (false, errorMsg) => {
                            resultCh!(state, (false, "Bond deposit failed: " ++ errorMsg))
                          }
                        }
                      }
                    }
                  }
                }
              } |
              // Public method allowing validators to withdraw their bonded and accumulated funds.
              contract PoS(@"withdraw", @deployerId, returnCh) = {
                new userCh, processCh, blockDataCh,
                    getBlockData(`rho:block:data`)
                in {
                  // Consumes state and updates withdrawers map.
                  runMVar!(*stateCh, *processCh, *returnCh) |
                  getBlockData!(*blockDataCh) |
                  getUser!(deployerId, *userCh) |
                  for (@state, resultCh   <- processCh;
                       @userPk            <- userCh;
                       @blockNumber, _, _ <- blockDataCh) {
                    if (state.get("allBonds").contains(userPk)) {
                      // The withdrawal goes into effect at the start of the next epoch.
                      resultCh!(
                        state.set("pendingWithdrawers",
                                  state.get("pendingWithdrawers")
                                       .set(userPk,
                                         $$quarantineLength$$ + $$epochLength$$ * (1 + blockNumber / $$epochLength$$))),
                        (true, Nil))
                    } else {
                      resultCh!(state, (false, "User is not bonded"))
                    }
                  }
                }
              } |
              // Private method which charges a deployer for a deploy.
              // Deployer's funds are deposited into the block sender's vault.
              // Return expects (Boolean, Either[Nil, String])
              new currentDeployerData in {
                contract PoS(@"chargeDeploy", @deployerId, @amount, @sysAuthToken, return) = {
                  new isValidTokenCh in {
                    sysAuthTokenOps!("check", sysAuthToken, *isValidTokenCh) |
                    for (@isValid <- isValidTokenCh) {
                      if (isValid) {
                        new depositCh in {
                          deposit!(deployerId, amount, posVaultAddr, *depositCh) |
                          for (@depositResult <- depositCh){
                            match depositResult {
                              (true, _) => {
                                currentDeployerData!((deployerId, amount)) |
                                return!(depositResult)
                              }
                              (_, errorMessage) => {
                                return!((false, "Deploy payment failed: " ++ errorMessage))
                              }
                            }
                          }
                        }
                      } else {
                        return!((false, "Invalid system auth token"))
                      }
                    }
                  }
                } |
                // Private method which refunds a deployer if too much was charged in chargeDeploy.
                // Funds are transferred from the block sender's vault to the deployer.
                // Return expects (Boolean, Either[Nil, String])
                contract PoS(@"refundDeploy", @refundAmount, @sysAuthToken, return) = {
                  new isValidTokenCh in {
                    sysAuthTokenOps!("check", sysAuthToken, *isValidTokenCh) |
                    for (@isValid <- isValidTokenCh) {
                      if (isValid) {
                        for (@(deployerId, initialPaymentAmount) <- currentDeployerData){
                          if (refundAmount > 0) {
                            new revAddressCh, transferCh in {
                              revAddressOps!("fromDeployerId", deployerId, *revAddressCh) |
                              for (@deployerRevAddress <- revAddressCh) {
                                // Transfer (from sender to deployer) called in refundDeploy.
                                @posVault!("transfer", deployerRevAddress, refundAmount, posAuthKey, *transferCh) |
                                for (@transferResult <- transferCh) {
                                  match transferResult {
                                    (true, _) => {
                                      return!((true, Nil))
                                    }
                                    (_, errorMessage) => {
                                      return!((false, "(Bug found) Deploy refund failed: " ++ errorMessage))
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            return!((true, Nil))
                          }
                        }
                      } else {
                        return!((false, "Invalid system auth token"))
                      }
                    }
                  }
                }
              } |
              new commitRewards, moveFunds in {
                // Private method which transfers all of a validator's rewards + bond to the Coop vault.
                // Slash expects (Boolean, Either[Nil, String]) on returnCh.
                contract PoS(@"slash", @deployerId, @blockHash, @sysAuthToken, returnCh) = {
                  new isValidTokenCh in {
                    sysAuthTokenOps!("check", sysAuthToken, *isValidTokenCh) |
                    for (@isValid <- isValidTokenCh) {
                      if (isValid) {
                        new invalidBlocksCh, stateProcessCh, userCh,
                            getInvalidBlocks(`rho:casper:invalidBlocks`)
                        in {
                          getInvalidBlocks!(*invalidBlocksCh) |
                          getUser!(deployerId, *userCh) |
                          runMVar!(*stateCh, *stateProcessCh, *returnCh) |
                          for (@invalidBlocks        <- invalidBlocksCh;
                               @userPk               <- userCh;
                               @state, stateUpdateCh <- stateProcessCh) {
                                new toBeSlashed, valBondCh, valRewardCh in {
                                  // Flow of logic:
                                  // 0. check if blockHash is the hash of an invalid block
                                  // 1. transfer stake of slashed validator from PoS to Coop vault
                                  // 2. update state
                                  // Retrieves either public key of sender of invalid block or the deployer public key.
                                  toBeSlashed!(invalidBlocks.getOrElse(blockHash, userPk)) |
                                  for (@validator <- toBeSlashed) {
                                    // Takes the stake of slashed validator
                                    valBondCh!(state.get("allBonds").get(validator)) |
                                    for (@valBond <- valBondCh) {
                                      // Transfers slashed funds from PoS vault to Coop vault, then updates state.
                                      new transferDoneCh in {
                                        @posVault!(
                                          "transfer",
                                          coopMultiVaultAddr,
                                          valBond,
                                          posAuthKey,
                                          *transferDoneCh
                                        ) |
                                        for (_ <- transferDoneCh) {
                                          // Sets slashed validator's committed rewards and bond to 0 in state.
                                          // Moves slashed validator to withdrawers map with no quarantine period.
                                          stateUpdateCh!({
                                            "allBonds"        : state.get("allBonds").set(validator, 0),
                                            "activeValidators": state.get("activeValidators").delete(validator),
                                            "withdrawers"     : state.get("withdrawers"),
                                            "randomImages"    : state.get("randomImages"),
                                            "randomNumbers"   : state.get("randomNumbers")
                                          },
                                          (true, Nil))
                                        }
                                      }
                                    }
                                  }
                                }
                          }
                        }
                      } else {
                        returnCh!((false, "Invalid system auth token"))
                      }
                    }
                  }
                } |
                // Private method which signals the end of block processing.
                contract PoS(@"closeBlock", @sysAuthToken, ackCh) = {
                  new isValidTokenCh in {
                    sysAuthTokenOps!("check", sysAuthToken, *isValidTokenCh) |
                    for (@isValid <- isValidTokenCh) {
                      if (isValid) {
                        new blockDataCh, getBlockData(`rho:block:data`) in {
                          getBlockData!(*blockDataCh) |
                          for (@blockNumber, _, _ <- blockDataCh) {
                            if (blockNumber % $$epochLength$$ != 0) {
                              // Epoch change does not occur.
                              ackCh!((true, Nil))
                            } else {
                              // Epoch change occurs.
                              new payWithdrawer, removeQuarantinedWithdrawers,
                                  stateProcessCh, paymentDoneCh,
                                  accDepositsDoneCh, commitRewardsCh,
                                  newValidatorsCh, removeQuarantinedCh, currentEpochRewardCh,
                                  accumulateRewards, updatedRewardsCh, movePendingWithdrawCh, movePendingWithdrawer
                              in {
                                PoS!("getCurrentEpochRewards", * currentEpochRewardCh) |
                                for (@currentRewards <- currentEpochRewardCh) {
                                  runMVar!(*stateCh, *stateProcessCh, *ackCh) |
                                  for (@state, stateUpdateCh <- stateProcessCh) {
                                    accumulateRewards!(state, currentRewards, *updatedRewardsCh) |
                                    for (@newCommittedState <- updatedRewardsCh) {
                                      stdlog!(("new commited state", newCommittedState)) |
                                      movePendingWithdrawer!(newCommittedState, *movePendingWithdrawCh) |
                                      for (@newMovedPendingState <- movePendingWithdrawCh){
                                        stdlog!(("new Moved PendingState", newMovedPendingState)) |
                                        removeQuarantinedWithdrawers!(blockNumber, newMovedPendingState, *removeQuarantinedCh) |
                                        for (@newRemovedQuantinueState <- removeQuarantinedCh) {
                                          stdlog!(("new Removed QuantinueState", newRemovedQuantinueState)) |
                                          pickActiveValidators!(newMovedPendingState.get("allBonds").toList(), *newValidatorsCh) |
                                          for (@newValidators <- newValidatorsCh) {
                                            stateUpdateCh!(newRemovedQuantinueState.set("activeValidators", newValidators), (true, Nil))
                                          }
                                        }
                                      }
                                    }
                                  }
                                } | 
                                // Transfers withdrawing validator's bond + accumulated rewards from PoS vault to their vault.
                                contract payWithdrawer(@(pk, amount), returnCh) = {
                                  new vaultCh, revAddressCh in {
                                    revAddressOps!("fromPublicKey", pk, *revAddressCh) |
                                    for (@toRevAddress <- revAddressCh) {
                                      @posVault!("transfer", toRevAddress, amount, posAuthKey, *returnCh)
                                    }
                                  }
                                } |
                                contract accumulateRewards(@state, @currentRewards, returnCh) = {
                                  new accumulate in {
                                    @ListOps!("fold", currentRewards.toList(), state, *accumulate, *returnCh) |
                                    contract accumulate(@(pk, reward), @updatedState, resultCh) = {
                                      stdlog!(("accumulate logs", updatedState, pk, reward))|
                                      resultCh!(updatedState.set("comittedRewards", 
                                                                  updatedState.get("comittedRewards").set(pk, updatedState.get("comittedRewards").getOrElse(pk, 0) + reward)))
                                    }
                                  }
                                } |
                                contract movePendingWithdrawer(@state, returnCh) = {
                                  new movePending in {
                                    @ListOps!("fold", state.get("pendingWithdrawers").toList(), state, *movePending, *returnCh) | 
                                    contract movePending(@(pk, quantine), @updatedState, resultCh) = {
                                      stdlog!(("move pending withdrawer", updatedState, pk, quantine))|
                                      resultCh!(updatedState
                                                .set("withdrawers", updatedState.get("withdrawers").set(pk, (updatedState.get("allBonds").get(pk), quantine)))
                                                .set("allBonds", updatedState.get("allBonds").delete(pk))
                                                .set("pendingWithdrawers", updatedState.get("pendingWithdrawers").delete(pk))
                                                )
                                    }
                                  }
                                } |
                                // Checks withdrawer's quarantine period against current block number,
                                // then computes their payment, removes them from the bonds and withdrawers maps, and
                                // updates the committed rewards map.
                                contract removeQuarantinedWithdrawers(@currentBlockNumber, @state, returnCh) = {
                                  new quarantinedValidatorsCh, validatorsToWithdrawListCh,
                                      isQuarantineFinished, notWithdrawn, computeRemove,
                                      newBondsListCh, newWithdrawersListCh,
                                      newRewardsListCh
                                  in {
                                    // Calculate rewards by taking PoS balance on PoS vault and subtract all active stake + newly bonded
                                    @ListOps!("filter", state.get("withdrawers").toList(), *isQuarantineFinished, *quarantinedValidatorsCh) |
                                    for (@quarantinedValidators <- quarantinedValidatorsCh) {
                                      stdlog!(("quantinued withdrawer", quarantinedValidators)) |
                                      @ListOps!("fold", quarantinedValidators, state, *computeRemove, *returnCh) |
                                      contract computeRemove(@(pk, (bonds, quantine)), @updatedState, resultCh) = {
                                        new payReturnCh in {
                                          stdlog!(("remove quantinue", updatedState, pk, bonds, quantine))|
                                          payWithdrawer!((pk, bonds + updatedState.get("comittedRewards").getOrElse(pk, 0)), *payReturnCh) | 
                                          for (@(true, _) <- payReturnCh) {
                                            resultCh!(updatedState
                                                      .set("comittedRewards", updatedState.get("comittedRewards").delete(pk))
                                                      .set("withdrawers", updatedState.get("withdrawers").delete(pk))
                                                      )
                                          }
                                        }
                                      }
                                    } |
                                    // Check whether quarantine period is finished.
                                    contract isQuarantineFinished(@(pk, (bonds, blockNumber)), resultCh) = {
                                      stdlog!(("isquantinue", pk, blockNumber, currentBlockNumber )) |
                                      resultCh!(currentBlockNumber >= blockNumber)
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        ackCh!((false, "Invalid system auth token"))
                      }
                    }
                  }
                } |
                // Moves the entire contents of a validator's vault to the PoS vault.
                contract moveFunds(@(unf, revAddr, vault), returnCh) = {
                  new balanceCh, unfAuthKeyCh, transferDoneCh in {
                    @vault!("balance", *balanceCh) |
                    for (@balance <- balanceCh) {
                      if (balance > 0) {
                        @RevVault!("unforgeableAuthKey", unf, *unfAuthKeyCh) |
                        for (@authKey <- unfAuthKeyCh) {
                          // Transfer funds from validator vault to the PoS vault.
                          @vault!("transfer", posVaultAddr, balance, authKey, *transferDoneCh) |
                          for (@(true, _) <- transferDoneCh) {
                            returnCh!(true)
                          }
                        }
                      } else {
                        returnCh!(true)
                      }
                    }
                  }
                } 
              } |
              //
              contract PoS(@"commitRandomImage", @deployerId, @hash, ackCh) = {
                new userCh, mvarCh in {
                  getUser!(deployerId, *userCh) |
                  runMVar!(*stateCh, *mvarCh, *ackCh) |
                  for (@validator       <- userCh;
                       @state, resultCh <- mvarCh) {
                    if (state.get("randomImages").contains(validator)) {
                      resultCh!(state, (false, "Image already committed"))
                    } else {
                      resultCh!(
                        state.set("randomImages", state.get("randomImages").set(validator, hash)), true)
                    }
                  }
                }
              } |
              //
              contract PoS(@"revealRandom", @deployerId, @random, ackCh) = {
                new userCh, mvarCh, computeHash(`rho:crypto:keccak256Hash`), hashCh in {
                  getUser!(deployerId, *userCh) |
                  runMVar!(*stateCh, *mvarCh, *ackCh) |
                  computeHash!(random, *hashCh) |
                  for (@validator       <- userCh;
                       @state, resultCh <- mvarCh;
                       @hash            <- hashCh) {
                    if (state.get("randomImages").contains(validator)) {
                      if (hash == state.get("randomImages").get(validator)) {
                        resultCh!(
                          state.set("randomNumbers",state.get("randomNumbers").set(validator, random)), true)
                      } else {
                        resultCh!(state, (false, "Previously committed image doesn't match the random number"))
                      }
                    } else {
                      resultCh!(state, (false, "Previously committed random image not found"))
                    }
                  }
                }
              }
            }
          }
        } |
        // Transfers funds from deployer to block sender.
        contract deposit(@deployerId, @amount, @toTargetAddress, returnCh) = {
          new vaultCh, revAddressCh,
              indexSender, authKeyCh
          in {
            @RevVault!("deployerAuthKey", deployerId, *authKeyCh) |
            revAddressOps!("fromDeployerId", deployerId, *revAddressCh) |
            for (@authKey        <- authKeyCh;
                 @fromRevAddress <- revAddressCh) {
              @RevVault!("findOrCreate", fromRevAddress, *vaultCh) |
              for (@(true, fromVault) <- vaultCh) {
                // Transfers from deployer to PoS vault
                @fromVault!("transfer", toTargetAddress, amount, authKey, *returnCh)
              }
            }
          }
        }
      } |
      // Updates value stored on varCh and sends (Bool) acknowledgement on returnCh.
      contract runMVar(varCh, processCh, returnCh) = {
        new resultCh in {
          for (@v <- varCh) {
            processCh!(v, *resultCh) |
            for (@newV, @result <- resultCh) {
              varCh!(newV) |
              returnCh!(result)
            }
          }
        }
      } |
      // Discards second element of a pair.
      contract fst(@(first, _), resultCh) = {
        resultCh!(first)
      } |
      // For computing some of initial validator bonds.
      contract sumFromPair(@(_, a), @b, resultCh) = {
        resultCh!(a + b)
      } |
      // Retrieves deployer's public key.
      contract getUser(@deployerId, returnCh) = {
        new deployerIdOps(`rho:rchain:deployerId:ops`) in {
          deployerIdOps!("pubKeyBytes", deployerId, *returnCh)
        }
      } |
      // Selects set of active validators from the set of available validators.
      contract pickActiveValidators(@allBonds, returnCh) = {
        new availableValidatorsCh,
            isAvailable, pksCh
        in {
          stdlog!(("pick", allBonds)) |
          @ListOps!("map", allBonds, *fst, *pksCh) |
          for (@pks <- pksCh) {
            // TODO: Randomly select 100 active validators once we have on-chain randomness
            returnCh!(pks.take($$numberOfActiveValidators$$).toSet())
          }
        }
      }
    } 
    }|
    // Registers signed write-only PoS contract bundle.
    rs!(
      "047b43d6548b72813b89ac1b9f9ca67624a8b372feedd71d4e2da036384a3e1236812227e524e6f237cde5f80dbb921cac12e6500791e9a9ed1254a745a816fe1f".hexToBytes(),
      (9223372036854775807, bundle+{*PoS}),
      "3044022054ff4bae3984252b116e41e28d98bb5533eaa39aec2729228159166e2784f641022066a0fd99e7ea33df812fab095cbe61250f9548bce6da3ec4c6a90c741b94087f".hexToBytes(),
      *uriOut)
  }
}
