// Rholang macro parameters:
// minimumBond - the minimum bond allowed by the PoS
// maximumBond - the maximum bond allowed by PoS
// initialBonds - the initial bonds map
// epochLength - the length of the validation epoch in blocks
// quarantineLength - the length of the quarantine time in blocks

/*
 The table below describes the required computations and their dependencies

 No. | Dependency | Computation method | Result
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 1.  |            | given              | sk = a9585a0687761139ab3587a4938fb5ab9fcba675c79fefba889859674046d4a5
 2.  |            | given              | timestamp = 1559156420651
 3.  |            | lastNonce          | nonce = 9223372036854775807
 4.  | 1,         | secp256k1          | pk = 047b43d6548b72813b89ac1b9f9ca67624a8b372feedd71d4e2da036384a3e1236812227e524e6f237cde5f80dbb921cac12e6500791e9a9ed1254a745a816fe1f
 5.  | 4, 2,      | genIds             | uname = Unforgeable(0xa32c1649f1700469f125ea85f9c2a220072e593ae617213782d738e389639d3b)
 6.  | 3, 5,      | registry           | value = (9223372036854775807, bundle+ {   Unforgeable(0xa32c1649f1700469f125ea85f9c2a220072e593ae617213782d738e389639d3b) })
 7.  | 6,         | protobuf           | toSign = 2a40aa013d0a0d2a0b10feffffffffffffffff010a2c5a2a0a263a240a220a20a32c1649f1700469f125ea85f9c2a220072e593ae617213782d738e389639d3b1001
 8.  | 7, 1,      | secp256k1          | sig = 3044022054ff4bae3984252b116e41e28d98bb5533eaa39aec2729228159166e2784f641022066a0fd99e7ea33df812fab095cbe61250f9548bce6da3ec4c6a90c741b94087f
 9.  | 4,         | registry           | uri = rho:id:m3xk7h8r54dtqtwsrnxqzhe81baswey66nzw6m533nyd45ptyoybqr
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
*/

new PoS,
    registryLookup(`rho:registry:lookup`),
    revAddressOps(`rho:rev:address`),
    revVaultCh, listOpsCh,
    getUser,
    pickActiveValidators,
    runMVar,
    fst,
    deposit, distributeRewards,
    perActiveValidatorPosVaultsCh,
    transferFromBlockSender,
    rs(`rho:registry:insertSigned:secp256k1`),
    posId(`rho:rchain:deployerId`),
    PendingRewards, MergeIntMaps, treeHashMapCh,
    sysAuthTokenOps(`sys:authToken:ops`),
    multiSigRevVaultCh, coopVaultCh,
    uriOut, sumFromPair
in {
  // Simultaneously retrieves RevVault, ListOps, TreeHashMap, and MultiSigRevVault contracts from the registry.
  registryLookup!(`rho:rchain:revVault`, *revVaultCh) |
  registryLookup!(`rho:lang:listOps`, *listOpsCh) |
  registryLookup!(`rho:lang:treeHashMap`, *treeHashMapCh) |
  registryLookup!(`rho:rchain:multiSigRevVault`, *multiSigRevVaultCh) |
  for (@(_, RevVault)         <- revVaultCh &
       @(_, ListOps)          <- listOpsCh &
       TreeHashMap            <- treeHashMapCh &
       @(_, MultiSigRevVault) <- multiSigRevVaultCh) {
    new posRevAddressCh, posAuthKeyCh, posVaultCh,
        initialActiveCh, pendingRewardsMapCh
    in {
      // Creates a Rev vault for each active validator, in parallel.
      new rangeCh, makeVault in {
        contract makeVault(_, returnCh) = {
          new unf, revAddressCh, vaultCh in {
            revAddressOps!("fromUnforgeable", *unf, *revAddressCh) |
            for (@revAddress <- revAddressCh) {
              @RevVault!("findOrCreate", revAddress, *vaultCh) |
              for (@(true, vault) <- vaultCh) {
                returnCh!((*unf, revAddress, vault))
              }
            }
          }
        } |
        @ListOps!("range", 0, $$numberOfActiveValidators$$, *rangeCh) |
        for (@range <- rangeCh) {
          @ListOps!("parMap", range, *makeVault, *perActiveValidatorPosVaultsCh)
        }
      } |
      // Creates the auth key and Rev vault associated with the PoS contract.
      new posPkCh in {
        @RevVault!("deployerAuthKey", *posId, *posAuthKeyCh) |
        getUser!(*posId, *posPkCh) |
        for (@posPk <- posPkCh) {
          revAddressOps!("fromPublicKey", posPk, *posRevAddressCh) |
          // Creates Coop multisig vault for slashed funds.
          // Either (false, errorMsg) or (true, (multiSigVault, revAddress, revVault)) are returned on coopVaultCh.
          @MultiSigRevVault!(
            "create",
            [
              "04db91a53a2b72fcdcb201031772da86edad1e4979eb6742928d27731b1771e0bc40c9e9c9fa6554bdec041a87cee423d6f2e09e9dfb408b78e85a4aa611aad20c".hexToBytes(),
              "042a736b30fffcc7d5a58bb9416f7e46180818c82b15542d0a7819d1a437aa7f4b6940c50db73a67bfc5f5ec5b5fa555d24ef8339b03edaa09c096de4ded6eae14".hexToBytes(),
              "047f0f0f5bbe1d6d1a8dac4d88a3957851940f39a57cd89d55fe25b536ab67e6d76fd3f365c83e5bfe11fe7117e549b1ae3dd39bfc867d1c725a4177692c4e7754".hexToBytes()
            ],
            [],
            2,
            *coopVaultCh
          )
        }
      } |
      for (@posRevAddress <- posRevAddressCh &
           @posAuthKey    <- posAuthKeyCh) {
        for (@(true, coopVault) <<- coopVaultCh) {
          // Creates PoS Rev vault with sum of initial bonds.
          new bondSumCh in {
            @ListOps!("fold", $$initialBonds$$.toList(), 0, *sumFromPair, *bondSumCh) |
            for (@bondSum <- bondSumCh) {
              @RevVault!("createWithBalance", posRevAddress, bondSum, *posVaultCh)
            }
          } |
          // Selects the initial active validators.
          pickActiveValidators!($$initialBonds$$, {}, *initialActiveCh) |
          // Initializes pending rewards TreeHashMap.
          // - each key in pending rewards state is Map[PublicKey, Int] accumulated by calling "refundDeploy".
          TreeHashMap!("init", 4, *pendingRewardsMapCh) |
          for (@(true, posVault)  <- posVaultCh &
               @initialActive     <- initialActiveCh &
               @pendingRewardsMap <- pendingRewardsMapCh) {
            new stateCh, pendingRewardsInitializedCh in {
              // Initializes empty pending rewards state for each validator.
              // - states must be initialized to prevent conflicts during "set" (only lookup can be conflict free)
              PendingRewards!("init", initialActive, *pendingRewardsInitializedCh) |
              for (_ <- pendingRewardsInitializedCh) {
                // Initializes PoS state structure.
                stateCh!({
                  // Map[PublicKey, Int] - each validator stake
                  "allBonds"        : $$initialBonds$$,
                  // List[PublicKey]     - the active validators
                  "activeValidators": initialActive,
                  // Map[PublicKey, Int] - are moved from pendingRewards on epoch change or slashing
                  "committedRewards": {},
                  // Map[PublicKey, Int] - the validators wishing to withdraw and the block number when their quarantine ends
                  //                       This begins at the start of the next epoch + quarantineLength.
                  "withdrawers"     : {},
                  "randomImages"    : {},
                  "randomNumbers"   : {},
                })
              } |
              // Peeks at bonds map.
              contract PoS(@"getBonds", returnCh) = {
                for (@state <<- stateCh) {
                  returnCh!(state.get("allBonds"))
                }
              } |
              // Peeks at active validator list.
              contract PoS(@"getActiveValidators", returnCh) = {
                for (@state <<- stateCh) {
                  returnCh!(state.get("activeValidators"))
                }
              } |
              // Peeks at active validator list.
              contract PoS(@"getWithdrawers", returnCh) = {
                for (@state <<- stateCh) {
                  returnCh!(state.get("withdrawers"))
                }
              } |
              // Peeks at active validator vaults.
              contract PoS(@"getActiveValidatorVaults", returnCh) = {
                for (@vaults <<- perActiveValidatorPosVaultsCh) {
                  returnCh!(vaults)
                }
              } |
              // Peeks at the accumulated rewards map, i.e. "committed rewards".
              // The returned map contains only the rewards committed up to the last closeBlock.
              contract PoS(@"getRewards", returnCh) = {
                for (@state <<- stateCh) {
                  returnCh!(state.get("committedRewards"))
                }
              } |
              // Exposes Coop multisig vault on returnCh.
              contract PoS(@"getCoopVault", returnCh) = {
                for (@(_, coopVault) <<- coopVaultCh) {
                  returnCh!(coopVault)
                }
              } |
              // Exposes initial PoS vault on returnCh.
              contract PoS(@"getInitialPosVault", returnCh) = {
                returnCh!(posVault)
              } |
              // Exposes epochLength parameter to PoSTest.
              contract PoS(@"getEpochLength", returnCh) = {
                returnCh!($$epochLength$$)
              } |
              // Exposes quarantineLength parameter to PoSTest.
              contract PoS(@"getQuarantineLength", returnCh) = {
                returnCh!($$quarantineLength$$)
              } |
              // Public method allowing users to bond and become validators.
              contract PoS(@"bond", @deployerId, @amount, returnCh) = {
                new userCh, depositCh,
                    processCh
                in {
                  runMVar!(*stateCh, *processCh, *returnCh) |
                  getUser!(deployerId, *userCh) |
                  for (@state, resultCh <- processCh &
                       @userPk          <- userCh) {
                    if (state.get("allBonds").contains(userPk)) {
                      resultCh!(state, (false, "Public key is already bonded."))
                    } else if (amount < $$minimumBond$$) {
                      resultCh!(state, (false, "Bond is less than minimum!"))
                    } else if (amount > $$maximumBond$$) {
                      resultCh!(state, (false, "Bond is greater than maximum!"))
                    } else {
                      // Transfers user's bond amount to the block sender's per validator vault.
                      deposit!(deployerId, amount, state.get("activeValidators"), *depositCh) |
                      for (@depositResult <- depositCh) {
                        match depositResult {
                          // If deposit is successful, the user becomes a bonded validator.
                          (true, _) => {
                            resultCh!(state.set("allBonds", state.get("allBonds").set(userPk, amount)), depositResult)
                          }
                          // If deposit is unsuccessful, the user is not bonded.
                          (false, errorMsg) => {
                            resultCh!(state, (false, "Bond deposit failed: " ++ errorMsg))
                          }
                        }
                      }
                    }
                  }
                }
              } |
              // Public method allowing validators to withdraw their bonded and accumulated funds.
              contract PoS(@"withdraw", @deployerId, returnCh) = {
                new userCh, processCh, blockDataCh,
                    getBlockData(`rho:block:data`)
                in {
                  // Consumes state and updates withdrawers map.
                  runMVar!(*stateCh, *processCh, *returnCh) |
                  getBlockData!(*blockDataCh) |
                  getUser!(deployerId, *userCh) |
                  for (@state, resultCh   <- processCh &
                       @userPk            <- userCh &
                       @blockNumber, _, _ <- blockDataCh) {
                    if (state.get("allBonds").contains(userPk)) {
                      // The withdrawal goes into effect at the start of the next epoch.
                      resultCh!(
                        state.set("withdrawers",
                                  state.get("withdrawers")
                                       .set(userPk,
                                         $$quarantineLength$$ + $$epochLength$$ * (1 + blockNumber / $$epochLength$$))),
                        (true, Nil))
                    } else {
                      resultCh!(state, (false, "User is not bonded"))
                    }
                  }
                }
              } |
              // Private method which charges a deployer for a deploy.
              // Deployer's funds are deposited into the block sender's vault.
              // Return expects (Boolean, Either[Nil, String])
              new currentDeployerData in {
                contract PoS(@"chargeDeploy", @deployerId, @amount, @sysAuthToken, return) = {
                  new isValidTokenCh in {
                    sysAuthTokenOps!("check", sysAuthToken, *isValidTokenCh) |
                    for (@isValid <- isValidTokenCh) {
                      if (isValid) {
                        new depositCh in {
                          for (@state <<- stateCh) {
                            deposit!(deployerId, amount, state.get("activeValidators"), *depositCh) |
                            for (@depositResult <- depositCh){
                              match depositResult {
                                (true, _) => {
                                  currentDeployerData!((deployerId, amount)) |
                                  return!(depositResult)
                                }
                                (_, errorMessage) => {
                                  return!((false, "Deploy payment failed: " ++ errorMessage))
                                }
                              }
                            }
                          }
                        }
                      } else {
                        return!((false, "Invalid system auth token"))
                      }
                    }
                  }
                } |
                // Private method which refunds a deployer if too much was charged in chargeDeploy.
                // Funds are transferred from the block sender's vault to the deployer.
                // Return expects (Boolean, Either[Nil, String])
                contract PoS(@"refundDeploy", @refundAmount, @sysAuthToken, return) = {
                  new isValidTokenCh in {
                    sysAuthTokenOps!("check", sysAuthToken, *isValidTokenCh) |
                    for (@isValid <- isValidTokenCh) {
                      if (isValid) {
                        for (@(deployerId, initialPaymentAmount) <- currentDeployerData){
                          new revAddressCh in {
                            revAddressOps!("fromDeployerId", deployerId, *revAddressCh) |
                            for (@deployerRevAddress <- revAddressCh){
                              new transferCh, blockDataCh,
                                  getBlockData(`rho:block:data`)
                              in {
                                getBlockData!(*blockDataCh) |
                                for (_, _, @sender <- blockDataCh) {
                                  for (@state <<- stateCh) {
                                    transferFromBlockSender!(deployerRevAddress, state.get("activeValidators"), sender, refundAmount, *transferCh) |
                                    for (@transferResult <- transferCh){
                                      match transferResult {
                                        (true, _) => {
                                          new newRewardsCh, pendingUpdatedCh in {
                                            distributeRewards!(
                                              initialPaymentAmount - refundAmount,
                                              state.get("activeValidators"),
                                              state.get("allBonds"),
                                              *newRewardsCh
                                            ) |
                                            for (@newRewards <- newRewardsCh) {
                                              // Add new pending rewards to validator pending rewards state
                                              PendingRewards!("append", sender, newRewards, *pendingUpdatedCh) |
                                              for (_ <- pendingUpdatedCh) {
                                                return!((true, Nil))
                                              }
                                            }
                                          }
                                        }
                                        (_, errorMessage) => {
                                          return!((false, "(Bug found) Deploy refund failed: " ++ errorMessage))
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        return!((false, "Invalid system auth token"))
                      }
                    }
                  }
                } |
                // Transfer (from sender to deployer) called in refundDeploy.
                contract transferFromBlockSender(@deployerRevAddress, @activeValidators, @sender, @refundAmount, returnCh) = {
                  new indexSender, unfAuthKeyCh, tmpCh in {
                    @ListOps!("indexOf", activeValidators, sender, *indexSender) |
                    for (@idx <- indexSender) {
                      if (idx == -1) {
                        returnCh!((false, "Sender is not an active validator"))
                      } else {
                        for (@vaults <<- perActiveValidatorPosVaultsCh) {
                          match vaults.nth(idx) {
                            (unf, _, activeValidatorVault) => {
                              @RevVault!("unforgeableAuthKey", unf, *unfAuthKeyCh) |
                              for (@authKey <- unfAuthKeyCh) {
                                @activeValidatorVault!("transfer", deployerRevAddress, refundAmount, authKey, *returnCh)
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } |
              new accumulateDeposits, commitRewards, moveFunds in {
                // Private method which transfers all of a validator's rewards + bond to the Coop vault.
                // Slash expects (Boolean, Either[Nil, String]) on returnCh.
                contract PoS(@"slash", @deployerId, @blockHash, @sysAuthToken, returnCh) = {
                  new isValidTokenCh in {
                    sysAuthTokenOps!("check", sysAuthToken, *isValidTokenCh) |
                    for (@isValid <- isValidTokenCh) {
                      if (isValid) {
                        new invalidBlocksCh, stateProcessCh, userCh,
                            getInvalidBlocks(`rho:casper:invalidBlocks`)
                        in {
                          getInvalidBlocks!(*invalidBlocksCh) |
                          getUser!(deployerId, *userCh) |
                          runMVar!(*stateCh, *stateProcessCh, *returnCh) |
                          for (@invalidBlocks        <- invalidBlocksCh &
                               @userPk               <- userCh &
                               @state, stateUpdateCh <- stateProcessCh) {
                            match coopVault {
                              (_, coopRevAddress, _) => {
                                new toBeSlashed, valBondCh, valRewardCh in {
                                  // Flow of logic:
                                  // 0. check if blockHash is the hash of an invalid block
                                  // 1. accumulateDeposits
                                  // 2. commitRewards
                                  // 3. transfer slashed funds to Coop
                                  // 4. update state
                                  // Retrieves either public key of sender of invalid block or the deployer public key.
                                  toBeSlashed!(invalidBlocks.getOrElse(blockHash, userPk)) |
                                  for (@validator <- toBeSlashed) {
                                    new commitRewardsCh, accDepositsDoneCh in {
                                      // Slashed funds:
                                      // + valPendingRewards
                                      // + state.get("committedRewards").get(validator)
                                      // + state.get("allBonds").get(validator)
                                      // Collects all deposits from per validator vaults.
                                      accumulateDeposits!(*accDepositsDoneCh) |
                                      for (_ <- accDepositsDoneCh) {
                                        new pendingRewardsAllCh in {
                                          // Collects pending rewards from each validator and resets to zero.
                                          PendingRewards!("collect", state.get("activeValidators"), *pendingRewardsAllCh) |
                                          for (@pendingRewards <- pendingRewardsAllCh) {
                                            new ackInitCh in {
                                              // Initialize empty pending rewards state with current set of validators.
                                              PendingRewards!("init", state.get("activeValidators"), *ackInitCh) |
                                              for (_ <- ackInitCh) {
                                                // Add all pending rewards to global committed rewards.
                                                commitRewards!(pendingRewards, state.get("committedRewards"), *commitRewardsCh)
                                              }
                                            }
                                          }
                                        } |
                                        for (@committedRewardsList <- commitRewardsCh) {
                                          // Collects slashed validator's committed rewards and bond.
                                          valRewardCh!(committedRewardsList.toMap().getOrElse(validator, 0)) |
                                          valBondCh!(state.get("allBonds").get(validator)) |
                                          for (@valReward <- valRewardCh &
                                               @valBond   <- valBondCh) {
                                            // Transfers slashed funds from PoS vault to Coop vault, then updates state.
                                            new transferDoneCh in {
                                              @posVault!(
                                                "transfer",
                                                coopRevAddress,
                                                valReward + valBond,
                                                posAuthKey,
                                                *transferDoneCh
                                              ) |
                                              for (_ <- transferDoneCh) {
                                                // Moves slashed validator to withdrawers map to unbond at next epoch change.
                                                new blockDataCh,
                                                    getBlockData(`rho:block:data`)
                                                in {
                                                  getBlockData!(*blockDataCh) |
                                                  for (@blockNumber, _, _ <- blockDataCh) {
                                                    // Sets slashed validator's committed rewards and bond to 0 in state.
                                                    // Moves slashed validator to withdrawers map with no quarantine period.
                                                    stateUpdateCh!({
                                                      "allBonds"        : state.get("allBonds").set(validator, 0),
                                                      "committedRewards": committedRewardsList.toMap().set(validator, 0),
                                                      "activeValidators": state.get("activeValidators"),
                                                      "withdrawers"     : state.get("withdrawers")
                                                                                .set(validator,
                                                                                  $$quarantineLength$$ + $$epochLength$$ * (1 + blockNumber / $$epochLength$$)),
                                                      "randomImages"    : state.get("randomImages"),
                                                      "randomNumbers"   : state.get("randomNumbers")
                                                    },
                                                    (true, Nil))
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        returnCh!((false, "Invalid system auth token"))
                      }
                    }
                  }
                } |
                // Private method which signals the end of block processing.
                contract PoS(@"closeBlock", @sysAuthToken, ackCh) = {
                  new isValidTokenCh in {
                    sysAuthTokenOps!("check", sysAuthToken, *isValidTokenCh) |
                    for (@isValid <- isValidTokenCh) {
                      if (isValid) {
                        new blockDataCh, getBlockData(`rho:block:data`) in {
                          getBlockData!(*blockDataCh) |
                          for (@blockNumber, _, _ <- blockDataCh) {
                            if (blockNumber % $$epochLength$$ != 0) {
                              // Epoch change does not occur.
                              ackCh!((true, Nil))
                            } else {
                              // Epoch change occurs.
                              new payWithdrawers, removeQuarantinedWithdrawers,
                                  stateProcessCh, paymentDoneCh,
                                  accDepositsDoneCh, commitRewardsCh,
                                  newValidatorsCh, removeQuarantinedCh
                              in {
                                runMVar!(*stateCh, *stateProcessCh, *ackCh) |
                                for (@state, stateUpdateCh <- stateProcessCh) {
                                  // Before choosing new active validators and paying out any withdrawers (i.e. updating the state),
                                  // per validator vaults are accumulated into the PoS vault.
                                  accumulateDeposits!(*accDepositsDoneCh) |
                                  // New active validators will be choosen from set of bonded validators who have not withdrawn.
                                  pickActiveValidators!(state.get("allBonds"), state.get("withdrawers"), *newValidatorsCh) |
                                  new pendingRewardsAllCh in {
                                    // Collects pending rewards from all validators and resets to zero.
                                    PendingRewards!("collect", state.get("activeValidators"), *pendingRewardsAllCh) |
                                    for (@pendingRewards <- pendingRewardsAllCh) {
                                      for (@newValidatorKeys <<- newValidatorsCh) {
                                        new ackInitCh in {
                                          // Initialize empty pending rewards state with new set of validators.
                                          PendingRewards!("init", newValidatorKeys, *ackInitCh) |
                                          for (_ <- ackInitCh) {
                                            // Add all pending rewards to global committed rewards.
                                            commitRewards!(pendingRewards, state.get("committedRewards"), *commitRewardsCh)
                                          }
                                        }
                                      }
                                    }
                                  } |
                                  // After pending rewards are committed, quarantined withdrawers are removed
                                  // from the bonds and withdrawers maps.
                                  for (@committedRewards <- commitRewardsCh) {
                                    removeQuarantinedWithdrawers!(
                                      blockNumber,
                                      state.get("allBonds"),
                                      state.get("withdrawers"),
                                      committedRewards,
                                      *removeQuarantinedCh)
                                  } |
                                  // After new active validators are selected, deposits are accumulated, and
                                  // quarantined withdrawers are removed from the bonds map,
                                  // these withdrawing validators are paid out, then the state is updated.
                                  for (@newValidators                                    <- newValidatorsCh &
                                       @(payments, newBonds, newWithdrawers, newRewards) <- removeQuarantinedCh &
                                       _                                                 <- accDepositsDoneCh) {
                                    payWithdrawers!(payments, *paymentDoneCh) |
                                    for (_ <- paymentDoneCh) {
                                      stateUpdateCh!({
                                        "allBonds"        : newBonds,
                                        "activeValidators": newValidators,
                                        "committedRewards": newRewards,
                                        "withdrawers"     : newWithdrawers,
                                        "randomImages"    : {},
                                        "randomNumbers"   : {},
                                      },
                                      (true, Nil))
                                    }
                                  }
                                } |
                                // Transfers withdrawing validator's bond + accumulated (committed) rewards from PoS vault to their vault.
                                new payWithdrawer in {
                                  contract payWithdrawer(@(pk, amount), returnCh) = {
                                    new vaultCh, revAddressCh in {
                                      revAddressOps!("fromPublicKey", pk, *revAddressCh) |
                                      for (@toRevAddress <- revAddressCh) {
                                        @posVault!("transfer", toRevAddress, amount, posAuthKey, *returnCh)
                                      }
                                    }
                                  } |
                                  contract payWithdrawers(@payments, returnCh) = {
                                    @ListOps!("unorderedParMap", payments, *payWithdrawer, *returnCh)
                                  }
                                } |
                                // Checks withdrawer's quarantine period against current block number,
                                // then computes their payment, removes them from the bonds and withdrawers maps, and
                                // updates the committed rewards map.
                                contract removeQuarantinedWithdrawers(@currentBlockNumber, @allBonds, @withdrawers, @rewards, returnCh) = {
                                  new quarantinedValidatorsCh, validatorsToWithdrawListCh,
                                      isQuarantineFinished, notWithdrawn,
                                      paymentsCh, computePay,
                                      newBondsListCh, newWithdrawersListCh,
                                      newRewardsListCh
                                  in {
                                    @ListOps!("filter", withdrawers.toList(), *isQuarantineFinished, *quarantinedValidatorsCh) |
                                    for (@quarantinedValidators <- quarantinedValidatorsCh) {
                                      @ListOps!("map", quarantinedValidators, *fst, *validatorsToWithdrawListCh) |
                                      for (@validatorsToWithdrawList <- validatorsToWithdrawListCh) {
                                        @ListOps!("map", validatorsToWithdrawList, *computePay, *paymentsCh) |
                                        contract computePay(@pk, resultCh) = {
                                          resultCh!((pk, allBonds.get(pk) + rewards.getOrElse(pk, 0)))
                                        } |
                                        match validatorsToWithdrawList.toSet() {
                                          validatorsToWithdrawSet => {
                                            @ListOps!("filter", allBonds.toList(), *notWithdrawn, *newBondsListCh) |
                                            @ListOps!("filter", withdrawers.toList(), *notWithdrawn, *newWithdrawersListCh) |
                                            @ListOps!("filter", rewards.toList(), *notWithdrawn, *newRewardsListCh) |
                                            for (@newWithdrawersList <- newWithdrawersListCh &
                                                 @newBondsList       <- newBondsListCh &
                                                 @newRewardsList     <- newRewardsListCh &
                                                 @payments           <- paymentsCh) {
                                              returnCh!((
                                                payments,
                                                newBondsList.toMap(),
                                                newWithdrawersList.toMap(),
                                                newRewardsList.toMap()
                                              ))
                                            } |
                                            // Checks that the validator is not a withdrawer.
                                            contract notWithdrawn(@(pk, _), resultCh) = {
                                              resultCh!(not validatorsToWithdrawSet.contains(pk))
                                            }
                                          }
                                        }
                                      }
                                    } |
                                    // Check whether quarantine period is finished.
                                    contract isQuarantineFinished(@(_, blockNumber), resultCh) = {
                                      resultCh!(currentBlockNumber >= blockNumber)
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        ackCh!((false, "Invalid system auth token"))
                      }
                    }
                  }
                } |
                // Adds pending rewards to global committed rewards for bookkeeping.
                new commitReward in {
                  contract commitReward(@(pk, pending), @acc, resultCh) = {
                    resultCh!(acc.set(pk, acc.getOrElse(pk, 0) + pending))
                  } |
                  contract commitRewards(@pendingRewards, @rewards, newRewardsCh) = {
                    @ListOps!("fold", pendingRewards.toList(), rewards, *commitReward, *newRewardsCh)
                  }
                } |
                // Moves the entire contents of a validator's vault to the PoS vault.
                contract moveFunds(@(unf, revAddr, vault), returnCh) = {
                  new balanceCh, unfAuthKeyCh, transferDoneCh in {
                    @vault!("balance", *balanceCh) |
                    for (@balance <- balanceCh) {
                      if (balance > 0) {
                        @RevVault!("unforgeableAuthKey", unf, *unfAuthKeyCh) |
                        for (@authKey <- unfAuthKeyCh) {
                          // Transfer funds from validator vault to the PoS vault.
                          @vault!("transfer", posRevAddress, balance, authKey, *transferDoneCh) |
                          for (@(true, _) <- transferDoneCh) {
                            returnCh!(true)
                          }
                        }
                      } else {
                        returnCh!(true)
                      }
                    }
                  }
                } |
                // Transfers all accumulated funds to the PoS vault.
                contract accumulateDeposits(returnCh) = {
                  for (@vaults <<- perActiveValidatorPosVaultsCh) {
                    @ListOps!("parMap", vaults, *moveFunds, *returnCh)
                  }
                }
              } |
              //
              contract PoS(@"commitRandomImage", @deployerId, @hash, ackCh) = {
                new userCh, mvarCh in {
                  getUser!(deployerId, *userCh) |
                  runMVar!(*stateCh, *mvarCh, *ackCh) |
                  for (@validator       <- userCh &
                       @state, resultCh <- mvarCh) {
                    if (state.get("randomImages").contains(validator)) {
                      resultCh!(state, (false, "Image already committed"))
                    } else {
                      resultCh!(
                        state.set("randomImages", state.get("randomImages").set(validator, hash)), true)
                    }
                  }
                }
              } |
              //
              contract PoS(@"revealRandom", @deployerId, @random, ackCh) = {
                new userCh, mvarCh, computeHash(`rho:crypto:keccak256Hash`), hashCh in {
                  getUser!(deployerId, *userCh) |
                  runMVar!(*stateCh, *mvarCh, *ackCh) |
                  computeHash!(random, *hashCh) |
                  for (@validator       <- userCh &
                       @state, resultCh <- mvarCh &
                       @hash            <- hashCh) {
                    if (state.get("randomImages").contains(validator)) {
                      if (hash == state.get("randomImages").get(validator)) {
                        resultCh!(
                          state.set("randomNumbers",state.get("randomNumbers").set(validator, random)), true)
                      } else {
                        resultCh!(state, (false, "Previously committed image doesn't match the random number"))
                      }
                    } else {
                      resultCh!(state, (false, "Previously committed random image not found"))
                    }
                  }
                }
              } |
              // Initialize pending rewards state for each validator
              contract PendingRewards(@"init", @validatorKeys, @return) = {
                new createStateKeyCh in {
                  @ListOps!("map", validatorKeys, *createStateKeyCh, return) |
                  contract createStateKeyCh(@key, @ackCh) = {
                    TreeHashMap!("set", pendingRewardsMap, key, {}, ackCh)
                  }
                }
              } |
              // Sum of new pending rewards with existing state
              contract PendingRewards(@"append", @validatorKey, @newRewards, @return) = {
                new currentRewardsCh in {
                  // Get existing pending rewards (per validator)
                  // - validator key is always initialized so here we can use unsafe get
                  TreeHashMap!("fastUnsafeGet", pendingRewardsMap, validatorKey, *currentRewardsCh) |
                  for (@currentRewards <- currentRewardsCh) {
                    new mergeResultCh in {
                      // Merge (sum) current pending rewards with new pending rewards
                      MergeIntMaps!(currentRewards, newRewards, *mergeResultCh) |
                      for (@mergeResult <- mergeResultCh) {
                        // Update pending rewards state
                        TreeHashMap!("set", pendingRewardsMap, validatorKey, mergeResult, return)
                      }
                    }
                  }
                }
              } |
              // Collect pending rewards from all validators (in a map) / reset state to zero.
              contract PendingRewards(@"collect", @validatorKeys, @return) = {
                new collectMaps, mapsListCh in {
                  // Get pending rewards (maps) for list of validators (public keys).
                  @ListOps!("fold", validatorKeys, [], *collectMaps, *mapsListCh) |
                  contract collectMaps(@validatorKey, @acc, mergeRet) = {
                    new updateCh, updateAckCh in {
                      // Update (per validator) pending rewards.
                      // - collect existing values and reset to empty map
                      TreeHashMap!("update", pendingRewardsMap, validatorKey, *updateCh, *updateAckCh) |
                      for (@rewardsMap, rewardsRet <- updateCh) {
                        // Reset per validator pending rewards state.
                        rewardsRet!({}) |
                        // Accumulate all rewards maps.
                        for (_ <- updateAckCh) {
                          mergeRet!(acc ++ [rewardsMap])
                        }
                      }
                    }
                  } |
                  // Merge all pending rewards maps into one map.
                  for (@mapsList <- mapsListCh) {
                    @ListOps!("fold", mapsList, {}, *MergeIntMaps, return)
                  }
                }
              }
            }
          }
        } |
        // Transfers funds from deployer to block sender.
        contract deposit(@deployerId, @amount, @activeValidators, returnCh) = {
          new vaultCh, revAddressCh,
              indexSender, authKeyCh,
              getBlockData(`rho:block:data`), blockDataCh
          in {
            @RevVault!("deployerAuthKey", deployerId, *authKeyCh) |
            revAddressOps!("fromDeployerId", deployerId, *revAddressCh) |
            for (@authKey        <- authKeyCh &
                 @fromRevAddress <- revAddressCh) {
              @RevVault!("findOrCreate", fromRevAddress, *vaultCh) |
              getBlockData!(*blockDataCh) |
              for (@(true, fromVault) <- vaultCh &
                   _, _, @sender      <- blockDataCh) {
                @ListOps!("indexOf", activeValidators, sender, *indexSender) |
                for (@idx <- indexSender) {
                  for (@vaults <<- perActiveValidatorPosVaultsCh) {
                    if (idx == -1) {
                      returnCh!((false, "Sender is not an active validator"))
                    } else {
                      match vaults.nth(idx) {
                        (_, activeValidatorVault, _) => {
                          @fromVault!("transfer", activeValidatorVault, amount, authKey, *returnCh)
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } |
        // Stake-weighted distribution of final deployment cost for bookkeeping in validator state.
        contract distributeRewards(@amount, @activeValidators, @bonds, returnCh) = {
          new computeSum, computeDelta, totalActiveStakeCh in {
            @ListOps!("fold", activeValidators, 0, *computeSum, *totalActiveStakeCh) |
            contract computeSum(@pk, @acc, resultCh) = {
              resultCh!(acc + bonds.get(pk))
            } |
            // Computes the rewards delta for each active validator.
            for (@totalActiveStake <- totalActiveStakeCh) {
              @ListOps!("fold", activeValidators, {}, *computeDelta, *returnCh) |
              // Stake-weighted rewards delta map.
              contract computeDelta(@pk, @acc, resultCh) = {
                resultCh!(acc.set(pk, (amount * bonds.get(pk)) / totalActiveStake))
              }
            }
          }
        }
      } |
      // Updates value stored on varCh and sends (Bool) acknowledgement on returnCh.
      contract runMVar(varCh, processCh, returnCh) = {
        new resultCh in {
          for (@v <- varCh) {
            processCh!(v, *resultCh) |
            for (@newV, @result <- resultCh) {
              varCh!(newV) |
              returnCh!(result)
            }
          }
        }
      } |
      // Discards second element of a pair.
      contract fst(@(first, _), resultCh) = {
        resultCh!(first)
      } |
      // For computing some of initial validator bonds.
      contract sumFromPair(@(_, a), @b, resultCh) = {
        resultCh!(a + b)
      } |
      // Retrieves deployer's public key.
      contract getUser(@deployerId, returnCh) = {
        new deployerIdOps(`rho:rchain:deployerId:ops`) in {
          deployerIdOps!("pubKeyBytes", deployerId, *returnCh)
        }
      } |
      // Selects set of active validators from the set of available validators.
      contract pickActiveValidators(@allBonds, @withdrawers, returnCh) = {
        new availableValidatorsCh,
            isAvailable, pksCh
        in {
          @ListOps!("filter", allBonds.toList(), *isAvailable, *availableValidatorsCh) |
          contract isAvailable(@(pk, _), resultCh) = {
            resultCh!(not withdrawers.contains(pk))
          } |
          for (@availableValidators <- availableValidatorsCh) {
            @ListOps!("map", availableValidators, *fst, *pksCh) |
            for (@pks <- pksCh) {
              // TODO: Randomly select 100 active validators once we have on-chain randomness
              returnCh!(pks.take($$numberOfActiveValidators$$))
            }
          }
        }
      }
    } |
    // Merge (sum) maps with integer values
    // MergeIntMaps({"a": 1, "b": 4}, {"a": 2, "c": 5, "d": Nil})
    //            = {"a": 3, "b": 4, "c": 5}
    contract MergeIntMaps(@map1, @map2, return) = {
      new mergeKey in {
        @ListOps!("fold", map2.toList(), map1, *mergeKey, *return) |
        contract mergeKey(@(key, v1), @acc, ret) = {
          match (v1, acc.get(key)) {
            (Int, v2 /\ Int) => ret!(acc.set(key, v1 + v2))
            (Int, _)         => ret!(acc.set(key, v1))
            (_, v2 /\ Int)   => ret!(acc.set(key, v2))
            _                => ret!(acc)
          }
        }
      }
    } |
    // Registers signed write-only PoS contract bundle.
    rs!(
      "047b43d6548b72813b89ac1b9f9ca67624a8b372feedd71d4e2da036384a3e1236812227e524e6f237cde5f80dbb921cac12e6500791e9a9ed1254a745a816fe1f".hexToBytes(),
      (9223372036854775807, bundle+{*PoS}),
      "3044022054ff4bae3984252b116e41e28d98bb5533eaa39aec2729228159166e2784f641022066a0fd99e7ea33df812fab095cbe61250f9548bce6da3ec4c6a90c741b94087f".hexToBytes(),
      *uriOut)
  }
}
