// Rholang macro parameters:
// minimumBond - the minimum bond allowed by the PoS
// maximumBond - the maximum bond allowed by PoS
// initialBonds - the initial bonds map
// epochLength - the length of the validation epoch in blocks
// quarantineLength - the length of the quarantine time in blocks
// numberOfActiveValidators - max number of active validator in a shard
// posMultiSigPublicKeys - public keys
// posMultiSigQuorum - how many confirmations are necessary to use multi-sig vault
/*

Life cycle in POS

POS internal state:
"allBonds"        : Map[Validator, bonds],
"activeValidators": Set[Validator],
"withdrawers"     : Map[Validator, (bonds, quantinue)],
"committedRewards" : Map[Validator, rewards],
"pendingWithdrawers": Map[Validator, quantinue]

**There are two vaults `posVault` and `coopMultiSigVault` while pos contract have no controll on `coopMultiSigVault` but `posVault`**

Several crucial calculate points:

## UserDeploy

* precharge -> user transfer the precharge funding to posVault
* refund -> posVault transfer the refund amount back to userVault

## Bonding

User transfer the bonding amount directly to posVault. `allBonds` would update with {Validator: bondAmount}.

## Withdraw(Unbond)

`pendingWithdrawers` would update with {Validator: quantinue}


## EpochChange(CloseBlock)

1. Calculate all the validator current epoch rewards based on active validator bonding proportion
2. Accumulate `committedRewards` with the result of step 1
3. Update `withdrawers` according to `allBonds` and `pendingWithdrawers` when pendingWithdrawers is not empty, remove the validator in `allBonds`
4. When the block number reaches the quantinue of `withdrawers` , transfer the corresponding bonds+ rewards to the corresponding validator from posVault.
5. update `pendingWithdrawers` to empty Map {}.
6. Pick new `activeValidators`


## Slashing
1. Transfer the bonding amount of the slashed validator based on `allBonds` from posVault to coopMultiSigVault.
2. Set the bonding amount in `allBonds` of the slashed validator to 0
3. remove the slashed validator in `activeValidators`

*/

/*
 The table below describes the required computations and their dependencies

 No. | Dependency | Computation method | Result
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 1.  |            | given              | sk = a9585a0687761139ab3587a4938fb5ab9fcba675c79fefba889859674046d4a5
 2.  |            | given              | timestamp = 1559156420651
 3.  |            | lastNonce          | nonce = 9223372036854775807
 4.  | 1,         | secp256k1          | pk = 047b43d6548b72813b89ac1b9f9ca67624a8b372feedd71d4e2da036384a3e1236812227e524e6f237cde5f80dbb921cac12e6500791e9a9ed1254a745a816fe1f
 5.  | 4, 2,      | genIds             | uname = Unforgeable(0xa32c1649f1700469f125ea85f9c2a220072e593ae617213782d738e389639d3b)
 6.  | 3, 5,      | registry           | value = (9223372036854775807, bundle+ {   Unforgeable(0xa32c1649f1700469f125ea85f9c2a220072e593ae617213782d738e389639d3b) })
 7.  | 6,         | protobuf           | toSign = 2a40aa013d0a0d2a0b10feffffffffffffffff010a2c5a2a0a263a240a220a20a32c1649f1700469f125ea85f9c2a220072e593ae617213782d738e389639d3b1001
 8.  | 7, 1,      | secp256k1          | sig = 3044022054ff4bae3984252b116e41e28d98bb5533eaa39aec2729228159166e2784f641022066a0fd99e7ea33df812fab095cbe61250f9548bce6da3ec4c6a90c741b94087f
 9.  | 4,         | registry           | uri = rho:id:m3xk7h8r54dtqtwsrnxqzhe81baswey66nzw6m533nyd45ptyoybqr
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
*/

new
  PosDispatcher,
  PoS,
  rb(`rho:registry:insertBlessed`),
  registryLookup(`rho:registry:lookup`),
  revAddressOps(`rho:rev:address`),
  getUser,
  pickActiveValidators,
  runMVar,
  fst,
  deposit,
  distributeRewards,
  perActiveValidatorPosVaultsCh,
  transferFromBlockSender,
  rs(`rho:registry:insertSigned:secp256k1`),
  posId(`rho:rchain:deployerId`),
  PendingRewards, MergeIntMaps,
  sysAuthTokenOps(`sys:authToken:ops`),
  coopVaultCh,
  uriOut,
  sumFromPair,
  treeHashMapCh,
  revVaultCh,
  multiSigRevVaultCh,
  listOpsCh,
  currentDeployerData
in {
  // Simultaneously retrieves RevVault, ListOps, TreeHashMap, and MultiSigRevVault contracts from the registry.
  registryLookup!(`rho:rchain:revVault`, *revVaultCh) |
  registryLookup!(`rho:lang:listOps`, *listOpsCh) |
  registryLookup!(`rho:lang:treeHashMap`, *treeHashMapCh) |
  registryLookup!(`rho:rchain:multiSigRevVault`, *multiSigRevVaultCh) |
  for (@(_, RevVault)         <- revVaultCh &
       @(_, ListOps)          <- listOpsCh &
       TreeHashMap            <- treeHashMapCh &
       @(_, MultiSigRevVault) <- multiSigRevVaultCh) {
    new posDeployerRevAddressCh, posDeployerAuthKeyCh, posDeployerVaultCh, posVaultCh,
        initialActiveCh, pendingRewardsMapCh, createUnfVault, moveInitialBondCh
    in {
      // Creates the auth key and Rev vault associated with the PoS contract.
      new posPkCh in {
        @RevVault!("deployerAuthKey", *posId, *posDeployerAuthKeyCh) |
        getUser!(*posId, *posPkCh) |
        for (@posPk <- posPkCh) {
          revAddressOps!("fromPublicKey", posPk, *posDeployerRevAddressCh) |
          // Creates Coop multisig vault for slashed funds.
          // Either (false, errorMsg) or (true, (multiSigVault, revAddress, revVault)) are returned on coopVaultCh.
          @MultiSigRevVault!(
            "create",
            $$posMultiSigPublicKeys$$,
            [],
            $$posMultiSigQuorum$$,
            *coopVaultCh
          )
        }
      } |
      // ret: the return channel of the create
      // pubKey: the pubkey which control the unforgeable name
      contract createUnfVault(ret, @pubkey) = {
        new unf, unfAddrRet, createRetCh, pubKeyChainUnfVault, unfVaultHandle, stdout(`rho:io:stdout`) in {
          revAddressOps!("fromUnforgeable", *unf, *unfAddrRet) |
          for (@unfAddr <- unfAddrRet){
            @RevVault!("findOrCreate", unfAddr, *createRetCh) |
            for (@(true, vault) <- createRetCh){
              contract unfVaultHandle(@"transfer", @targetAddress, @amount, deployerID, transferRet) = {
                new deployerPubKeyBytesCh, DeployerIdOps(`rho:rchain:deployerId:ops`) in {
                  DeployerIdOps!("pubKeyBytes", *deployerID, *deployerPubKeyBytesCh) |
                  for (@deployerPubKeyBytes <- deployerPubKeyBytesCh) {
                    if (deployerPubKeyBytes ==  pubkey.hexToBytes()){
                      new unfAuthKeyCh in {
                        @RevVault!("unforgeableAuthKey", *unf, *unfAuthKeyCh) |
                        for (@unfAuthKey <- unfAuthKeyCh){
                          @vault!("transfer", targetAddress, amount, unfAuthKey, *transferRet)
                        }
                      }
                    } else {
                      transferRet!((false, "You have not permission to transfer."))
                    }
                  }
                }
              } |
              ret!((*unf, unfAddr, vault ,*unfVaultHandle))
            }
          }
        }
      }|
      createUnfVault!(*posVaultCh, "$$posPubKey$$") |
      for (@(posVaultUnf, posVaultAddr, posVault, humanControlHandle) <- posVaultCh){
      for (@posDeployerRevAddress <- posDeployerRevAddressCh;
           @posDeployerAuthKey    <- posDeployerAuthKeyCh)  {
        for (@(true, (coopMultiVault, coopMultiVaultAddr, coopVaultHd)) <<- coopVaultCh) {
          // Creates PoS Rev vault with sum of initial bonds.
          new bondSumCh in {
            @ListOps!("fold", $$initialBonds$$.toList(), 0, *sumFromPair, *bondSumCh) |
            for (@bondSum <- bondSumCh) {
              @RevVault!("createWithBalance", posDeployerRevAddress, bondSum, *posDeployerVaultCh)|
              for (@(true, posDeployerVault)  <- posDeployerVaultCh) {
                // move all the fund from deployer addr to POS unforgeable vault
                @posDeployerVault!("transfer", posVaultAddr, bondSum, posDeployerAuthKey, *moveInitialBondCh)
              }
            }
          } |
          // Selects the initial active validators.
          pickActiveValidators!($$initialBonds$$.toList(), *initialActiveCh) |
          for (@initialActive     <- initialActiveCh;
               @(true, _) <- moveInitialBondCh) {
            new stateCh, pendingRewardsInitializedCh, rewardsInfo, calTotalActiveBonds, calTotalBonds,
                accumulateSndNum, accumulateFstOfSndArg, accumulateItemInState in {
              // Initializes PoS state structure.
              stateCh!({
                // Map[PublicKey, Int] - each validator stake
                "allBonds"        : $$initialBonds$$,
                // Set[PublicKey]     - the active validators
                "activeValidators": initialActive,
                // Map[PublicKey, (Int, Int)] - The validators who issued a withdraw request , finished validating jobs and not active.
                //                              When the validator reachs the quantinue length, it would be removed in the map and
                //                              pos would transfer back all the original bond and rewards back to validator vault.
                //                              Value(Int, Int) represents (original bond + reward, quantinue length)
                "withdrawers"     : {},
                // Map[PublicKey, Int]
                "committedRewards" : {},
                // Map[PublicKey, Int] - the validators wishing to withdraw and the block number when their quarantine ends
                "pendingWithdrawers": {},
                "randomImages"    : {},
                "randomNumbers"   : {},
              }) |
              contract rewardsInfo(retCh) = {
                new posBalanceCh, totalActiveBondCh, totalBondCh, totalWithdrawCh, committedRewardsCh in {
                  @posVault!("balance", *posBalanceCh) |
                  accumulateItemInState!(*totalBondCh, "allBonds", *accumulateSndNum) |
                  calTotalActiveBonds!(*totalActiveBondCh) |
                  accumulateItemInState!(*totalWithdrawCh, "withdrawers", *accumulateFstOfSndArg) |
                  accumulateItemInState!(*committedRewardsCh, "committedRewards", *accumulateSndNum) |
                  for (@posBalance <- posBalanceCh; @totalBond <- totalBondCh; @activeBonds <- totalActiveBondCh;
                       @totalWithdraw <- totalWithdrawCh; @totalCommittedRewards <- committedRewardsCh){
                    for (@state <<- stateCh) {
                      retCh!((posBalance , totalBond , activeBonds, totalWithdraw, totalCommittedRewards, state.get("allBonds"), state.get("activeValidators")))
                    }
                  }
                }
              } |
              contract calTotalActiveBonds(returnCh) = {
                new computeSum in {
                  for (@state <<- stateCh){
                    @ListOps!("fold", state.get("allBonds").toList(), 0, *computeSum, *returnCh) |
                    contract computeSum(@(pk, bondAmount), @acc, resultCh) = {
                      if (state.get("activeValidators").contains(pk)){
                        resultCh!(acc + bondAmount)
                      } else {
                        resultCh!(acc)
                      }
                    }
                  }
                }
              } |
              contract accumulateSndNum(@(_, amount), @acc, resultCh) = {
                resultCh!(acc + amount)
              } |
              contract accumulateFstOfSndArg(@(_, (amount, _)), @acc, resultCh) = {
                resultCh!(acc + amount)
              } |
              contract accumulateItemInState(returnCh, @stateKey, accumulateAlgo) = {
                for (@state <<- stateCh){
                  @ListOps!("fold", state.get(stateKey).toList(), 0, *accumulateAlgo, *returnCh)
                }
              }|
              contract PoS(@"getCurrentEpochRewards", returnCh) = {
                new rewardCh, computeReward in {
                  rewardsInfo!(*rewardCh)|
                  for (@(posBalance, totalBond, activeBonds, totalWithdraw, totalCommittedRewards, bondsMap, activeValidatorsSet) <- rewardCh){
                    @ListOps!("fold", bondsMap.toList(), {}, *computeReward, *returnCh) |
                    contract computeReward(@(pk, bonds), @acc,  outCh) = {
                      //  someAmount / minimumBond to reduce the possibility on overflow long
                      if (activeValidatorsSet.contains(pk)){
                        outCh!(acc.set(pk, (posBalance - totalBond - totalWithdraw - totalCommittedRewards) * (bonds / $$minimumBond$$) / (activeBonds / $$minimumBond$$)))
                      } else {
                        outCh!(acc.set(pk, 0))
                      }
                    }
                  }
                }
              } |
              contract PoS(@"getRewards", returnCh) = {
                new currentEpochRewardCh, accumulateReward in {
                  for (@state <<- stateCh) {
                    PoS!("getCurrentEpochRewards", *currentEpochRewardCh)|
                    for (@currentEpochReward <- currentEpochRewardCh) {
                      @ListOps!("fold", currentEpochReward.toList(), state.get("committedRewards"), *accumulateReward, *returnCh) |
                      contract accumulateReward(@(pk, reward), @acc, outCh) = {
                        outCh!(acc.set(pk, acc.getOrElse(pk, 0) + reward))
                      }
                    }
                  }
                }
              } |
              // Peeks at bonds map.
              contract PoS(@"getBonds", returnCh) = {
                for (@state <<- stateCh) {
                  returnCh!(state.get("allBonds"))
                }
              } |
              // Peeks at active validator list.
              contract PoS(@"getActiveValidators", returnCh) = {
                for (@state <<- stateCh) {
                  returnCh!(state.get("activeValidators"))
                }
              } |
              // Peeks at active validator list.
              contract PoS(@"getWithdrawers", returnCh) = {
                for (@state <<- stateCh) {
                  returnCh!(state.get("withdrawers"))
                }
              } |
              contract PoS(@"getPendingWithdrawer", returnCh) = {
                for (@state <<- stateCh) {
                  returnCh!(state.get("pendingWithdrawers"))
                }
              } |
              // Exposes Coop multisig vault on returnCh.
              contract PoS(@"getCoopVault", returnCh) = {
                for (@(_, coopVault) <<- coopVaultCh) {
                  returnCh!((coopMultiVault, coopMultiVaultAddr, coopVaultHd))
                }
              } |
              // Exposes initial PoS vault on returnCh.
              contract PoS(@"getInitialPosVault", returnCh) = {
                returnCh!((posVaultAddr, posVault))
              } |
              // Exposes epochLength parameter to PoSTest.
              contract PoS(@"getEpochLength", returnCh) = {
                returnCh!($$epochLength$$)
              } |
              // Exposes quarantineLength parameter to PoSTest.
              contract PoS(@"getQuarantineLength", returnCh) = {
                returnCh!($$quarantineLength$$)
              } |
              contract PoS(@"posVaultTransfer", @targetAddress, @amount, @deployerID, @transferRet) = {
                // human transfer would just use this method
                @humanControlHandle!("transfer", targetAddress, amount, deployerID, transferRet)
              } |
              // Returns current state elements on `ret`.
              contract @(bundle+{*PoS}, "extractState")(ret) = {
                for (@state <<- stateCh) {
                  ret!({
                    "state"     : state,
                    "coopVault" : (coopMultiVault, coopMultiVaultAddr, coopVaultHd),
                    "posVault"  : (posVaultUnf, posVaultAddr, posVault, humanControlHandle),
                    "currentDeployerData"   : *currentDeployerData
                  })
                }
              } |
              // Public method allowing users to bond and become validators.
              contract PoS(@"bond", @deployerId, @amount, returnCh) = {
                new userCh, depositCh,
                    processCh
                in {
                  runMVar!(*stateCh, *processCh, *returnCh) |
                  getUser!(deployerId, *userCh) |
                  for (@state, resultCh <- processCh &
                       @userPk          <- userCh) {
                    if (state.get("allBonds").contains(userPk)) {
                      resultCh!(state, (false, "Public key is already bonded."))
                    } else if (amount < $$minimumBond$$) {
                      resultCh!(state, (false, "Bond is less than minimum!"))
                    } else if (amount > $$maximumBond$$) {
                      resultCh!(state, (false, "Bond is greater than maximum!"))
                    } else {
                      // Transfers user's bond amount to the PoS vault.
                      deposit!(deployerId, amount, posVaultAddr, *depositCh) |
                      for (@depositResult <- depositCh) {
                        match depositResult {
                          // If deposit is successful, the user becomes a bonded validator.
                          (true, _) => {
                            resultCh!(state.set("allBonds", state.get("allBonds").set(userPk, amount)), depositResult)
                          }
                          // If deposit is unsuccessful, the user is not bonded.
                          (false, errorMsg) => {
                            resultCh!(state, (false, "Bond deposit failed: " ++ errorMsg))
                          }
                        }
                      }
                    }
                  }
                }
              } |
              // Public method allowing validators to withdraw their bonded and accumulated funds.
              contract PoS(@"withdraw", @deployerId, returnCh) = {
                new userCh, processCh, blockDataCh,
                    getBlockData(`rho:block:data`)
                in {
                  // Consumes state and updates withdrawers map.
                  runMVar!(*stateCh, *processCh, *returnCh) |
                  getBlockData!(*blockDataCh) |
                  getUser!(deployerId, *userCh) |
                  for (@state, resultCh   <- processCh &
                       @userPk            <- userCh &
                       @blockNumber, _, _ <- blockDataCh) {
                    if (state.get("allBonds").contains(userPk)) {
                      // The withdrawal goes into effect at the start of the next epoch.
                      resultCh!(
                        state.set("pendingWithdrawers",
                                  state.get("pendingWithdrawers")
                                       .set(userPk,
                                         $$quarantineLength$$ + $$epochLength$$ * (1 + blockNumber / $$epochLength$$))),
                        (true, Nil))
                    } else {
                      resultCh!(state, (false, "User is not bonded"))
                    }
                  }
                }
              } |
              // Private method which charges a deployer for a deploy.
              // Deployer's funds are deposited into the block sender's vault.
              // Return expects (Boolean, Either[Nil, String])
              contract PoS(@"chargeDeploy", @deployerId, @amount, @sysAuthToken, return) = {
                new isValidTokenCh in {
                  sysAuthTokenOps!("check", sysAuthToken, *isValidTokenCh) |
                  for (@isValid <- isValidTokenCh) {
                    if (isValid) {
                      new depositCh in {
                        deposit!(deployerId, amount, posVaultAddr, *depositCh) |
                        for (@depositResult <- depositCh){
                          match depositResult {
                            (true, _) => {
                              currentDeployerData!((deployerId, amount)) |
                              return!(depositResult)
                            }
                            (_, errorMessage) => {
                              return!((false, "Deploy payment failed: " ++ errorMessage))
                            }
                          }
                        }
                      }
                    } else {
                      return!((false, "Invalid system auth token"))
                    }
                  }
                }
              } |
              // Private method which refunds a deployer if too much was charged in chargeDeploy.
              // Funds are transferred from the block sender's vault to the deployer.
              // Return expects (Boolean, Either[Nil, String])
              contract PoS(@"refundDeploy", @refundAmount, @sysAuthToken, return) = {
                new isValidTokenCh, posAuthKeyCh in {
                  sysAuthTokenOps!("check", sysAuthToken, *isValidTokenCh) |
                  for (@isValid <- isValidTokenCh) {
                    if (isValid) {
                      for (@(deployerId, initialPaymentAmount) <- currentDeployerData){
                        if (refundAmount > 0) {
                          new revAddressCh, transferCh in {
                            revAddressOps!("fromDeployerId", deployerId, *revAddressCh) |
                            @RevVault!("unforgeableAuthKey", posVaultUnf, *posAuthKeyCh) |
                            for (@deployerRevAddress <- revAddressCh ; @posAuthKey <- posAuthKeyCh) {
                              // Transfer (from sender to deployer) called in refundDeploy.
                              @posVault!("transfer", deployerRevAddress, refundAmount, posAuthKey, *transferCh) |
                              for (@transferResult <- transferCh) {
                                match transferResult {
                                  (true, _) => {
                                    return!((true, Nil))
                                  }
                                  (_, errorMessage) => {
                                    return!((false, "(Bug found) Deploy refund failed: " ++ errorMessage))
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          return!((true, Nil))
                        }
                      }
                    } else {
                      return!((false, "Invalid system auth token"))
                    }
                  }
                }
              } |
              new commitRewards in {
                // Private method which transfers all of a validator's rewards + bond to the Coop vault.
                // Slash expects (Boolean, Either[Nil, String]) on returnCh.
                contract PoS(@"slash", @deployerId, @blockHash, @sysAuthToken, returnCh) = {
                  new isValidTokenCh in {
                    sysAuthTokenOps!("check", sysAuthToken, *isValidTokenCh) |
                    for (@isValid <- isValidTokenCh) {
                      if (isValid) {
                        new invalidBlocksCh, stateProcessCh, userCh,
                            getInvalidBlocks(`rho:casper:invalidBlocks`)
                        in {
                          getInvalidBlocks!(*invalidBlocksCh) |
                          getUser!(deployerId, *userCh) |
                          runMVar!(*stateCh, *stateProcessCh, *returnCh) |
                          for (@invalidBlocks        <- invalidBlocksCh &
                               @userPk               <- userCh &
                               @state, stateUpdateCh <- stateProcessCh) {
                                new toBeSlashed, valBondCh, valRewardCh, posAuthKeyCh in {
                                  // Flow of logic:
                                  // 0. check if blockHash is the hash of an invalid block
                                  // 1. transfer stake of slashed validator from PoS to Coop vault
                                  // 2. update state
                                  // Retrieves either public key of sender of invalid block or the deployer public key.
                                  toBeSlashed!(invalidBlocks.getOrElse(blockHash, userPk)) |
                                  for (@validator <- toBeSlashed) {
                                    // Takes the stake of slashed validator
                                    valBondCh!(state.get("allBonds").get(validator)) |
                                    @RevVault!("unforgeableAuthKey", posVaultUnf, *posAuthKeyCh) |
                                    for (@valBond <- valBondCh ; @posAuthKey <- posAuthKeyCh) {
                                      // Transfers slashed funds from PoS vault to Coop vault, then updates state.
                                      new transferDoneCh in {
                                        @posVault!(
                                          "transfer",
                                          coopMultiVaultAddr,
                                          valBond,
                                          posAuthKey,
                                          *transferDoneCh
                                        ) |
                                        // FIXME handle transfer failing case
                                        for (_ <- transferDoneCh) {
                                          // Sets slashed validator's committed rewards and bond to 0 in state.
                                          // Moves slashed validator to withdrawers map with no quarantine period.
                                          stateUpdateCh!({
                                            "allBonds"        : state.get("allBonds").set(validator, 0),
                                            "activeValidators": state.get("activeValidators").delete(validator),
                                            "committedRewards" : state.get("committedRewards").delete(validator),
                                            "withdrawers"     : state.get("withdrawers"),
                                            "pendingWithdrawers": state.get("pendingWithdrawers"),
                                            "randomImages"    : state.get("randomImages"),
                                            "randomNumbers"   : state.get("randomNumbers")
                                          },
                                          (true, Nil))
                                        }
                                      }
                                    }
                                  }
                                }
                          }
                        }
                      } else {
                        returnCh!((false, "Invalid system auth token"))
                      }
                    }
                  }
                } |
                // Private method which signals the end of block processing.
                contract PoS(@"closeBlock", @sysAuthToken, ackCh) = {
                  new isValidTokenCh in {
                    sysAuthTokenOps!("check", sysAuthToken, *isValidTokenCh) |
                    for (@isValid <- isValidTokenCh) {
                      if (isValid) {
                        new blockDataCh, getBlockData(`rho:block:data`) in {
                          getBlockData!(*blockDataCh) |
                          for (@blockNumber, _, _ <- blockDataCh) {
                            if (blockNumber % $$epochLength$$ != 0) {
                              // Epoch change does not occur.
                              ackCh!((true, Nil))
                            } else {
                              // Epoch change occurs.
                              new payWithdrawer, removeQuarantinedWithdrawers,
                                  stateProcessCh, paymentDoneCh,
                                  accDepositsDoneCh, commitRewardsCh,
                                  newValidatorsCh, removeQuarantinedCh, currentEpochRewardCh,
                                  commitCurrentEpochRewards, updatedRewardsCh, movePendingWithdrawCh, movePendingWithdrawer
                              in {
                                PoS!("getCurrentEpochRewards", * currentEpochRewardCh) |
                                for (@currentRewards <- currentEpochRewardCh) {
                                  runMVar!(*stateCh, *stateProcessCh, *ackCh) |
                                  for (@state, stateUpdateCh <- stateProcessCh) {
                                    // 1. Calculate all the validator current epoch rewards based on active validator bonding proportion
                                    // 2. Accumulate `committedRewards` with the result of step 1
                                    commitCurrentEpochRewards!(state, currentRewards, *updatedRewardsCh) |
                                    for (@newCommittedState <- updatedRewardsCh) {
                                      // 3. Update `withdrawers` according to `allBonds` and `pendingWithdrawers`
                                      // when pendingWithdrawers is not empty, remove the validator in `allBonds`
                                      movePendingWithdrawer!(newCommittedState, *movePendingWithdrawCh) |
                                      for (@newMovedPendingState <- movePendingWithdrawCh){
                                        // 4. When the block number reaches the quantinue of `withdrawers` ,
                                        //  transfer the corresponding bonds+ rewards to the corresponding validator from posVault.
                                        // 5. update `pendingWithdrawers` to empty Map {}.
                                        removeQuarantinedWithdrawers!(blockNumber, newMovedPendingState, *removeQuarantinedCh) |
                                        for (@newRemovedQuantinueState <- removeQuarantinedCh) {
                                          // 6. Pick new `activeValidators`
                                          pickActiveValidators!(newMovedPendingState.get("allBonds").toList(), *newValidatorsCh) |
                                          for (@newValidators <- newValidatorsCh) {
                                            stateUpdateCh!(newRemovedQuantinueState.set("activeValidators", newValidators), (true, Nil))
                                          }
                                        }
                                      }
                                    }
                                  }
                                } |
                                // Transfers withdrawing validator's bond + accumulated rewards from PoS vault to their vault.
                                contract payWithdrawer(@(pk, amount), returnCh) = {
                                  new vaultCh, revAddressCh, createCh, posAuthKeyCh in {
                                    revAddressOps!("fromPublicKey", pk, *revAddressCh) |
                                    @RevVault!("unforgeableAuthKey", posVaultUnf, *posAuthKeyCh) |
                                    for (@toRevAddress <- revAddressCh; @posAuthKey <- posAuthKeyCh) {
                                      @RevVault!("findOrCreate", toRevAddress, *createCh) |
                                      for (@_ <- createCh){
                                        @posVault!("transfer", toRevAddress, amount, posAuthKey, *returnCh)
                                      }
                                    }
                                  }
                                } |
                                contract commitCurrentEpochRewards(@state, @currentRewards, returnCh) = {
                                  new accumulate in {
                                    @ListOps!("fold", currentRewards.toList(), state, *accumulate, *returnCh) |
                                    contract accumulate(@(pk, reward), @updatedState, resultCh) = {
                                      resultCh!(updatedState.set("committedRewards",
                                                                  updatedState.get("committedRewards").set(pk, updatedState.get("committedRewards").getOrElse(pk, 0) + reward)))
                                    }
                                  }
                                } |
                                contract movePendingWithdrawer(@state, returnCh) = {
                                  new movePending in {
                                    @ListOps!("fold", state.get("pendingWithdrawers").toList(), state, *movePending, *returnCh) |
                                    contract movePending(@(pk, quantine), @updatedState, resultCh) = {
                                      resultCh!(updatedState
                                                .set("withdrawers", updatedState.get("withdrawers").set(pk, (updatedState.get("allBonds").get(pk), quantine)))
                                                .set("allBonds", updatedState.get("allBonds").delete(pk))
                                                .set("pendingWithdrawers", updatedState.get("pendingWithdrawers").delete(pk))
                                                )
                                    }
                                  }
                                } |
                                // Checks withdrawer's quarantine period against current block number,
                                // then computes their payment, removes them from the bonds and withdrawers maps, and
                                // updates the committed rewards map.
                                contract removeQuarantinedWithdrawers(@currentBlockNumber, @state, returnCh) = {
                                  new quarantinedValidatorsCh, validatorsToWithdrawListCh,
                                      isQuarantineFinished, notWithdrawn, payWithdraw,
                                      newBondsListCh, newWithdrawersListCh,
                                      computeRemove, payRet
                                  in {
                                    // Calculate rewards by taking PoS balance on PoS vault and subtract all active stake + newly bonded
                                    @ListOps!("filter", state.get("withdrawers").toList(), *isQuarantineFinished, *quarantinedValidatorsCh) |
                                    for (@quarantinedValidators <- quarantinedValidatorsCh) {
                                      @ListOps!("unorderedParMap", quarantinedValidators, *payWithdraw, *payRet) |
                                      contract payWithdraw(@(pk, (bonds, quantine)), resultCh) = {
                                        // FIXME fix transfer in failure case
                                        payWithdrawer!((pk, bonds + state.get("committedRewards").getOrElse(pk, 0)), *resultCh)
                                      } |
                                      for (@_ <- payRet) {
                                        @ListOps!("fold", quarantinedValidators, state, *computeRemove, *returnCh) |
                                        contract computeRemove(@(pk, (bonds, quantine)), @updatedState, resultCh) = {
                                          resultCh!(updatedState
                                                    .set("committedRewards", updatedState.get("committedRewards").delete(pk))
                                                    .set("withdrawers", updatedState.get("withdrawers").delete(pk))
                                                    )
                                        }
                                      }
                                    } |
                                    // Check whether quarantine period is finished.
                                    contract isQuarantineFinished(@(pk, (bonds, blockNumber)), resultCh) = {
                                      resultCh!(currentBlockNumber >= blockNumber)
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        ackCh!((false, "Invalid system auth token"))
                      }
                    }
                  }
                }
              } |
              //
              contract PoS(@"commitRandomImage", @deployerId, @hash, ackCh) = {
                new userCh, mvarCh in {
                  getUser!(deployerId, *userCh) |
                  runMVar!(*stateCh, *mvarCh, *ackCh) |
                  for (@validator       <- userCh &
                       @state, resultCh <- mvarCh) {
                    if (state.get("randomImages").contains(validator)) {
                      resultCh!(state, (false, "Image already committed"))
                    } else {
                      resultCh!(
                        state.set("randomImages", state.get("randomImages").set(validator, hash)), true)
                    }
                  }
                }
              } |
              //
              contract PoS(@"revealRandom", @deployerId, @random, ackCh) = {
                new userCh, mvarCh, computeHash(`rho:crypto:keccak256Hash`), hashCh in {
                  getUser!(deployerId, *userCh) |
                  runMVar!(*stateCh, *mvarCh, *ackCh) |
                  computeHash!(random, *hashCh) |
                  for (@validator       <- userCh &
                       @state, resultCh <- mvarCh &
                       @hash            <- hashCh) {
                    if (state.get("randomImages").contains(validator)) {
                      if (hash == state.get("randomImages").get(validator)) {
                        resultCh!(
                          state.set("randomNumbers",state.get("randomNumbers").set(validator, random)), true)
                      } else {
                        resultCh!(state, (false, "Previously committed image doesn't match the random number"))
                      }
                    } else {
                      resultCh!(state, (false, "Previously committed random image not found"))
                    }
                  }
                }
              }
            }
          }
        } |
        // Transfers funds from deployer to block sender.
        contract deposit(@deployerId, @amount, @toTargetAddress, returnCh) = {
          new vaultCh, revAddressCh,
              indexSender, authKeyCh
          in {
            @RevVault!("deployerAuthKey", deployerId, *authKeyCh) |
            revAddressOps!("fromDeployerId", deployerId, *revAddressCh) |
            for (@authKey        <- authKeyCh &
                 @fromRevAddress <- revAddressCh) {
              @RevVault!("findOrCreate", fromRevAddress, *vaultCh) |
              for (@(true, fromVault) <- vaultCh) {
                // Transfers from deployer to PoS vault
                @fromVault!("transfer", toTargetAddress, amount, authKey, *returnCh)
              }
            }
          }
        }
      } |
      // Updates value stored on varCh and sends (Bool) acknowledgement on returnCh.
      contract runMVar(varCh, processCh, returnCh) = {
        new resultCh in {
          for (@v <- varCh) {
            processCh!(v, *resultCh) |
            for (@newV, @result <- resultCh) {
              varCh!(newV) |
              returnCh!(result)
            }
          }
        }
      } |
      // Discards second element of a pair.
      contract fst(@(first, _), resultCh) = {
        resultCh!(first)
      } |
      // For computing some of initial validator bonds.
      contract sumFromPair(@(_, a), @b, resultCh) = {
        resultCh!(a + b)
      } |
      // Retrieves deployer's public key.
      contract getUser(@deployerId, returnCh) = {
        new deployerIdOps(`rho:rchain:deployerId:ops`) in {
          deployerIdOps!("pubKeyBytes", deployerId, *returnCh)
        }
      } |
      // Selects set of active validators from the set of available validators.
      contract pickActiveValidators(@allBonds, returnCh) = {
        new availableValidatorsCh,
            isAvailable, pksCh
        in {
          @ListOps!("map", allBonds, *fst, *pksCh) |
          for (@pks <- pksCh) {
            // TODO: Randomly select 100 active validators once we have on-chain randomness
            returnCh!(pks.take($$numberOfActiveValidators$$).toSet())
          }
        }
      }
    }
    }|
    // Insert location channel into the registry location map
     rb!(`rho:rchain:pos`, bundle+{*PoS}, *PosDispatcher) |
     // Put the contract data on the location channel
     // Insert the signed, write-only dispatcher contract into the registry uri map
    rs!(
      (9223372036854775807, bundle+{*PosDispatcher}),
      *posId,
      *uriOut)
  }
}
