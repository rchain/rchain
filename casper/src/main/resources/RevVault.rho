/*
 The table below describes the required computations and their dependencies

 No. | Dependency | Computation method | Result
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 1.  |            | given              | sk = 27e5718bf55dd673cc09f13c2bcf12ed7949b178aef5dcb6cd492ad422d05e9d
 2.  |            | given              | timestamp = 1559156183943
 3.  |            | lastNonce          | nonce = 9223372036854775807
 4.  | 1,         | secp256k1          | pk = 040f035630a5d2199184890b4b6b83440c842da0b6becca539f788f7b35d6e873561f673cd6ebe2e32236398a86f29dad992e8fba32534734300fcc5104bcfea0e
 5.  | 4, 2,      | genIds             | uname = Unforgeable(0x263f45f2ca50669ef4011a57d3a10270c1250d52ed99f212a6332d8ffe57d3be)
 6.  | 3, 5,      | registry           | value = (9223372036854775807, bundle+ {   Unforgeable(0x263f45f2ca50669ef4011a57d3a10270c1250d52ed99f212a6332d8ffe57d3be) })
 7.  | 6,         | protobuf           | toSign = 2a40aa013d0a0d2a0b10feffffffffffffffff010a2c5a2a0a263a240a220a20263f45f2ca50669ef4011a57d3a10270c1250d52ed99f212a6332d8ffe57d3be1001
 8.  | 7, 1,      | secp256k1          | sig = 30450221008af89d676c4cd6b3d41e90da89b03a1e83f161fc8c4ad22c9edc903db3a9f4c402204e35e29e40a5f2b2f431d3cc63b87fb52c33716b3ce331a2a19b9660c3690c18
 9.  | 4,         | registry           | uri = rho:id:6zcfqnwnaqcwpeyuysx1rm48ndr6sgsbbgjuwf45i5nor3io7dr76j
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 */
new
  RevVault,
  uriOut,
  rs(`rho:registry:insertSigned:secp256k1`),
  rl(`rho:registry:lookup`),
  RevAddress(`rho:rev:address`),
  MakeMintCh,
  AuthKeyCh,
  EitherCh,
  TreeHashMapCh,
  _makeVault,
  _newVault,
  _create,
  _revVault,
  _transferTemplate,
  _depositTemplate
in {
  // Lookup contract names in the registry
  rl!(`rho:rchain:makeMint`, *MakeMintCh) |
  rl!(`rho:rchain:authKey`, *AuthKeyCh) |
  rl!(`rho:lang:either`, *EitherCh) |
  rl!(`rho:lang:treeHashMap`, *TreeHashMapCh) |
  for (@(_, MakeMint) <- MakeMintCh &
       @(_, AuthKey)  <- AuthKeyCh &
       @(_, Either)   <- EitherCh &
       TreeHashMap    <- TreeHashMapCh) {
    // Each invocation of the RevVault contract uses a different mint
    new
      mintCh,
      vaultMapStore,
      initVault
    in {
      // Initializes the `vaultMapStore`
      TreeHashMap!("init", 2, *vaultMapStore) |
      for (@vaultMap <- vaultMapStore) {
        // Called from RevGenerator:
        //   RevVault!("init", *ret)
        new initContinue in {
          // REV vault initialization in genesis is done in batches.
          // In the last batch `initContinue` channel will not receive anything
          // so further access to `RevVault(@"init", _)` is impossible
          initContinue!() |
          contract RevVault(@"init", ret) = {
            for (<- initContinue) {
              ret!(*TreeHashMap, vaultMap, *initVault, *initContinue)
            }
          }
        } |
        // Retrieve MakeMint contract from registry
        @MakeMint!(*mintCh) |
        for (mint <- mintCh) {
          // Initializes a vault with given `name`, `address`, and purse containing the `initialAmount`
          contract initVault(name, @address, @initialAmount) = {
            new purseCh in {
              mint!("makePurse", initialAmount, *purseCh) |
              for (purse <- purseCh) {
                _newVault!(*name, address, *purse)
              }
            }
          } |
          // Creates an auth key from `deployerId` and returns a write-only version on `ret`
          contract RevVault(@"deployerAuthKey", deployerId, ret) = {
            new
              RevAddress(`rho:rev:address`),
              DeployerIdOps(`rho:rchain:deployerId:ops`),
              revAddrCh,
              deployerPubKeyBytesCh
            in {
              DeployerIdOps!("pubKeyBytes", *deployerId, *deployerPubKeyBytesCh) |
              for (@deployerPubKeyBytes <- deployerPubKeyBytesCh) {
                RevAddress!("fromPublicKey", deployerPubKeyBytes, *revAddrCh) |
                for (@deployerRevAddress <- revAddrCh) {
                  @AuthKey!("make", (*_revVault, deployerRevAddress), *ret)
                }
              }
            }
          } |
          // Creates an auth key from the unforgeable name `unf` and returns a write-only version on `ret`
          contract RevVault(@"unforgeableAuthKey", unf, ret) = {
            new
              RevAddress(`rho:rev:address`),
              revAddrCh
            in {
              RevAddress!("fromUnforgeable", *unf, *revAddrCh) |
              for (@unfRevAddress <- revAddrCh) {
                @AuthKey!("make", (*_revVault, unfRevAddress), *ret)
              }
            }
          } |
          // Either retrieves or creates corresponding Rev vault and returns corresponding either on `retCh`
          contract RevVault(@"findOrCreate", @revAddress, retCh) = {
            new
              revAddressValidCh,
              revAddressValidEitherCh
            in {
              // Validate Rev address first
              RevAddress!("validate", revAddress, *revAddressValidCh) |
              @Either!("fromNillableError <-", *revAddressValidCh, *revAddressValidEitherCh) |
              for (@revAddressEither <- revAddressValidEitherCh) {
                match revAddressEither {
                  // Invalid Rev address returns Left.
                  (false, _) => {
                    retCh!(revAddressEither)
                  }
                  // Valid Rev address returns Right and we proceed with creation/search.
                  _ => {
                    new
                      createVault,
                      vaultCh,
                      getVaultCh
                    in {
                      new stdlog(`rho:io:stdlog`) in {stdlog!("info", ("get in findOrCreate"))}|
                      TreeHashMap!("get", vaultMap, revAddress, *getVaultCh) |
                      for (@res <- getVaultCh) {
                        match res {
                          Nil => {
                            // If vault was not found in store, create it and put it in the store.
                            _create!(revAddress, *createVault, *vaultCh) |
                            for (vaultRetCh <- createVault) {
                              // Creates Rev vault and returns on vaultRetCh, consumed within _create contract.
                              _makeVault!(revAddress, 0, *vaultRetCh) |
                              // Blocks until both the vault is created and set in the store.
                              for (@eitherVault <- vaultCh) {
                                retCh!(eitherVault)
                              }
                            }
                          }
                          (_, vault, _) => {
                            // If vault is in the store, return (true, vault).
                            retCh!((true, vault))
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } |
          // Used during genesis to create PoS vault with initial balance = sum of initial bonds.
          // Can only be used to create the PoS vault, i.e. Rev address = "1111gW5kkGxHg7xDg6dRkZx2f7qxTizJzaCH9VEM1oJKWRvSX9Sk5".
          for (@"createWithBalance", @"1111gW5kkGxHg7xDg6dRkZx2f7qxTizJzaCH9VEM1oJKWRvSX9Sk5", @amount, retCh <- RevVault) {
            new
              createVault,
              vaultCh
            in {
              _create!("1111gW5kkGxHg7xDg6dRkZx2f7qxTizJzaCH9VEM1oJKWRvSX9Sk5", *createVault, *vaultCh) |
              for (vaultRetCh <- createVault) {
                _makeVault!("1111gW5kkGxHg7xDg6dRkZx2f7qxTizJzaCH9VEM1oJKWRvSX9Sk5", amount, *vaultRetCh) |
                for (@eitherVault <- vaultCh) {
                  retCh!(eitherVault)
                }
              }
            }
          } |
          // Retrieves (revAddress, vault, logCh) corresponding to revAddress if one exists, creates a vault otherwise.
          // Returns either (true, vault) or (false, _) on retCh.
          contract _create(@revAddress, constructor, retCh) = {
            // The vault was not found, create a new one and set it in the vaultMap.
            new
              resCh,
              ackCh,
              logCh
            in {
              constructor!(*resCh) |
              for (@eitherVault <- resCh) {
                match eitherVault {
                  (true, vault) => {
                    // map `revAddress` to `(revAddress, vault, *logCh)`
                    new stdlog(`rho:io:stdlog`) in {stdlog!("info", ("_create get"))}|
                    TreeHashMap!("set", vaultMap, revAddress, (revAddress, vault, *logCh), *ackCh) |
                    for (_ <- ackCh) {
                      retCh!(eitherVault)
                    }
                  }
                  (false, _) => {
                    retCh!(eitherVault)
                  }
                }
              }
            }
          } |
          // Creates a Rev vault for `ownerRevAddress` containing a purse with `initialAmount`
          // and creates an associated transfer logging channel which is stored in `logChMap`
          // Returns vault Either on `ret`
          contract _makeVault(@ownerRevAddress, @initialAmount, ret) = {
            new
              revAddrCh,
              eitherRevAddrCh,
              purseCh,
              eitherPurseCh,
              mkVault
            in {
              @Either!("fromNillable", ownerRevAddress, "Required `revAddress` parameter was Nil", *eitherRevAddrCh) |
              mint!("makePurse", initialAmount, *purseCh) |
              @Either!("fromNillable <-", *purseCh, "Couldn't create purse", *eitherPurseCh) |
              @Either!("map2 <-", *eitherRevAddrCh, *eitherPurseCh,
                for (@addr, purse, r <- mkVault) {
                  new revVault in {
                    _newVault!(*revVault, addr, *purse) |
                    r!(bundle+{*revVault})
                  }
                },
                *ret
              )
            }
          } |
          // Supplies balance, transfer, and readEntry methods on `revVault`.
          contract _newVault(revVault, @fromRevAddress, purse) = {
            // Returns `revVault` balance on ret
            contract revVault(@"balance", ret) = {
              purse!("getBalance", *ret)
            } |
            // Transfers `amount` from `revVault` (validated with `authKey`) to the vault at `toRevAddress`
            // Returns either (true, Nil) or (false, "BUG FOUND: purse deposit failed") on `ret`
            // Logs successful transfers on a read-ony channel made available through "getLog" method
            contract revVault(@"transfer", @toRevAddress, @amount, authKey, ret) = {
              new ret2 in {
                _transferTemplate!(fromRevAddress, *purse, toRevAddress, amount, *authKey, *ret2) |
                new stdlog(`rho:io:stdlog`) in {stdlog!("info", ("transfer template"))}|
                for (@result <- ret2) {
                  if (result.nth(0)) {
                    new
                      bd(`rho:block:data`),
                      bdCh
                    in {
                      new stdlog(`rho:io:stdlog`) in {stdlog!("info", ("record history ", result))}|
                      bd!(*bdCh) |
                      for (@blockNumber, @timestamp, @sender <- bdCh) {
                        // Log the transfer in both vault logs with the same unique id
                        new id in {
                          // Record new log entry in both vault logs
                          match ("transfer",
                            { "id"     : *id,
                              "from"   : fromRevAddress,
                              "to"     : toRevAddress,
                              "amount" : amount,
                              "block"  : { "number" : blockNumber, "timestamp" : timestamp, "sender" : sender }
                            }
                          ) {
                            entryTuple => {
                              new
                                fromLogRet,
                                toLogRet
                              in {
                                new stdlog(`rho:io:stdlog`) in {stdlog!("info", (" history get", entryTuple))}|
                                // Lookup vault associated with `toRevAddress`
                                TreeHashMap!("get", vaultMap, toRevAddress, *toLogRet) |
                                // Lookup log channel associated with `fromRevAddress`
                                TreeHashMap!("get", vaultMap, fromRevAddress, *fromLogRet) |
                                for (@(_, _, *fromLogCh) <- fromLogRet &
                                     @(_, _, *toLogCh)   <- toLogRet) {
                                  new stdlog(`rho:io:stdlog`) in {stdlog!("info", (" history get done"))}|
                                  // Put the entry in both logs and return `result` on `ret`
                                  fromLogCh!(entryTuple) |
                                  toLogCh!(entryTuple) |
                                  ret!(result)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    // Unsuccessful transfers are not logged
                    ret!(result)
                  }
                }
              }
            } |
            // Returns an entry of the vault's log
            contract revVault(@"readLogEntry", ret) = {
              new thmRet in {
                // Lookup the log channel associated with `fromRevAddress`
                new stdlog(`rho:io:stdlog`) in {stdlog!("info", ("record log get"))}|
                TreeHashMap!("get", vaultMap, fromRevAddress, *thmRet) |
                for (@(_, _, *logCh) <- thmRet) {
                  // Read a transfer entry and return it on `ret`
                  for (@("transfer", entry) <<- logCh) {
                    ret!(entry)
                  }
                }
              }
            } |
            // Internal RevVault method for making a deposit from purse in `_revVault`
            contract @{fromRevAddress | bundle0{*_revVault}}(@"_deposit", depositPurse, retCh) = {
              _depositTemplate!(*purse, *depositPurse, *retCh)
            }
          } |
          // Checks all necessary validation and authentication prerequisites. If everything checks out,
          // `amount` is transferred from vault at `fromRevAddress` to vault at `toRevAddress`.
          contract _transferTemplate(@fromRevAddress, purse, @toRevAddress, @amount, authKey, ret) = {
            new
              revAddressValid,
              revAddressValidEither,
              amountNonNegative,
              authKeyValidCh,
              authKeyValidEitherCh,
              parametersOkCh,
              parametersAndAuthOkCh,
              split,
              eitherPurseCh,
              doDeposit
            in {
              // `toRevAddress` is validated
              RevAddress!("validate", toRevAddress, *revAddressValid) |
              @Either!("fromNillableError <-", *revAddressValid, *revAddressValidEither) |
              // `amount` is verified
              @Either!("fromBoolean", amount >= 0, "Amount must be positive value", *amountNonNegative) |
              // `authkey` is validated
              @AuthKey!("check", *authKey, (*_revVault, fromRevAddress), *authKeyValidCh) |
              @Either!("fromBoolean <-", *authKeyValidCh, "Invalid AuthKey", *authKeyValidEitherCh) |
              @Either!("productR <-", *revAddressValidEither, *amountNonNegative, *parametersOkCh) |
              @Either!("productR <-", *parametersOkCh, *authKeyValidEitherCh, *parametersAndAuthOkCh) |
              @Either!("flatMap <-", *parametersAndAuthOkCh, *split, *eitherPurseCh) |
              for (_, retCh <- split) {
                new amountPurseCh in {
                  // `revAddress`, `amount`, `authKey` are all valid
                  purse!("split", amount, *amountPurseCh) |
                  @Either!("fromSingletonList <-", *amountPurseCh, "Insufficient funds", *retCh)
                }
              } |
              @Either!("flatMap <-", *eitherPurseCh, *doDeposit, *ret) |
              for (@fromPurse, retCh <- doDeposit) {
                @{toRevAddress | bundle0{*_revVault}}!("_deposit", fromPurse, *retCh)
              }
            }
          } |
          // Deposits the entire balance in `fromPurse` to `toPurse`
          contract _depositTemplate(toPurse, fromPurse, retCh) = {
            new
              amountCh,
              depositSuccessCh
            in {
              fromPurse!("getBalance", *amountCh) |
              for (@amount <- amountCh) {
                // Calls purse deposit method in MakeMint contract; adds amount to `toPurse` and subtracts from `fromPurse`
                toPurse!("deposit", amount, *fromPurse, *depositSuccessCh) |
                // If successful, returns (true, Nil), otherwise returns (false, "BUG FOUND: purse deposit failed")
                @Either!("fromBoolean <-", *depositSuccessCh, "BUG FOUND: purse deposit failed", *retCh)
              }
            }
          } |
          // Inserts signed write-only RevVault contract into the registry
          rs!(
            "040f035630a5d2199184890b4b6b83440c842da0b6becca539f788f7b35d6e873561f673cd6ebe2e32236398a86f29dad992e8fba32534734300fcc5104bcfea0e".hexToBytes(),
            (9223372036854775807, bundle+{*RevVault}),
            "30450221008af89d676c4cd6b3d41e90da89b03a1e83f161fc8c4ad22c9edc903db3a9f4c402204e35e29e40a5f2b2f431d3cc63b87fb52c33716b3ce331a2a19b9660c3690c18".hexToBytes(),
            *uriOut
          )
        }
      }
    }
  }
}
