//scalapackage coop.rchain.rholang.mint

//based on http://erights.org/elib/capability/ode/ode-capabilities.html#simple-money
//requires NonNegativeNumber

new int2NN, MakeMint, NonNegativeNumber, StopGap(`rho:StopGap`), ack1, ack2, nnnret in {
  @(*StopGap, "set")!("MakeMint.int2NN", bundle+{int2NN}, *ack1) |
  @(*StopGap, "set")!("MakeMint", bundle+{MakeMint}, *ack2) |
  @(*StopGap, "get")!("NonNegativeNumber", *nnnret) |
  
  for(_ <- ack1; _ <- ack2; NonNegativeNumber <- nnnret) {
    contract int2NN(@x, return) = {
      new nnCh in {
        NonNegativeNumber!(x, *nnCh) | for(@nn <- nnCh) {
          return!(nn)
        }
      }
    } |
    contract MakeMint(return) = {
      new thisMint, internalMakePurse, decr in {
        contract @(*thisMint, "makePurse")(@init, return) = {
          new balanceCh in {
            int2NN!(init, *balanceCh) | for(@balance <- balanceCh) {
              internalMakePurse!(balance, *return)
            }
          }
        } |
        contract internalMakePurse(@balance, return) = {
          //balance must be a name that NonNegativeNumber contract is listening on
          new thisPurse in {
            contract @(*thisPurse, *decr)(@amount, success) = { @(balance, "sub")!(amount, *success) } |
            contract @(*thisPurse, "getBalance")(return) = { @(balance, "value")!(*return) } |
            contract @(*thisPurse, "sprout")(return) = { @(*thisMint, "makePurse")!(0, *return) } |
            contract @(*thisPurse, "split")(@amount, return) = {
              new destPurseCh, successCh in {
                @(*thisPurse, "sprout")!(*destPurseCh) | for(@destPurse <- destPurseCh) {
                  @(destPurse, "deposit")!(amount, *thisPurse, *successCh) |
                  for(@success <- successCh) {
                    if (success) {
                      return!([destPurse])
                    } else {
                      return!([])
                    }
                  }
                }
              }
            } |
            contract @(*thisPurse, "deposit")(@amount, @src, success) = {
              new result in {
                @(src, *decr)!(amount, *result) | //call src decr function.
                for(@decrSuccess <- result) {
                  if (decrSuccess) {
                    @(balance, "add")!(amount, *success) // add transferred amount to this purse
                  } else {
                    success!(false) 
                  }
                }
              }
            } |
            return!(*thisPurse)
          }
        } |
        return!(*thisMint)
      }
    }
  }
}

