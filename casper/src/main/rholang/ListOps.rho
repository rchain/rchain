//scalapackage coop.rchain.rholang.collection
new prepend, append, partialFold, fold, reverse, parMap, unorderedParMap,
    foreach, indexOf, zip, range, sgset(`rho:stopgap:set`), sgget(`rho:stopgap:get`),
    ack1, ack2, ack3, ack4, ack5, ack6, ack7, ack8, ack9, ack10, ack11 in {

  sgset!("ListOps.prepend", prepend}, *ack1) |
  sgset!("ListOps.append", append}, *ack2) |
  sgset!("ListOps.partialFold", partialFold}, *ack3) |
  sgset!("ListOps.fold", fold}, *ack4) |
  sgset!("ListOps.reverse", reverse}, *ack5) |
  sgset!("ListOps.parMap", parMap}, *ack6) |
  sgset!("ListOps.unorderedParMap", unorderedParMap}, *ack7) |
  sgset!("ListOps.foreach", foreach}, *ack8) |
  sgset!("ListOps.indexOf", indexOf}, *ack9) |
  sgset!("ListOps.zip", zip}, *ack10) |
  sgset!("ListOps.range", range}, *ack11) |

  for(_ <- ack1; _ <- ack2; _ <- ack3; _ <- ack4; _ <- ack5; _ <- ack6; 
      _ <- ack7; _ <- ack8; _ <- ack9; _ <- ack10; _ <- ack11) {
    contract prepend(@head, @tail, return) = {
      return!([head] ++ tail)
    } |
    contract append(@list, @element, return) = {
      return!(list ++ [element])
    } |

    //A fold over the list which breaks early if a condition is met.
    //Both the condition and combinator are are combined into a single
    //function which returns a [boolean, value] pair.
    //Use cases: see get and indexOf
    contract partialFold(@list, @start, combinatorAndCondition, return) = {
      new loop in {
        contract loop(@accumulatedValue, @lst) = {
          match lst {
            [head ...tail] => {
              new result in {
                combinatorAndCondition!(head, accumulatedValue, *result) |
                for (@done, @newValue <- result) {
                  if (done){ return!(done, newValue) }
                  else     { loop!(newValue, tail)   }
                }
              }
            }
            _ => { return!(false, accumulatedValue) }
          }
        } | loop!(start, list)
      }
    } |
    contract fold(@list, @start, combinator, return) = {
      new combinatorAndCondition in {
        contract combinatorAndCondition(@head, @accumulatedValue, return) = {
          new result in {
            combinator!(head, accumulatedValue, *result) |
            for(@r <- result){ return!(false, r) }
          }
        } |
        new result in {
          partialFold!(list, start, *combinatorAndCondition, *result) |
          for(_, @value <- result) {
            return!(value)
          }
        }
      }
    } |
    contract reverse(@list, return) = {
      fold!(list, [], *prepend, *return)
    } |
    contract map(@list, function, return) = {
      new combinator in {
        contract combinator(@head, @accumulatedValue, return) = {
          new mappedHead in {
            function!(head, *mappedHead) |
            for(@x <- mappedHead) {
              append!(accumulatedValue, x, *return)
            }
          }
        } | 
        fold!(list, [], *combinator, *return)
      }
    } |
    contract parMap(@list, function, return) = {
      new namesListCh, startProcess, getOutput in {
        contract startProcess(@x, ret) = { new outCh in { function!(x, *outCh) | ret!(*outCh) } } |
        contract getOutput(name, ret)  = { for(@result <- name){ ret!(result) } } |    

        //map each element to a name listening for the result of the function
        map!(list, *startProcess, *namesListCh) |
        for(@namesList <- namesListCh) {
          //map each name to its result
          map!(namesList, *getOutput, *return)
        }
      }
    } |
    contract unorderedParMap(@list, function, return) = {
      new mapLoop, collect, startCount, completeCount, accCh in {
        //Spawn processes, each computing one element
        //also processes listening for the result
        contract mapLoop(@l, @count)= {
          match l {
            [hd ...tl] => {
              new ch in { function!(hd, *ch) | for(@r <- ch){collect!(r)} | mapLoop!(tl, count + 1) }
            }
            _  => { startCount!(count) }
          }
        } |
        //add a result to our accumulating list
        contract collect(@result) = {
          for(@sc <- startCount; @cc <- completeCount; @acc <- accCh) {
            startCount!(sc) |
            if (sc == cc + 1) { //all started processes completed!
              prepend!(result, acc, *return)
            } else {            //still waiting on some
              completeCount!(cc + 1) |
              prepend!(result, acc, *accCh)
            }
          }
        } |
        match list {
          [] => { return!([]) }
          _  => { mapLoop!(list, 0) | completeCount!(0) | accCh!([]) }

        }
      }
    } |
    contract foreach(@list, proc, isDone) = {
      new combinator, nilReturn in {
        contract combinator(@head, @accumulatedValue, return) = {
          //Need return flag from `proc` in order to guarantee execution order
          new isDone in { proc!(head, *isDone) | for(_ <- isDone){ return!(Nil) } }
        } | 
        fold!(list, Nil, *combinator, *nilReturn) | for(_ <- nilReturn){ isDone!(true) }
      }
    } |
    contract indexOf(@list, @value, return) = {
      new combinatorAndCondition in {
        contract combinatorAndCondition(@head, @accumulatedValue, return) = {
          return!(head == value, accumulatedValue + 1)
        } |
        new result in {
          partialFold!(list, -1, *combinatorAndCondition, *result) |
          for(@valueFound, @i <- result) {
            if (valueFound) { return!(i)  }
            else            { return!(-1) }
          }
        }
      }
    } |
    contract zip(@list1, @list2, return) = {
      new loop in {
        contract loop(@pair, @acc, return) = {
          match pair {
            ([h1 ...t1], [h2 ...t2]) => {
              loop!((t1, t2), acc ++ [(h1, h2)], *return)
            }
            _ => {
              return!(acc)
            }
          }
        } |
        loop!((list1, list2), [], *return)
      }
    } |
    contract range(@start, @end, return) = {
      new loop in {
        contract loop(@i, @list) = {
          if(i < start) {
            return!(list)
          } else {
            loop!(i - 1, [i] ++ list)
          }
        } | loop!(end - 1, [])
      }
    }
  }
}
