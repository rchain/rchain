//scalapackage coop.rchain.rholang.collection

//Requires ListOps
//Represents Either[A, B] as ("Left", A) or ("Right", B)

new flatMap, map, compose, ack1, ack2, ack3, foldRet, sgset(`rho:stopgap:set`), 
    sgget(`rho:stopgap:get`) in {
  sgset!("Either.flatMap", *flatMap, *ack1) |
  sgset!("Either.map", *map, *ack2) |
  sgset!("Either.compose", *compose, *ack3) |
  sgget!("ListOps.fold", *foldret) |
  for (_ <- ack1; _ <- ack2; _ <- ack3; fold <- foldret) {
    //Right-biased flatMap; f must also return an Either
    contract flatMap(@either, f, return) = {
      match either {
        ("Right", value) => { f!(value, *return) }
        ("Left", _)      => { return!(either) }
      }
    } |
    //Right-biased map to transform an Either
    contract map(@either, f, return) = {
      match either {
        ("Right", value) => {
          new mappedResultCh in {
            f!(value, *mappedResultCh) |
            for(@mappedResult <- mappedResultCh) {
              return!(("Right", mappedResult))
            }
          }
        }
        ("Left", _) => return!(either)
      }
    } |

    //Composes a list of functions returning Either into a
    //single result by using flatMap. Similar to following Scala code:
    //for {
    //  r0 <- Right(input)
    //  r1 <- f1(r0)
    //  r2 <- f2(r1)
    //  ...
    //} yield fn
    contract compose(@input, @functions, return) = {
      new combinator, foldret in {
        contract combinator(@head, @accumulatedValue, return) = {
          flatMap!(accumulatedValue, head, *return)
        } |
        fold!(functions, ("Right", input), *combinator, *return)
      }
    }
  }
}
