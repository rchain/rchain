//scalapackage coop.rchain.rholang.wallet

// WalletCheck: holds funds until a public key with the given hash is presented,
//     then creates a wallet with that public key and those funds.

// create: makes a wallet check
//
// string ethAddr: the address of the funds on Ethereum (pre-issuance)
// Purse purse: the funds to put in the wallet
new create, publicToAddr, StopGap(`rho:StopGap`), ack1, ack2, bwret in {
  @(*StopGap, "set")!("WalletCheck.create", bundle+{*create}, *ack1) |
  @(*StopGap, "set")!("WalletCheck.publicToAddr", bundle+{*publicToAddr}, *ack2) |
  @(*StopGap, "get")!("BasicWallet", *bwret) |
  
  for (_ <- ack1; _ <- ack2; BasicWallet <- bwret) {
    contract create(@ethAddr, @purse) = {
      new doneStore in {
        doneStore!(false) |
    
        // claims the wallet by presenting the preimage of the hash
        //
        // string pubkey: Base16 encoded public key. It should be true that
        //                "0x" + Base16.encode(keccak256.hash(Base16.decode(pubkey)).takeRight(20)) == ethAddr
        // name statusOut
        // string sig: signature of [pubKey, statusOut]
        contract @ethAddr(@[pubKey, statusOut], @sig) = {
      
          // Make sure the purse hasn't already been claimed
          for (@done <- doneStore) {
            if (done) {
              doneStore!(done) |
              @statusOut!([false, "Already claimed wallet"])
            } else {

              // Verify signature 
              new verifiedOut, calcAddrOut, hashOut, 
                  keccak256Hash(`rho:crypto:keccak256Hash`),
                  secp256k1Verify(`rho:crypto:secp256k1Verify`) in {
                keccak256Hash!([pubKey, statusOut].toByteArray(), *hashOut) |
                for(@dataHash <- hashOut) {
                  //need to verify the signature using the provided plue 1 extra byte (for some reason...)
                  secp256k1Verify!(dataHash, sig.hexToBytes(), ("04" ++ pubKey).hexToBytes(), *verifiedOut) |
                  for (@verified <- verifiedOut) {
                    if (verified) {
                      // Check that given pubKey is the preimage of hash
                      publicToAddr!(pubKey, *calcAddrOut) |
                      for (@calcAddr <- calcAddrOut) {
                        //drop the "0x" from the Ethereum address then convert to bytes
                        if (calcAddr == ethAddr.slice(2, ethAddr.length()).hexToBytes()) {
                          new walletOut in {

                            // Create the wallet
                            BasicWallet!(purse, "secp256k1", "04" ++ pubKey, *walletOut) |

                            // Advertise the private name on a forgeable one
                            // TODO: This is completely insecure.  Once the
                            //   registry is done, use that.
                            for (@[wallet] <- walletOut) {
                              @pubKey!!(wallet) |
                        
                              // Return success
                              @statusOut!([true, wallet])
                            } |
                        
                            // All done
                            doneStore!(true)
                          }
                        } else {
                          doneStore!(done) |
                          @statusOut!([false, "Public key is not the preimage of hash"])
                        }
                      }
                    } else {
                      doneStore!(done) |
                      @statusOut!([false, "Signature verification failed"])
                    }
                  }
                }
              }
            }
          }
        }
      }
    } |

    //computes the ethereum address from a public key
    //string pubKey
    //returns bytearray
    contract publicToAddr(@pubKey, ret) = {
      new hashOut, keccak256Hash(`rho:crypto:keccak256Hash`) in {
        keccak256Hash!(pubKey.hexToBytes(), *hashOut) |
        for(@pkHash <- hashOut) {
          ret!(pkHash.slice(12, 32))
        }
      }
    }
  }
}