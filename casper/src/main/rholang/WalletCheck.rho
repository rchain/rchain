//scalapackage coop.rchain.rholang.wallet

// WalletCheck: holds funds until a public key with the given hash is presented,
//     then creates a wallet with that public key and those funds.

// create: makes a wallet check
//
// string ethAddr: the address of the funds on Ethereum (pre-issuance)
// Purse purse: the funds to put in the wallet
// ch(URN) return: the URN of the new wallet
// TODO(pyrocto): when crypto functions are moved to the rho:crypto namespace, update this.  It's insecure until then.

new mapStore, active in {
  mapStore!({}) |
  activeStore!(true) |
  contract EthWalletMap(@"get", @ethAddr, urnout) = {
    for (@map <- mapStore) {
      mapStore!(map) |
      urnOut!(map.get(ethAddr))
    }
  } |
  contract EthWalletMap(@"set", @ethAddr, @urn, ack) = {
    for (@map <- mapStore; @active <- activeStore) {
      activeStore!(active) |
      // Scales quadratically with the number of initial validators, but we only do it once.
      if (active) { mapStore!(map.set(ethAddr, urn)) }
      else {mapStore!(map) } |
      ack!()
    }
  } |
  // Need to call this at the end of the genesis deployment
  contract EthWalletMap(@"done", ack) = {
    for (_ <- activeStore) {
      activeStore!(false)
    }
  }
} |
contract WalletCheck(@"create", @ethAddr, @purse) = {
  new doneStore, ethWallet, ack, r(`rho:registry:insertArbitrary`) in {
    doneStore!(false) |

    new return, ack in {
      r!(bundle+{ethWallet}, return) |
      for (@urn <- return) {
        EthWalletMap("set", ethAddr, urn, *ack)
        for (<- ack) {

          // claims the wallet by presenting the preimage of the hash
          //
          // string pubkey: Base16 encoded public key. It should be true that
          //                "0x" + Base16.encode(keccak256.hash(Base16.decode(pubkey)).takeRight(20)) == ethAddr
          // name statusOut
          // string sig: signature of [pubKey, statusOut]
          contract ethWallet(@[pubKey, statusOut], @sig) = {

            // Make sure the purse hasn't already been claimed
            for (@done <- doneStore) {
              if (done) {
                doneStore!(done) |
                @statusOut!([false, "Already claimed wallet"])
              } else {

                // Verify signature 
                new verifiedOut, calcAddrOut, hashOut in {
                  @"keccak256Hash"!([pubKey, statusOut].toByteArray(), *hashOut) |
                  for(@dataHash <- hashOut) {
                    //need to verify the signature using the provided plue 1 extra byte (for some reason...)
                    @"secp256k1Verify"!(dataHash, sig.hexToBytes(), ("04" ++ pubKey).hexToBytes(), *verifiedOut) |
                    for (@verified <- verifiedOut) {
                      if (verified) {
                        // Check that given pubKey is the preimage of hash
                        publicToAddr!(pubKey, *calcAddrOut) |
                        for (@calcAddr <- calcAddrOut) {
                          //drop the "0x" from the Ethereum address then convert to bytes
                          if (calcAddr == ethAddr.slice(2, ethAddr.length()).hexToBytes()) {
                            new walletOut in {

                              // Create the wallet
                              BasicWallet!(purse, "secp256k1", "04" ++ pubKey, *walletOut) |

                              // Advertise the private name on a forgeable one
                              // TODO: This is completely insecure.  Once the
                              //   registry is done, use that.
                              for (@[wallet] <- walletOut) {
                                @pubKey!!(wallet) |

                                // Return success
                                @statusOut!([true, wallet])
                              } |

                              // All done
                              doneStore!(true)
                            }
                          } else {
                            doneStore!(done) |
                            @statusOut!([false, "Public key is not the preimage of hash"])
                          }
                        }
                      } else {
                        doneStore!(done) |
                        @statusOut!([false, "Signature verification failed"])
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
} |

//computes the ethereum address from a public key
//string pubKey
//returns bytearray
contract WalletCheck(@"publicToAddr", @pubKey, ret) = {
  new hashOut in {
    @"keccak256Hash"!(pubKey.hexToBytes(), *hashOut) |
    for(@pkHash <- hashOut) {
      ret!(pkHash.slice(12, 32))
    }
  }
}
