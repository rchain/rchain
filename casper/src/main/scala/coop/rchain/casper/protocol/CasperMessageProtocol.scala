package coop.rchain.casper.protocol

trait CasperMessageProtocol {
  import FromPacket.protoImpl
  import ToPacket.protoSerde

  implicit final val blockMessageFromPacket =
    protoImpl[PacketTypeTag.BlockMessage.type, BlockMessageProto]
  implicit final val approvedBlockFromPacket =
    protoImpl[PacketTypeTag.ApprovedBlock.type, ApprovedBlockProto]
  implicit final val approvedBlockRequestFromPacket =
    protoImpl[PacketTypeTag.ApprovedBlockRequest.type, ApprovedBlockRequestProto]
  implicit final val blockRequestFromPacket =
    protoImpl[PacketTypeTag.BlockRequest.type, BlockRequestProto]
  implicit final val hasBlockRequestFromPacket =
    protoImpl[PacketTypeTag.HasBlockRequest.type, HasBlockRequestProto]
  implicit final val hasBlockFromPacket = protoImpl[PacketTypeTag.HasBlock.type, HasBlockProto]
  implicit final val forkChoiceTipRequestFromPacket =
    protoImpl[PacketTypeTag.ForkChoiceTipRequest.type, ForkChoiceTipRequestProto]
  implicit final val blockApprovalFromPacket =
    protoImpl[PacketTypeTag.BlockApproval.type, BlockApprovalProto]
  implicit final val unapprovedBlockFromPacket =
    protoImpl[PacketTypeTag.UnapprovedBlock.type, UnapprovedBlockProto]
  implicit final val noApprovedBlockFromPacket =
    protoImpl[PacketTypeTag.NoApprovedBlockAvailable.type, NoApprovedBlockAvailableProto]

  // we don't need those at all  can be autogeneratedd by "protoSerde" but caching them could be beneficial for performance
  implicit final val blockMessageToPacket =
    protoSerde[PacketTypeTag.BlockMessage.type, BlockMessageProto]
  implicit final val approvedBlockToPacket =
    protoSerde[PacketTypeTag.ApprovedBlock.type, ApprovedBlockProto]
  implicit final val approvedBlockRequestToPacket =
    protoSerde[PacketTypeTag.ApprovedBlockRequest.type, ApprovedBlockRequestProto]
  implicit final val blockRequestToPacket =
    protoSerde[PacketTypeTag.BlockRequest.type, BlockRequestProto]
  implicit final val hasBlockRequestToPacket =
    protoSerde[PacketTypeTag.HasBlockRequest.type, HasBlockRequestProto]
  implicit final val hasBlockToPacket = protoSerde[PacketTypeTag.HasBlock.type, HasBlockProto]
  implicit final val forkChoiceTipRequestToPacket =
    protoSerde[PacketTypeTag.ForkChoiceTipRequest.type, ForkChoiceTipRequestProto]
  implicit final val blockApprovalToPacket =
    protoSerde[PacketTypeTag.BlockApproval.type, BlockApprovalProto]
  implicit final val unapprovedBlockToPacket =
    protoSerde[PacketTypeTag.UnapprovedBlock.type, UnapprovedBlockProto]
  implicit final val noApprovedBlockToPacket =
    protoSerde[PacketTypeTag.NoApprovedBlockAvailable.type, NoApprovedBlockAvailableProto]
}
