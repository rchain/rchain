package coop.rchain.casper.protocol

trait CasperMessageProtocol {
  import FromPacket.protoImpl
  import ToPacket.protoSerde

  implicit final val blockMessageFromPacket =
    protoImpl[PacketTypeTag.BlockMessage.type, BlockMessageProto]
  implicit final val blockHashMessageFromPacket =
    protoImpl[PacketTypeTag.BlockHashMessage.type, BlockHashMessageProto]
  implicit final val approvedBlockFromPacket =
    protoImpl[PacketTypeTag.ApprovedBlock.type, ApprovedBlockProto]
  implicit final val approvedBlockRequestFromPacket =
    protoImpl[PacketTypeTag.ApprovedBlockRequest.type, ApprovedBlockRequestProto]
  implicit final val blockRequestFromPacket =
    protoImpl[PacketTypeTag.BlockRequest.type, BlockRequestProto]
  implicit final val hasBlockRequestFromPacket =
    protoImpl[PacketTypeTag.HasBlockRequest.type, HasBlockRequestProto]
  implicit final val hasBlockFromPacket = protoImpl[PacketTypeTag.HasBlock.type, HasBlockProto]
  implicit final val forkChoiceTipRequestFromPacket =
    protoImpl[PacketTypeTag.ForkChoiceTipRequest.type, ForkChoiceTipRequestProto]
  implicit final val blockApprovalFromPacket =
    protoImpl[PacketTypeTag.BlockApproval.type, BlockApprovalProto]
  implicit final val unapprovedBlockFromPacket =
    protoImpl[PacketTypeTag.UnapprovedBlock.type, UnapprovedBlockProto]
  implicit final val noApprovedBlockFromPacket =
    protoImpl[PacketTypeTag.NoApprovedBlockAvailable.type, NoApprovedBlockAvailableProto]
  // Last finalized state messages
  implicit final val storeItemsMessageRequestFromPacket =
    protoImpl[PacketTypeTag.StoreItemsMessageRequest.type, StoreItemsMessageRequestProto]
  implicit final val storeItemsMessageFromPacket =
    protoImpl[PacketTypeTag.StoreItemsMessage.type, StoreItemsMessageProto]

  // we don't need those at all  can be autogeneratedd by "protoSerde" but caching them could be beneficial for performance
  implicit final val blockHashMessageToPacket =
    protoSerde[PacketTypeTag.BlockHashMessage.type, BlockHashMessageProto]
  implicit final val blockMessageToPacket =
    protoSerde[PacketTypeTag.BlockMessage.type, BlockMessageProto]
  implicit final val approvedBlockToPacket =
    protoSerde[PacketTypeTag.ApprovedBlock.type, ApprovedBlockProto]
  implicit final val approvedBlockRequestToPacket =
    protoSerde[PacketTypeTag.ApprovedBlockRequest.type, ApprovedBlockRequestProto]
  implicit final val blockRequestToPacket =
    protoSerde[PacketTypeTag.BlockRequest.type, BlockRequestProto]
  implicit final val hasBlockRequestToPacket =
    protoSerde[PacketTypeTag.HasBlockRequest.type, HasBlockRequestProto]
  implicit final val hasBlockToPacket = protoSerde[PacketTypeTag.HasBlock.type, HasBlockProto]
  implicit final val forkChoiceTipRequestToPacket =
    protoSerde[PacketTypeTag.ForkChoiceTipRequest.type, ForkChoiceTipRequestProto]
  implicit final val blockApprovalToPacket =
    protoSerde[PacketTypeTag.BlockApproval.type, BlockApprovalProto]
  implicit final val unapprovedBlockToPacket =
    protoSerde[PacketTypeTag.UnapprovedBlock.type, UnapprovedBlockProto]
  implicit final val noApprovedBlockToPacket =
    protoSerde[PacketTypeTag.NoApprovedBlockAvailable.type, NoApprovedBlockAvailableProto]
  // Last finalized state messages
  implicit final val storeItemsMessageRequestToPacket =
    protoSerde[PacketTypeTag.StoreItemsMessageRequest.type, StoreItemsMessageRequestProto]
  implicit final val storeItemsMessageToPacket =
    protoSerde[PacketTypeTag.StoreItemsMessage.type, StoreItemsMessageProto]
}
