//scalapackage coop.rchain.rholang.unittest

//requires ListOps
contract @"delayForCh"(@n, notHangingCh, done) = {
  for(@notHanging <- notHangingCh) {
    if(notHanging == false) {
      notHangingCh!(notHanging) | // put back to keep it there for the next call (if false)
      if(n == 0) {
       done!(false) // false if notHanging never set to true
      }
      else {
        @"delayForCh"!(n - 1, *notHangingCh, *done)
      }
    }
    else {
      done!(true) // true if notHanging is set to true
    }
  }
} |
contract @"TestSet"(desc, @tests) = {
  new addTests, execTests, testsCh in {
    contract execTests(return) = {
      new combinator in {
        contract combinator(head, @accumulatedValue, return) = {
          new result in {
            head!(*result) |
            for(@r <- result) {
              match [r, accumulatedValue] {
                [true, true] => return!(true)
                _            => return!(false)
              }
            }
          }
        } |
        for(@tests <- testsCh) {
          @("ListOps", "fold")!(tests, true, *combinator, *return)
        }
      }
    } |
    contract addTests(@tests) = {
      new toContract in {
        contract toContract(@test, return) = {
          match test {
            [functionCh, answer] => {
              new tContract, notHangingCh, delayCh in {
                contract tContract(return) = {
                  for (function <- @functionCh) {
                    @functionCh!(*function) | //put back for possible re-use
                    new result in {
                      function!(*result) |
                      @"delayForCh"!(40, *notHangingCh, *delayCh) |
                      notHangingCh!(false) | // initialize notHanging
                      for(@r <- result) {
                        for(_ <- notHangingCh) { // throw away false
                          notHangingCh!(true) | // add true - we have a result so no hanging return
                          return!(r==answer)
                        }
                      }
                    } |
                    for(@hanging<-delayCh) {
                      if(hanging==false) { // delay finished with hanging return
                        return!(answer=="hanging return")
                      }
                    }
                  }
                } |
                return!(*tContract)
              }
            }
          }
        } |
        @("ListOps", "map")!(tests, *toContract, *testsCh)
      }
    } |
    addTests!(tests) |
    execTests!(*desc)
  }
} |
contract @("TestSet", "after")(desc, continuation) = {
  for(@result <- desc) {
    if (result) {
      desc!(result) | { *continuation }
    } else {
      desc!(result)
    }
  }
}
