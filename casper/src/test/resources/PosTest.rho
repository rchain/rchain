//scalapackage coop.rchain.rholang.mint

//requires Pos, RhoSpec

let
  @posPubKey, @posVaultPubKey <-
    "047b43d6548b72813b89ac1b9f9ca67624a8b372feedd71d4e2da036384a3e1236812227e524e6f237cde5f80dbb921cac12e6500791e9a9ed1254a745a816fe1f".hexToBytes(),
    "04a7808009ad157bec658c8d35055f21f34dc866566d2f4b874600bb8782c20af9ae2cf90420e6f0a9c683358aea1b659d344737481fc0957de4e63485d044ee80".hexToBytes() &
  @user0, @user1, @user2, @user3, @user4, @user5, @user6, @user7, @user8, @user9,
  @userA, @userB, @userC, @userD, @userE, @userF, @user12, @user13, @user14 <-
    "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222",
    "3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333",
    "4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444",
    "5555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555",
    "6666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666",
    "7777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777",
    "8888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888",
    "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999",
    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
    "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
    "cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc",
    "dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd",
    "eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
    "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
    "1212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212",
    "1313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313",
    "1414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414"
 in {
    new
      rl(`rho:registry:lookup`),
      makeSysAuthToken(`sys:test:authToken:make`),
      sysAuthTokenCh,
      stdlog(`rho:io:stdlog`),
      revAddressOps(`rho:rev:address`),
      posRevAddressCh, posVaultCh,
      RhoSpecCh, PoSCh, RevVaultCh, ListOpsCh,
      setup, prepareUser,
      test_make_pos_succeeds,
      test_close_block_finishes,
      test_bonding_succeeds,
      test_withdraw_succeeds,
      test_validator_is_paid_after_withdraw,
      test_multiple_bonding_succeeds,
      test_bonding_fails_if_deposit_fails,
      test_bonding_fails_if_already_bonded,
      test_bonding_fails_if_bond_too_small,
      test_pay_succeeds,
      test_refund_succeeds,
      test_commit_random,
      test_dont_reward_inactive_validators,
      test_bonding_failure,
      test_slashing_vaults_and_state,
      test_bonding_fails_if_not_in_whitelist,
      test_bonding_fails_if_removed_from_whitelist,
      test_bonding_fails_if_stake_is_not_the_same_as_whitelist,
      test_epoch_change_on_setting_epoch_block,
      test_pos_params_only_updated_with_proper_authority_and_type,
      getPosBalance, getCoopBalance,
      closeBlock, fmt_expect, getPosData,
      makeDeployerId(`rho:test:deployerId:make`),
      bondWithAddingBondingRequest,
      deployerIdCh, set_context
    in {
      makeDeployerId!("deployerId", posVaultPubKey, *deployerIdCh) |
      revAddressOps!("fromPublicKey", posPubKey, *posRevAddressCh) |
      rl!(`rho:rchain:revVault`, *RevVaultCh) |
      rl!(`rho:rchain:pos`, *PoSCh) |
      rl!(`rho:lang:listOps`, *ListOpsCh) |
      rl!(`rho:id:zphjgsfy13h1k85isc8rtwtgt3t9zzt5pjd5ihykfmyapfc4wt3x5h`, *RhoSpecCh) |
      makeSysAuthToken!(*sysAuthTokenCh) |
      for(@(_, RhoSpec)      <- RhoSpecCh &
          @(_, PoS)          <- PoSCh &
          @(_, RevVault)     <- RevVaultCh &
          @posRevAddress     <- posRevAddressCh &
          @(_, ListOps)      <- ListOpsCh &
          @sysAuthToken      <- sysAuthTokenCh  & 
          posVaultDeployerId <- deployerIdCh) {
        stdlog!("info", {"posRevAddress" : posRevAddress}) |
        @PoS!("getInitialPosVault", *posVaultCh) |
        for (@(posAddr, posVault) <- posVaultCh) {
          @RhoSpec!("testSuite", *setup,
            [
              ("PoS is created with empty rewards", *test_make_pos_succeeds),
              ("epoch change should happen successfully on setting block", *test_epoch_change_on_setting_epoch_block),
              ("closeBlock finishes successfully", *test_close_block_finishes),
              ("bonding success", *test_bonding_succeeds),
              ("withdraw succeeds", *test_withdraw_succeeds),
              ("validator is paid after withdraw", *test_validator_is_paid_after_withdraw),
              ("bonding fails if deposit fails", *test_bonding_fails_if_deposit_fails),
              ("multiple bondings work", *test_multiple_bonding_succeeds),
              ("payment works", *test_pay_succeeds),
              ("payment refund works", *test_refund_succeeds),
              ("bonding fails if already bonded", *test_bonding_fails_if_already_bonded),
              ("bonding fails if bond is too small", *test_bonding_fails_if_bond_too_small),
              ("payment is not distributed to inactive validators", *test_dont_reward_inactive_validators),
              ("bonding fails if the requester not in the white list", *test_bonding_fails_if_not_in_whitelist),
              ("bonding fails if the requester is removed in the white list", *test_bonding_fails_if_removed_from_whitelist),
              ("bonding fails if the bonding request is not euqal to the stake in white list", *test_bonding_fails_if_stake_is_not_the_same_as_whitelist),
              // TODO we should reimplement the random test in the future when it is available
              // ("commited random matches its image", *test_commit_random),
              ("slashing transfers funds appropriately", *test_slashing_vaults_and_state),
              ("PoS params fail to update with invalid authority and types", *test_pos_params_only_updated_with_proper_authority_and_type)
            ]
          ) |

          contract setup(_, retCh) = {
            retCh!({})
          } |

          contract fmt_expect(@a, @b, @c, retCh) = {
            if (b == Nil) {
              retCh!("(${a}, Nil, ${c})" %% { "a": a, "c": c})
            } else {
              retCh!("(${a}, ${b}, ${c})" %% { "a": a, "b": b, "c": c})
            }
          } |

          contract prepareUser(@pk, retCh) = {
            stdlog!("info", ("preparing user ", pk)) |
            new deployerIdCh, revAddrCh, vaultCh
            in {
              revAddressOps!("fromPublicKey", pk.hexToBytes(), *revAddrCh) |
              makeDeployerId!("deployerId", pk.hexToBytes(), *deployerIdCh) |
              for (@revAddress <- revAddrCh &
                   @deployerId <- deployerIdCh) {
                @RevVault!("findOrCreate", revAddress, *vaultCh) |
                for (@(true, vault) <- vaultCh) {
                  retCh!(pk.hexToBytes(), revAddress, vault, deployerId)
                }
              }
            }
          } |

          contract set_context(doneCh) = {
            new setBlockData(`rho:test:block:data:set`), blockDataCh in {
              setBlockData!("blockNumber", 1, *blockDataCh) |
              for (_ <- blockDataCh) {
                doneCh!(Nil)
              }
            }
          } |

          contract test_make_pos_succeeds(rhoSpec, _, ackCh) = {
            new bondsCh, rewardsCh, rewardsZeroCh, rewardsZeroPred in {
              @PoS!("getBonds", *bondsCh) |
              @PoS!("getRewards", *rewardsCh) |
              for (@bonds   <- bondsCh &
                   @rewards <- rewardsCh) {
                @ListOps!("forall", rewards.toList(), *rewardsZeroPred, *rewardsZeroCh) |
                contract rewardsZeroPred(@(_, reward), resultCh) = {
                  resultCh!(reward == 0)
                } |
                rhoSpec!("assertMany",
                  [
                    (bonds.size() >= 0, "some bonds map should be received"),
                    ((true, "== <-", *rewardsZeroCh), "no rewards yet")
                  ],
                  *ackCh
                )
              }
            }
          } |
          // Tests that close block finishes on non epoch change block number and on epoch change block number.
          contract test_close_block_finishes(rhoSpec, _, ackCh) = {
            new closeCh, setBlockData(`rho:test:block:data:set`), expCh,
                blockDataCh, epochLengthCh, epochBlockNumberCh, getBlockData(`rho:block:data`)
            in {
              set_context!(*blockDataCh) |
              for (_ <- blockDataCh) {
                let @initBlock <- 1 &
                    @targetEpochBlock <- 1001
                in {
                  @PoS!("getEpochLength", *epochLengthCh) |
                  // set epoch block number to targetEpochBlock
                  @PoS!("setEpochBlockNumber", *posVaultDeployerId, targetEpochBlock, *epochBlockNumberCh) |
                  for (@epochLength <- epochLengthCh & @setRes <- epochBlockNumberCh) {
                    // non epoch change closeBlock
                    setBlockData!("blockNumber", initBlock, *blockDataCh) |
                    for (_ <- blockDataCh) {
                      closeBlock!(*closeCh) |
                      for (@closeRes1 <- closeCh) {
                        // epoch change closeBlock
                        setBlockData!("blockNumber", targetEpochBlock, *blockDataCh) |
                        for (_ <- blockDataCh) {
                          closeBlock!(*closeCh) |
                          for (@closeRes2 <- closeCh) {
                            fmt_expect!(initBlock, targetEpochBlock, epochLength, *expCh) |
                            for (@expect <- expCh) {
                              rhoSpec!("assertMany",
                                [
                                  ((setRes, "==", (true, Nil)), "set epoch block number succeeds"),
                                  ((closeRes1.nth(0), "==", true), "no epoch on init block"),
                                  ((closeRes2.nth(0), "==", true), "epoch change on targetEpochBlock"),
                                  ((closeRes1.nth(1), "==", expect), "no epoch on non epoch block 1"),
                                  ((closeRes2.nth(1), "==", Nil), "epoch on epoch block 1"),
                                ],
                                *ackCh
                              )
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } |
          // test the PoS "setEpochBlockNumber" method
          contract test_epoch_change_on_setting_epoch_block(rhoSpec, _, ackCh) = {
            new closeCh, setBlockData(`rho:test:block:data:set`),
                epochBlockCh, epochLengthCh, blockDataCh, blockDataCh, setEpochRet
            in {
              set_context!(*blockDataCh) |
              for (_ <- blockDataCh) {
                let @targetEpochBlock <- 100 in {
                  // first get the initial epoch block number to reset later - should be Nil
                  @PoS!("getEpochBlockNumber", *epochBlockCh) |
                  @PoS!("getEpochLength", *epochLengthCh) |
                  for (@initialEpochBlock <- epochBlockCh &
                      @epochLength       <- epochLengthCh) {
                    // non epoch change closeBlock
                    setBlockData!("blockNumber", targetEpochBlock - 1, *blockDataCh) |
                    for (_ <- blockDataCh) {
                      closeBlock!(*closeCh) |
                      for (@closeRes1 <- closeCh) {
                        // epoch change closeBlock
                        setBlockData!("blockNumber", targetEpochBlock, *blockDataCh) |
                        @PoS!("setEpochBlockNumber", *posVaultDeployerId, targetEpochBlock, *setEpochRet) |
                        for (_ <- setEpochRet & _ <- blockDataCh) {
                          @PoS!("getEpochBlockNumber", *epochBlockCh) |
                          closeBlock!(*closeCh) |
                          for (@closeRes2 <- closeCh & @finalEpochBlock <- epochBlockCh) {
                            // format expect
                            fmt_expect!(targetEpochBlock - 1, initialEpochBlock, epochLength, *blockDataCh) |
                            for (@expect <- blockDataCh) {
                              rhoSpec!("assertMany",
                                [
                                  ((finalEpochBlock, "==", targetEpochBlock), "setting epoch block with correct deployId changes the number"),
                                  ((closeRes1.nth(0), "==", true), "first closeBlock works"),
                                  ((closeRes2.nth(0), "==", true), "second closeBlock works"),                              
                                  ((closeRes1.nth(1), "==", expect), "epoch block would not happen before setting epoch block number"),
                                  ((closeRes2.nth(1), "==", Nil), "epoch block would happen after setting epoch block number"),
                                ],
                                *ackCh
                              )
                            }
                          }
                        }
                      }
                    }
                  }              
                }
              }
            }
          } |
          // test setting PoS parameters with invalid deploy id and invalid types
          contract test_pos_params_only_updated_with_proper_authority_and_type(rhoSpec, _, ackCh) = {
            new epochBlockCh, setEpochRet, setupCh, setBlockData(`rho:test:block:data:set`), blockDataCh in {
              prepareUser!(userF, *setupCh) |
              for (_, _, _, @userDeployerId <- setupCh) {
                // non-pos attempts to set epoch block number - should fail
                @PoS!("getEpochBlockNumber", *epochBlockCh) |
                @PoS!("setEpochBlockNumber", userDeployerId, 42, *setEpochRet) |
                for (@setRes1 <- setEpochRet & @epochBlock0 <- epochBlockCh) {
                  // pos attempts to set string epoch block number - should fail
                  @PoS!("getEpochBlockNumber", *epochBlockCh) |
                  @PoS!("setEpochBlockNumber", *posVaultDeployerId, "42", *setEpochRet) |
                  for (@setRes2 <- setEpochRet & @epochBlock1 <- epochBlockCh) {
                    // pos attempts to set list epoch block number - should fail
                    @PoS!("getEpochBlockNumber", *epochBlockCh) |
                    @PoS!("setEpochBlockNumber", *posVaultDeployerId, [42], *setEpochRet) |
                    for (@setRes3 <- setEpochRet & @epochBlock2 <- epochBlockCh) {
                      // pos sets epoch block number to current block number - should succeed
                      let @blockNumber <- 42 in {
                        @PoS!("getEpochBlockNumber", *epochBlockCh) |
                        setBlockData!("blockNumber", blockNumber, *blockDataCh) |
                        @PoS!("setEpochBlockNumber", *posVaultDeployerId, blockNumber, *setEpochRet) |
                        for (_            <- blockDataCh &
                             @setRes4     <- setEpochRet &
                             @epochBlock3 <- epochBlockCh) {
                          stdlog!("info", ("get", "set", blockNumber)) |
                          // pos attempts to set epoch block number in the past - should fail
                          @PoS!("getEpochBlockNumber", *epochBlockCh) |
                          @PoS!("setEpochBlockNumber", *posVaultDeployerId, blockNumber - 1, *setEpochRet) |
                          for (@setRes5 <- setEpochRet & @epochBlock4 <- epochBlockCh) {
                            @PoS!("getEpochBlockNumber", *epochBlockCh) |
                            for (@epochBlock5 <- epochBlockCh) {
                              let @expect <-
                                    "new PoS epoch block number ${1} cannot come before current block ${2}"
                                      %% {"1": blockNumber - 1, "2": blockNumber}
                              in {
                                rhoSpec!("assertMany",
                                  [
                                    // set success
                                    ((setRes1.nth(0), "==", false), "set epoch block number should fail for non-Pos identity"),
                                    ((setRes2.nth(0), "==", false), "set epoch block number should fail for string"),
                                    ((setRes3.nth(0), "==", false), "set epoch block number should fail for list"),
                                    ((setRes4.nth(0), "==", true), "set epoch block number should succeed"),
                                    ((setRes5.nth(0), "==", false), "set epoch block number should fail in the past"),
                                    // set results
                                    ((setRes1.nth(1), "==", "Invalid authority to set PoS epoch block number"), "get authority error message"),
                                    ((setRes2.nth(1), "==", "PoS epoch block number must be an integer or Nil"), "get type error message 1"),
                                    ((setRes3.nth(1), "==", "PoS epoch block number must be an integer or Nil"), "get type error message 2"),
                                    ((setRes4.nth(1), "==", Nil), "set epoch block number to given"),
                                    ((setRes5.nth(1), "==", expect), "set epoch block number in the past"),
                                    // epoch block numbers
                                    ((Set(epochBlock1, epochBlock2, epochBlock3), "==", Set(epochBlock0)), "epoch block number should not change"),
                                    ((epochBlock4, "==", epochBlock5), "epoch block number should not change when set fails"),
                                  ],
                                  *ackCh
                                )
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } |

          // Tests that a user's bond is added to the bonds map properly and all balances change accordingly.
          contract test_bonding_succeeds(rhoSpec, _, ackCh) = {
            new setupCh, retCh, initialPosBalanceCh, finalPosBalanceCh,
                initialUserBalanceCh, finalUserBalanceCh,
                initialCoopBalanceCh, finalCoopBalanceCh,
                initialBondsCh, finalBondsCh, rewardsCh,
                addBondReqCh
            in {
              prepareUser!(user1, *setupCh) |
              for (@userPubKey, _, @userVault, @userDeployerId <- setupCh) {
                let @bondAmt <- 100  in {
                  getPosBalance!(*initialPosBalanceCh) |
                  getCoopBalance!(*initialCoopBalanceCh) |
                  @userVault!("balance", *initialUserBalanceCh) |
                  @PoS!("getBonds", *initialBondsCh) |
                  @PoS!("addBondingRequest", *posVaultDeployerId, user1, bondAmt, *addBondReqCh) |
                  for (@initialPosBalance  <- initialPosBalanceCh &
                       @initialUserBalance <- initialUserBalanceCh &
                       @initialCoopBalance <- initialCoopBalanceCh &
                       @initialBonds       <- initialBondsCh &
                       @addBondingReqRes   <- addBondReqCh) {
                    @PoS!("bond", userDeployerId, bondAmt, *retCh) |
                    for (@bondRes <- retCh) {
                      @PoS!("getBonds", *finalBondsCh) |
                      getPosBalance!(*finalPosBalanceCh) |
                      getCoopBalance!(*finalCoopBalanceCh) |
                      @userVault!("balance", *finalUserBalanceCh) |
                      @PoS!("getRewards", *rewardsCh) |
                      for (@finalPosBalance  <- finalPosBalanceCh &
                           @finalUserBalance <- finalUserBalanceCh &
                           @finalCoopBalance <- finalCoopBalanceCh &
                           @finalBonds       <- finalBondsCh &
                           @rewards          <- rewardsCh) {
                        rhoSpec!("assertMany",
                          [
                            ((addBondingReqRes.nth(0), "==", true), "add bonding request should be true"),
                            ((bondRes.nth(0), "==", true), "the bonding result should be true"),
                            ((bondAmt, "==", finalBonds.get(userPubKey)), "the user's bond is expected in the final map"),
                            ((bondAmt, "==", initialUserBalance - finalUserBalance), "the user account decreases accordingly"),
                            ((bondAmt, "==", finalPosBalance - initialPosBalance), "the PoS account increases accordingly"),
                            ((finalCoopBalance, "==", initialCoopBalance), "Coop vault balance does not change"),
                            ((Nil, "==", initialBonds.get(userPubKey)), "the user's bond is not expected in the initial map"),
                            ((0, "==", rewards.getOrElse(userPubKey, 0)), "new validator should not have any rewards")
                          ],
                          *ackCh
                        )
                      }
                    }
                  }
                }
              }
            }
          } |
          contract getPosData(userBalanceCh, userVault, posBalanceCh, bondsCh, rewardsCh) = {
            getPosBalance!(*posBalanceCh) |
            userVault!("balance", *userBalanceCh) |
            @PoS!("getBonds", *bondsCh) |
            @PoS!("getRewards", *rewardsCh)
          } |
          // Tests that when a user requests to bond, they are added to the bond map with the appropriate bond stake.
          // Rewards shouldn't change with a bond request because these funds are just accumulated into the PoS vault during closeBlock.
          // The user's balance should decrease by the bond amount after their bonding request is processed.
          // After withdrawing, the validator should be moved to the withdrawers map with the appropriate quarantine period.
          // Caution: there is interaction between this test and test_withdraw_succeeds because block numbers are manipulated.
          contract test_withdraw_succeeds(rhoSpec, _, ackCh) = {
            new setupCh, bondCh, posBalanceCh,
                userBalanceCh, rewardsCh, bondsCh,
                withdrawCh, closeBlockCh, quarantineCh, epochCh,
                withdrawersCh, setBlockData(`rho:test:block:data:set`),
                blockDataCh, addBondReqCh, epochBlockCh, pWithdrawersCh
            in {
              set_context!(*blockDataCh) |
              for (_ <- blockDataCh) {
                prepareUser!(userA, *setupCh) |
                for (@userPubKey, _, userVault, @userDeployerId <- setupCh) {
                  let @initBlock <- 1 in {
                    @PoS!("getEpochLength", *epochCh) |
                    @PoS!("getQuarantineLength", *quarantineCh) |
                    setBlockData!("blockNumber", initBlock, *blockDataCh) |
                    getPosData!(*userBalanceCh, *userVault, *posBalanceCh, *bondsCh, *rewardsCh) |
                    for (@posBalance0 <- posBalanceCh &
                        @balance0    <- userBalanceCh &
                        @bonds0      <- bondsCh &
                        @rewards0    <- rewardsCh &
                        @epochLength <- epochCh &
                        @qLength     <- quarantineCh &
                        _            <- blockDataCh) {
                      let @bondAmt <- 100 &
                          // assumes withdraw occurs in initBlock
                          @qPeriod <- qLength + epochLength * (1 + initBlock / epochLength)
                      in {
                        @PoS!("addBondingRequest", *posVaultDeployerId, userA, bondAmt, *addBondReqCh) |
                        for (@addBondRes <- addBondReqCh) {
                          // bond in initBlock
                          @PoS!("bond", userDeployerId, bondAmt, *bondCh) |
                          for (@bondRes <- bondCh) {
                            // get intermediate PoS data
                            getPosData!(*userBalanceCh, *userVault, *posBalanceCh, *bondsCh, *rewardsCh) |
                            for (@bonds1      <- bondsCh &
                                 @rewards1    <- rewardsCh &
                                 @balance1    <- userBalanceCh &
                                 @posBalance1 <- posBalanceCh) {
                              // withdraw in initBlock
                              @PoS!("withdraw", userDeployerId, *withdrawCh) |
                              for (_ <- withdrawCh) {
                                // user should not be in withdrawers map
                                // user should be in pending withdrawers map
                                @PoS!("getWithdrawers", *withdrawersCh) |
                                @PoS!("getPendingWithdrawers", *pWithdrawersCh) |
                                for (@withdrawers1 <- withdrawersCh & @pWithdrawers1 <- pWithdrawersCh) {
                                  // set epoch block number to before quarantine expiry
                                  @PoS!("setEpochBlockNumber", *posVaultDeployerId, qPeriod - 1, *epochBlockCh) |
                                  // epoch change before quarantine expiry
                                  // user should remain in withdrawers map
                                  // user should not be in pending withdrawers map
                                  setBlockData!("blockNumber", qPeriod - 1, *blockDataCh) |
                                  for (_ <- blockDataCh & _ <- epochBlockCh) {
                                    closeBlock!(*closeBlockCh) |
                                    for (@(true, _) <- closeBlockCh) {
                                      @PoS!("getWithdrawers", *withdrawersCh) |
                                      @PoS!("getPendingWithdrawers", *pWithdrawersCh) |
                                      getPosData!(*userBalanceCh, *userVault, *posBalanceCh, *bondsCh, *rewardsCh) |
                                      for (@posBalance2   <- posBalanceCh &
                                           @balance2      <- userBalanceCh &
                                           @bonds2        <- bondsCh &
                                           @rewards2      <- rewardsCh &
                                           @withdrawers2  <- withdrawersCh &
                                           @pWithdrawers2 <- pWithdrawersCh) {
                                        @PoS!("setEpochBlockNumber", *posVaultDeployerId, qPeriod + 1, *epochBlockCh) |
                                        // epoch change after quarantine expiry
                                        // user should not be in withdrawers map
                                        setBlockData!("blockNumber", qPeriod + 1, *blockDataCh) |
                                        for (_ <- blockDataCh & _ <- epochBlockCh) {
                                          closeBlock!(*closeBlockCh) |
                                          for (@(true, _) <- closeBlockCh) {
                                            @PoS!("getWithdrawers", *withdrawersCh) |
                                            getPosData!(*userBalanceCh, *userVault, *posBalanceCh, *bondsCh, *rewardsCh) |
                                            for (@posBalance3  <- posBalanceCh &
                                                 @balance3     <- userBalanceCh &
                                                 @bonds3       <- bondsCh &
                                                 @rewards3     <- rewardsCh &
                                                 @withdrawers3 <- withdrawersCh) {
                                              rhoSpec!("assertMany",
                                                [
                                                  // bonding assertions
                                                  ((addBondRes.nth(0), "==", true), "add bonding request succeeds"),
                                                  ((bondRes.nth(0), "==", true), "the bonding result is true"),
                                                  // bonds map assertions
                                                  ((bonds0, "==", bonds3), "user is not in the bond map after withdraw"),
                                                  ((bonds0.contains(userPubKey), "==", false), "user is not in the bonds map before bond"),
                                                  ((bonds1.get(userPubKey), "==", bondAmt), "user has correct bond in bonds map before withdraw"),
                                                  ((bonds2.contains(userPubKey), "==", false), "user has correct bond in bonds map after withdraw, before quarantine expiry"),
                                                  ((bonds3.contains(userPubKey), "==", false), "user is not in the bond map after quarantine expiry"),
                                                  // rewards assertions
                                                  ((rewards0, "==", rewards3), "rewards don't change for bonding"),
                                                  ((rewards0.contains(userPubKey), "==", false), "user is not in rewards0 map"),
                                                  ((rewards1.get(userPubKey), "==", 0), "user should be in rewards1 map with 0 rewards"),
                                                  ((rewards2.get(userPubKey), "==", 0), "user should be in rewards2 map with 0 rewards"),
                                                  ((rewards3.contains(userPubKey), "==", false), "user should not be in final rewards map"),
                                                  // user balance assertions
                                                  ((balance0, "==", balance3), "user receives bond after quarantine expiry"),
                                                  ((balance1, "==", balance0 - bondAmt), "user balance decreases by bond amount once bonded"),
                                                  ((balance2, "==", balance1), "user balance remains the same before quarantine expiry"),
                                                  // pos balance assertions
                                                  ((posBalance0, "==", posBalance3), "pos balance returns to original once user withdraws"),
                                                  ((posBalance1, "==", posBalance0 + bondAmt), "pos balance increases by bond amount once user bonds"),
                                                  ((posBalance2, "==", posBalance1), "pos balance remains the same before user withdraws"),
                                                  // withdrawers map assertions
                                                  ((pWithdrawers1.get(userPubKey), "==", qPeriod), "withdrawer state has correct quarantine period before withdrawing from pos"),
                                                  ((pWithdrawers2.contains(userPubKey), "==", false), "withdrawer is moved from pending to withdrawers map"),
                                                  ((withdrawers1.contains(userPubKey), "==", false), "withdrawer is removed from withdrawers map after withdraw"),
                                                ],
                                                *ackCh
                                              )
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } |
          // Tests that a withdrawing validator is only paid after their quarantine period finishes and that when they are paid,
          // their bond is returned to their vault and they are paid the rewards they have accumulated.
          // Caution: there is interaction between this test and test_withdraw_succeeds because block numbers are manipulated.
          contract test_validator_is_paid_after_withdraw(rhoSpec, _, ackCh) = {
            new setupCh, bondCh, chargeCh, refundCh,
                initialValidatorBalanceCh, finalValidatorBalanceCh,
                initialBondsCh, finalBondsCh,
                withdrawCh, closeBlockCh, epochCh, quarantineCh,
                setBlockData(`rho:test:block:data:set`),
                blockDataCh, rewardsCh, validatorRewardCh,
                intermediateValidatorBalanceCh, withdrawersCh, 
                addBondReqCh, epochBlockCh
            in {
              set_context!(*blockDataCh) |
              for (_ <- blockDataCh) {
                prepareUser!(userB, *setupCh) |
                for (@validatorPubKey, _, @validatorVault, @validatorDeployerId <- setupCh) {
                  @validatorVault!("balance", *initialValidatorBalanceCh) |
                  @PoS!("getBonds", *initialBondsCh) |
                  @PoS!("getQuarantineLength", *quarantineCh) |
                  @PoS!("getEpochLength", *epochCh) |
                  for (@initialValidatorBalance <- initialValidatorBalanceCh &
                       @initialBonds            <- initialBondsCh &
                       @epochLength             <- epochCh &
                       @quarantineLength        <- quarantineCh) {
                    let @(bondAmt, chargeAmt, refundAmt, blockNumber)<- (100, 100, 0, 1) in {
                      @PoS!("addBondingRequest", *posVaultDeployerId, userB, bondAmt, *addBondReqCh) |
                      for (@addBondRes <- addBondReqCh) {
                        @PoS!("bond", validatorDeployerId, bondAmt, *bondCh) |
                        for (@bondRes <- bondCh) {
                          stdlog!("info", ("successfully bond.")) |
                          closeBlock!(*closeBlockCh) |
                          for (_ <- closeBlockCh) {
                            prepareUser!(userC, *setupCh) |
                            for (@userPubKey, _, @userVault, @userDeployerId <- setupCh) {
                              @PoS!("chargeDeploy", userDeployerId, chargeAmt, sysAuthToken, *chargeCh) |
                              @PoS!("refundDeploy", refundAmt, sysAuthToken, *refundCh) |
                              for (@(true, _) <- chargeCh &
                                   @(true, _) <- refundCh) {
                                closeBlock!(*closeBlockCh) |
                                for (_ <- closeBlockCh) {
                                  @PoS!("getRewards", *rewardsCh) |
                                  for (@rewards <- rewardsCh) {
                                    stdlog!("info", ("After precharge and refund of the rewards", rewards)) |
                                    validatorRewardCh!(rewards.getOrElse(validatorPubKey, 0)) |
                                    for (@validatorReward <- validatorRewardCh) {
                                      setBlockData!("blockNumber", blockNumber, *blockDataCh) |
                                      stdlog!("info", ("Successfully set block number", blockNumber)) |
                                      @PoS!("getWithdrawers", *withdrawersCh) |
                                      for (_                   <- blockDataCh &
                                           @initialWithdrawers <- withdrawersCh) {
                                        @PoS!("withdraw", validatorDeployerId, *withdrawCh) |
                                        for (@(true, _) <- withdrawCh) {
                                          stdlog!("info", ("Successfully withdraw bbbb....")) |
                                          match quarantineLength + epochLength * (1 + blockNumber / epochLength) {
                                            quarantinePeriod => {
                                              setBlockData!("blockNumber", quarantinePeriod - 1, *blockDataCh) |
                                              for (_ <- blockDataCh) {
                                                stdlog!("info", ("Successfully set block number",  quarantinePeriod - 1)) |
                                                @PoS!("getPendingWithdrawers", *withdrawersCh) |
                                                @validatorVault!("balance", *intermediateValidatorBalanceCh) |
                                                for (@intermediateWithdrawers      <- withdrawersCh &
                                                     @intermediateValidatorBalance <- intermediateValidatorBalanceCh) {
                                                  // epoch change after quarantine expiry
                                                  @PoS!("setEpochBlockNumber", *posVaultDeployerId, quarantinePeriod, *epochBlockCh) |
                                                  setBlockData!("blockNumber", quarantinePeriod, *blockDataCh) |
                                                  for (_ <- blockDataCh & _ <- epochBlockCh) {
                                                    stdlog!("info", ("Epoch block number set", quarantinePeriod)) |
                                                    closeBlock!(*closeBlockCh) |
                                                    for (_ <- closeBlockCh) {
                                                      @validatorVault!("balance", *finalValidatorBalanceCh) |
                                                      @PoS!("getBonds", *finalBondsCh) |
                                                      @PoS!("getWithdrawers", *withdrawersCh) |
                                                      for (@finalBonds            <- finalBondsCh &
                                                           @finalWithdrawers      <- withdrawersCh &
                                                           @finalValidatorBalance <- finalValidatorBalanceCh) {
                                                        stdlog!("info", ("validator rewards", validatorReward, finalValidatorBalance, initialValidatorBalance)) |
                                                        rhoSpec!("assertMany",
                                                          [
                                                            ((addBondRes.nth(0), "==", true), "add bonding request should be true"),
                                                            ((bondRes.nth(0), "==", true), "the bonding result should be true"),
                                                            ((finalBonds, "==", initialBonds), "bonds don't change after the same user bonds and withdraws successfully"),
                                                            ((intermediateValidatorBalance, "==", initialValidatorBalance - bondAmt), "withdrawer is not paid before quarantine period is over"),
                                                            ((validatorReward, "==", finalValidatorBalance - initialValidatorBalance), "after payment, validator's balance only changes by their accumulated rewards"),
                                                            ((false, "==", initialWithdrawers.contains(validatorPubKey)), "before validator withdraws, they should not be in withdrawers map"),
                                                            ((true, "==", intermediateWithdrawers.contains(validatorPubKey)), "after validator requests to withdraw and before quarantine is finished, they should be in withdrawers map"),
                                                            ((false, "==", finalWithdrawers.contains(validatorPubKey)), "after quarantine is finished, validator should not be in withdrawers map")
                                                          ],
                                                          *ackCh
                                                        )
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } |
          contract test_multiple_bonding_succeeds(rhoSpec, _, ackCh) = {
            new setupCh, initialPosBalanceCh, finalPosBalanceCh,
                user2BondCh, user3BondCh, initialBondsCh, finalBondsCh,
                initialUser1BalanceCh, finalUser1BalanceCh,
                initialUser2BalanceCh, finalUser2BalanceCh,
                initialCoopBalanceCh, finalCoopBalanceCh,
                addBondReqCh1, addBondReqCh2
            in {
              prepareUser!(user2, *setupCh) |
              for (@user1PubKey, _, @user1Vault, @user1DeployerId <- setupCh) {
                getPosBalance!(*initialPosBalanceCh) |
                getCoopBalance!(*initialCoopBalanceCh) |
                @PoS!("getBonds", *initialBondsCh) |
                @user1Vault!("balance", *initialUser1BalanceCh) |
                for (@initialPosBalance   <- initialPosBalanceCh &
                     @initialUser1Balance <- initialUser1BalanceCh &
                     @initialCoopBalance  <- initialCoopBalanceCh &
                     @initialBonds        <- initialBondsCh) {
                  let @(user2Bond, user3Bond) <- (100, 200) in {
                    @PoS!("addBondingRequest", *posVaultDeployerId, user2, user2Bond, *addBondReqCh1) |
                    @PoS!("addBondingRequest", *posVaultDeployerId, user3, user3Bond, *addBondReqCh2) |
                    for (@addBondRes1 <- addBondReqCh1 & @addBondRes2 <- addBondReqCh2 ) {
                      @PoS!("bond", user1DeployerId, user2Bond, *user2BondCh) |
                      for (@bondRes1 <- user2BondCh) {
                        stdlog!("info", "first bond") |
                        prepareUser!(user3, *setupCh) |
                        for (@user2PubKey, _, @user2Vault, @user2DeployerId <- setupCh) {
                          @user2Vault!("balance", *initialUser2BalanceCh) |
                          for (@initialUser2Balance <- initialUser2BalanceCh) {
                            @PoS!("bond", user2DeployerId, user3Bond, *user3BondCh) |
                            for (@bondRes2 <- user3BondCh) {
                              @PoS!("getBonds", *finalBondsCh) |
                              getPosBalance!(*finalPosBalanceCh) |
                              getCoopBalance!(*finalCoopBalanceCh) |
                              @user1Vault!("balance", *finalUser1BalanceCh) |
                              @user2Vault!("balance", *finalUser2BalanceCh) |
                              for (@finalPosBalance   <- finalPosBalanceCh &
                                   @finalUser1Balance <- finalUser1BalanceCh &
                                   @finalUser2Balance <- finalUser2BalanceCh &
                                   @finalCoopBalance  <- finalCoopBalanceCh &
                                   @finalBonds        <- finalBondsCh) {
                                rhoSpec!("assertMany",
                                  [
                                    ((addBondRes1.nth(0), "==", true), "add bonding user2 request should be true"),
                                    ((bondRes1.nth(0), "==", true), "the bonding user2 result should be true"),
                                    ((addBondRes2.nth(0), "==", true), "add bonding user3 request should be true"),
                                    ((bondRes2.nth(0), "==", true), "the bonding user3 result should be true"),
                                    ((0, "==", initialBonds.getOrElse(user1PubKey, 0)), "user2's bond is not expected in the initial map"),
                                    ((0, "==", initialBonds.getOrElse(user2PubKey, 0)), "user3's bond is not expected in the initial map"),
                                    ((user2Bond, "==", finalBonds.get(user1PubKey)), "user2's bond is expected in the final map"),
                                    ((user3Bond, "==", finalBonds.get(user2PubKey)), "user3's bond is expected in the final map"),
                                    ((user2Bond, "==", initialUser1Balance - finalUser1Balance), "user2's account decreases as expected"),
                                    ((user3Bond, "==", initialUser2Balance - finalUser2Balance), "user3's account decreases as expected"),
                                    ((finalCoopBalance, "==", initialCoopBalance), "Coop vault balance does not change"),
                                    ((user2Bond + user3Bond, "==", finalPosBalance - initialPosBalance), "the PoS account increases as expected")
                                  ],
                                  *ackCh
                                )
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } |
          contract test_pay_succeeds(rhoSpec, _, ackCh) = {
            new setupCh, closeBlockCh, retCh0, retCh1, initialPosBalanceCh, finalPosBalanceCh,
                initialUser1BalanceCh, finalUser1BalanceCh,
                initialRewardsCh, finalRewardsCh, setEpochRet,
                computeDelta, deltaRewardsCh, deltaSumCh, sumDelta, finalBondsCh,
                isPositive, allRewardsPositiveCh, initialBondsCh, initialActiveCh,
                addBondReqCh, blockDataCh, setBlockData(`rho:test:block:data:set`)
            in {
              set_context!(*blockDataCh) |
              for (_ <- blockDataCh) {
                prepareUser!(user4, *setupCh) |
                for (@validatorPubKey, _, _, @validatorDeployerId <- setupCh) {
                  let @validatorBond, <- 100 &
                      @userCharge <- 100 &
                      @userRefund <- 0 &
                      @blockNumber <- 42
                  in {
                    @PoS!("addBondingRequest", *posVaultDeployerId, user4, validatorBond, *addBondReqCh) |
                    for (@addBondRes <- addBondReqCh) {
                      @PoS!("bond", validatorDeployerId, validatorBond, *setupCh) |
                      for (@bondRes <- setupCh) {
                        // epoch change is required for finalRewards
                        @PoS!("setEpochBlockNumber", *posVaultDeployerId, blockNumber, *setEpochRet) |
                        setBlockData!("blockNumber", blockNumber, *blockDataCh) |
                        for (_ <- setEpochRet & _ <- blockDataCh) {
                          closeBlock!(*closeBlockCh) |
                          prepareUser!(user5, *setupCh) |
                          for (_, _, @userVault, @userDeployerId <- setupCh & _ <- closeBlockCh) {
                            getPosBalance!(*initialPosBalanceCh) |
                            @userVault!("balance", *initialUser1BalanceCh) |
                            @PoS!("getRewards", *initialRewardsCh) |
                            @PoS!("getBonds", *initialBondsCh) |
                            @PoS!("getActiveValidators", *initialActiveCh) |
                            for (@initialPosBalance   <- initialPosBalanceCh &
                                 @initialUser1Balance <- initialUser1BalanceCh &
                                 @initialRewards      <- initialRewardsCh &
                                 @initialBonds        <- initialBondsCh) {
                              @PoS!("chargeDeploy", userDeployerId, userCharge, sysAuthToken, *retCh0) |
                              @PoS!("refundDeploy", userRefund, sysAuthToken, *retCh1) |
                              for (@(true, _) <- retCh0 &
                                   @(true, _) <- retCh1) {
                                // epoch change is required for finalRewards
                                @PoS!("setEpochBlockNumber", *posVaultDeployerId, blockNumber, *setEpochRet) |
                                setBlockData!("blockNumber", blockNumber, *blockDataCh) |
                                for (_ <- setEpochRet & _ <- blockDataCh) {
                                  closeBlock!(*closeBlockCh) |
                                  for (_ <- closeBlockCh) {
                                    getPosBalance!(*finalPosBalanceCh) |
                                    @PoS!("getBonds", *finalBondsCh) |
                                    @userVault!("balance", *finalUser1BalanceCh) |
                                    @PoS!("getRewards", *finalRewardsCh) |
                                    for (@finalPosBalance   <- finalPosBalanceCh &
                                         @finalUser1Balance <- finalUser1BalanceCh &
                                         @finalRewards      <- finalRewardsCh &
                                         @finalBonds        <- finalBondsCh) {
                                      @ListOps!("fold", finalRewards.toList(), {}, *computeDelta, *deltaRewardsCh) |
                                      contract computeDelta(@(pk, finalReward), @acc, resultCh) = {
                                        resultCh!(acc.set(pk, finalReward - initialRewards.getOrElse(pk, 0)))
                                      } |
                                      for (@deltaRewards <- deltaRewardsCh) {
                                        @ListOps!("forall", deltaRewards, *isPositive, *allRewardsPositiveCh) |
                                        contract isPositive(@n, resultCh) = {
                                          resultCh!(n > 0)
                                        } |
                                        @ListOps!("fold", deltaRewards.toList(), 0, *sumDelta, *deltaSumCh) |
                                        contract sumDelta(@(_, delta), @acc, resultCh) = {
                                          resultCh!(acc + delta)
                                        } |
                                        rhoSpec!("assertMany",
                                          [
                                            // bond results
                                            ((addBondRes.nth(0), "==", true), "add bonding request should be true"),
                                            ((bondRes.nth(0), "==", true), "the bonding result should be true"),
                                            // balances
                                            ((userCharge - userRefund, "==", initialUser1Balance - finalUser1Balance), "the user account decreases"),
                                            ((userCharge - userRefund, "==", finalPosBalance - initialPosBalance), "the pos account increases"),
                                            // bonds map
                                            ((initialBonds, "==", finalBonds), "bonds are unchanged"),
                                            // rewards
                                            //TODO: active validator stake-weighted reward
                                            ((0, "==", initialRewards.get(validatorPubKey)), "the validator's initial rewards are as expected"),
                                            ((19, "==", finalRewards.get(validatorPubKey)), "the validator's final rewards are as expected"),
                                            //TODO use arbitrary precision numbers instead of long ints
                                            ((98, "== <-", *deltaSumCh), "the sum difference should equal the payment"),
                                            ((true, "== <-", *allRewardsPositiveCh), "the rewards can only grow")
                                          ],
                                          *ackCh
                                        )
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } |
          contract test_refund_succeeds(rhoSpec, _, ackCh) = {
            new prepareUserAck, bondAck, closeBlockAck, posBalanceCh,
                userBalanceCh, rewardsCh, chargeDeployAck, refundDeployAck,
                computeDelta, deltaRewardsCh, deltaSumCh, sumDelta, setEpochRet,
                isPositive, allRewardsPositiveCh, addBondReqCh, blockDataCh,
                setBlockData(`rho:test:block:data:set`)
            in {
              set_context!(*blockDataCh) |
              for (_ <- blockDataCh) {
                prepareUser!(userD, *prepareUserAck) |
                for (@validatorPubKey, _, _, @validatorDeployerId <- prepareUserAck) {
                  let @validatorBond <- 100 &
                      @userCharge <- 100 &
                      @userRefund <- 50 &
                      @blockNumber <- 42
                  in {
                    @PoS!("addBondingRequest", *posVaultDeployerId, userD, validatorBond, *addBondReqCh) |
                    for (@addBondRes <- addBondReqCh) {
                      @PoS!("bond", validatorDeployerId, validatorBond, *bondAck) |
                      for (@bondRes <- bondAck) {
                        // epoch change is required for newly bonded validator to receive rewards
                        @PoS!("setEpochBlockNumber", *posVaultDeployerId, blockNumber, *setEpochRet) |
                        setBlockData!("blockNumber", blockNumber, *blockDataCh) |
                        for (_ <- setEpochRet & _ <- blockDataCh) {
                          closeBlock!(*closeBlockAck) |
                          prepareUser!(userE, *prepareUserAck) |
                          for (_, _, @userVault, @userDeployerId <- prepareUserAck &
                               _                                 <- closeBlockAck) {
                            getPosBalance!(*posBalanceCh) |
                            @userVault!("balance", *userBalanceCh) |
                            @PoS!("getRewards", *rewardsCh) |
                            for (@initialPosBalance  <- posBalanceCh &
                                 @initialUserBalance <- userBalanceCh &
                                 @initialRewards     <- rewardsCh) {
                              @PoS!("chargeDeploy", userDeployerId, userCharge, sysAuthToken, *chargeDeployAck) |
                              @PoS!("refundDeploy", userRefund, sysAuthToken, *refundDeployAck) |
                              for (@(true, _) <- chargeDeployAck &
                                   @(true, _) <- refundDeployAck) {
                                @PoS!("setEpochBlockNumber", *posVaultDeployerId, blockNumber, *setEpochRet) |
                                setBlockData!("blockNumber", blockNumber, *blockDataCh) |
                                for (_ <- setEpochRet & _ <- blockDataCh) {
                                  closeBlock!(*closeBlockAck) |
                                  for (_ <- closeBlockAck) {
                                    getPosBalance!(*posBalanceCh) |
                                    @userVault!("balance", *userBalanceCh) |
                                    @PoS!("getRewards", *rewardsCh) |
                                    for (@finalPosBalance  <- posBalanceCh &
                                         @finalUserBalance <- userBalanceCh &
                                         @finalRewards     <- rewardsCh) {
                                      @ListOps!("fold", finalRewards.toList(), {}, *computeDelta, *deltaRewardsCh) |
                                      contract computeDelta(@(pk, finalReward), @acc, resultCh) = {
                                        resultCh!(acc.set(pk, finalReward - initialRewards.getOrElse(pk, 0)))
                                      } |
                                      for (@deltaRewards <- deltaRewardsCh) {
                                        @ListOps!("forall", deltaRewards, *isPositive, *allRewardsPositiveCh) |
                                        contract isPositive(@n, resultCh) = {
                                          resultCh!(n > 0)
                                        } |
                                        @ListOps!("fold", deltaRewards.toList(), 0, *sumDelta, *deltaSumCh) |
                                        contract sumDelta(@(_, delta), @acc, resultCh) = {
                                          resultCh!(acc + delta)
                                        } |
                                        rhoSpec!("assertMany",
                                          [
                                            ((addBondRes.nth(0), "==", true), "add bonding request should be true"),
                                            ((bondRes.nth(0), "==", true), "the bonding result should be true"),
                                            // balances
                                            ((userCharge - userRefund, "==", initialUserBalance - finalUserBalance), "the user account decreases"),
                                            ((userCharge - userRefund, "==", finalPosBalance - initialPosBalance), "the pos account increases"),
                                            // rewards
                                            //TODO: active validator stake-weighted reward
                                            ((0, "==", initialRewards.get(validatorPubKey)), "the validator's initial rewards are as expected"),
                                            ((8, "==", finalRewards.get(validatorPubKey)), "the validator's final rewards are as expected"),
                                            //TODO use arbitrary precision numbers instead of long ints
                                            ((50, "== <-", *deltaSumCh), "the sum difference should equal the payment"),
                                            ((true, "== <-", *allRewardsPositiveCh), "the rewards can only grow")
                                          ],
                                          *ackCh
                                        )
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } |

          contract test_bonding_fails_if_deposit_fails(rhoSpec, _, ackCh) = {
            test_bonding_failure!(*rhoSpec, user6, 20000, "Bond deposit failed: Insufficient funds", *ackCh)
          } |

          contract test_bonding_fails_if_bond_too_small(rhoSpec, _, ackCh) = {
            test_bonding_failure!(*rhoSpec, user7, -1, "Bond is less than minimum!", *ackCh)
          } |
          contract test_bonding_fails_if_already_bonded(rhoSpec, _, ackCh) = {
            new setupCh, initialBondsCh, bond1Ch, bond2Ch, bondsCh,
                finalRewardsCh, initialRewardsCh,
                addBondReqCh
            in {
              prepareUser!(user8, *setupCh) |
              for (_, _, _, @userDeployerId <- setupCh) {
                let @(userBond1, userBond2) <- (150, 100) in {
                  @PoS!("addBondingRequest", *posVaultDeployerId, user8, userBond1, *addBondReqCh) |
                  for (@addBondRes <- addBondReqCh) {
                    @PoS!("bond", userDeployerId, userBond1, *bond1Ch) |
                    for (@(bond1Result, _) <- bond1Ch) {
                      @PoS!("getBonds", *initialBondsCh) |
                      @PoS!("getRewards", *initialRewardsCh) |
                      for (@initialBonds   <- initialBondsCh &
                           @initialRewards <- initialRewardsCh) {
                        @PoS!("bond", userDeployerId, userBond2, *bond2Ch) |
                        for (@(bond2Result, msg2) <- bond2Ch) {
                          @PoS!("getBonds", *bondsCh) |
                          @PoS!("getRewards", *finalRewardsCh) |
                          rhoSpec!("assertMany",
                            [
                              ((addBondRes.nth(0), "==", true), "add bond request should be true"),
                              ((true, "==", bond1Result), "the first bond should succeed"),
                              ((false, "==", bond2Result), "the second bond should fail"),
                              (("Public key is already bonded.", "==", msg2), "the message should be as expected"),
                              ((initialBonds, "== <-", *bondsCh), "the bonds map remains unchanged after second bond request"),
                              ((initialRewards, "== <-", *finalRewardsCh), "the rewards map remains unchanged after second bond request")
                            ],
                            *ackCh
                          )
                        }
                      }
                    }
                  }
                }
              }
            }
          } |
          contract test_bonding_failure(rhoSpec, @pk, @transferAmount, @expectedMsg, ackCh) = {
            new setupCh, retCh, bondsCh,
                finalRewardsCh, initialRewardsCh, addBondReqCh in {
              prepareUser!(pk, *setupCh) |
              for (_, _, _, @deployerId <- setupCh) {
                @PoS!("getBonds", *bondsCh) |
                @PoS!("getRewards", *initialRewardsCh) |
                for (@initialBonds   <- bondsCh &
                     @initialRewards <- initialRewardsCh) {
                  @PoS!("addBondingRequest", *posVaultDeployerId, pk, transferAmount, *addBondReqCh) |
                  for (@addBondRes <- addBondReqCh) {
                    @PoS!("bond", deployerId, transferAmount, *retCh) |
                    for (@(result, msg) <- retCh) {
                      @PoS!("getBonds", *bondsCh) |
                      @PoS!("getRewards", *finalRewardsCh) |
                      rhoSpec!("assertMany",
                        [
                          ((expectedMsg, "==", msg), "the message should be as epected"),
                          ((false, "==", result), "the bond should fail"),
                          ((initialBonds, "== <-", *bondsCh), "the bonds map remains unchanged after failed bond"),
                          ((initialRewards, "== <-", *finalRewardsCh), "the rewards map remains unchanged after failed bond")
                        ],
                        *ackCh
                      )
                    }
                  }
                }
              }
            }
          } |
          contract test_dont_reward_inactive_validators(rhoSpec, _, ackCh) = {
            new setupCh, closeBlockCh, chargeCh,
                refundCh, finalRewardsCh, addBondReqCh
            in {
              prepareUser!(user9, *setupCh) |
              for (@validatorPubKey, _, _, @validatorDeployerId <- setupCh) {
                @PoS!("addBondingRequest", *posVaultDeployerId, user9, 100, *addBondReqCh) |
                for (@addBondRes <- addBondReqCh) {
                  @PoS!("bond", validatorDeployerId, 100, *setupCh) |
                  for (@bondRes <- setupCh) {
                    prepareUser!(user0, *setupCh) |
                    for (@user1PubKey, _, @user1Vault, @user1DeployerId <- setupCh) {
                      @PoS!("chargeDeploy", user1DeployerId, 100, sysAuthToken, *chargeCh) |
                      @PoS!("refundDeploy", 10, sysAuthToken, *refundCh) |
                      for (@(true, _) <- chargeCh &
                           @(true, _) <- refundCh) {
                        closeBlock!(*closeBlockCh) |
                        for (_ <- closeBlockCh) {
                          @PoS!("getRewards", *finalRewardsCh) |
                          for(@finalRewards <- finalRewardsCh) {
                            rhoSpec!("assertMany",
                              [
                                ((addBondRes.nth(0), "==", true), "add bonding request should be true"),
                                ((bondRes.nth(0), "==", true), "the bonding result should be true"),
                                ((0, "==", finalRewards.get(validatorPubKey)), "the new validator should have no reward")
                              ],
                              *ackCh
                            )
                          }
                        }
                      }
                    }
                  } 
                }
              }
            }
          } |
          contract test_bonding_fails_if_not_in_whitelist(rhoSpec, _, ackCh) = {
            new setupCh, bondRetCh in {
              prepareUser!(user12, *setupCh) |
              for (@validatorPubKey, _, _, @validatorDeployerId <- setupCh) {
                @PoS!("bond", validatorDeployerId, 100, *bondRetCh) |
                for (@bondRes <- bondRetCh) {
                  rhoSpec!("assertMany",
                    [
                      ((bondRes.nth(0), "==", false), "add bonding request should be false because the pubkey is not in whitelist")
                    ],
                    *ackCh
                  )
                } 
              }
            }
          } |
          contract test_bonding_fails_if_removed_from_whitelist(rhoSpec, _, ackCh) = {
            new setupCh, addBondReqCh, removeBondReqCh, bondRetCh in {
              prepareUser!(user13, *setupCh) |
              for (@validatorPubKey, _, _, @validatorDeployerId <- setupCh) {
                @PoS!("addBondingRequest", *posVaultDeployerId, user13, 100, *addBondReqCh) |
                for (@addBondRes <- addBondReqCh) {
                  @PoS!("removeBondingRequest", *posVaultDeployerId, user13, *removeBondReqCh) |
                  for (@removeRes <- removeBondReqCh) {
                    @PoS!("bond", validatorDeployerId, 100, *bondRetCh) |
                    for (@bondRes <- bondRetCh) {
                      rhoSpec!("assertMany",
                        [
                          ((addBondRes.nth(0), "==", true), "add bonding request should be true"),
                          ((removeRes.nth(0), "==", true), "remove bonding request should be true after adding into whitelist"),
                          ((bondRes.nth(0), "==", false), "bonding should fail because the pubkey is removed in whitelist"),
                        ],
                        *ackCh
                      )
                    }
                  }
                }
              }
            }
          } |
          contract test_bonding_fails_if_stake_is_not_the_same_as_whitelist(rhoSpec, _, ackCh) = {
            new setupCh, addBondReqCh, bondRetCh in {
              prepareUser!(user14, *setupCh) |
              for (@validatorPubKey, _, _, @validatorDeployerId <- setupCh) {
                @PoS!("addBondingRequest", *posVaultDeployerId, user14, 100, *addBondReqCh) |
                for (@addBondRes <- addBondReqCh) {
                  @PoS!("bond", validatorDeployerId, 200, *bondRetCh) |
                  for (@bondRes <- bondRetCh) {
                    rhoSpec!("assertMany",
                      [
                        ((addBondRes.nth(0), "==", true), "add bonding request should be true"),
                        ((bondRes.nth(0), "==", false), "bonding should fail because stake is not equal to whitelist stake  "),
                      ],
                      *ackCh
                    )
                  }
                }
              }
            }
          } | 
          contract getPosBalance(retCh) = {
            @posVault!("balance", *retCh)
          } |

          contract closeBlock(ackCh) = {
            new ackCh0, activeValidatorsCh, setBlockData(`rho:test:block:data:set`), blockDataSet in {
              @PoS!("closeBlock", sysAuthToken, *ackCh0) |
              for (@ack <- ackCh0) {
                @PoS!("getActiveValidators", *activeValidatorsCh) |
                for (@activeValidators <- activeValidatorsCh) {
                  // For testing we need one of the active validators to be the block sender
                  setBlockData!("sender", activeValidators.toList().nth(0), *blockDataSet) |
                  for (_ <- blockDataSet) {
                    ackCh!(ack)
                  }
                }
              }
            }
          } |

          contract getCoopBalance(returnCh) = {
            new retCh in {
              @PoS!("getCoopVault", *retCh) |
              for (@(_, _, coopVault) <- retCh) {
                @coopVault!("balance", *returnCh)
              }
            }
          } |

          contract test_commit_random(rhoSpec, _, ackCh) = {
            new setupCh, closeBlockCh, retCh,
                finalRewardsCh, computeHash(`rho:crypto:keccak256Hash`), hash00Ch, hashFFCh
            in {
              prepareUser!(userD, *setupCh) |
              for (@validatorPubKey, _, _, @validatorDeployerId <- setupCh) {
                @PoS!("revealRandom", validatorDeployerId, "FF".hexToBytes(), *retCh) |
                computeHash!("00".hexToBytes(), *hash00Ch) |
                computeHash!("FF".hexToBytes(), *hashFFCh) |
                for (@result0 <- retCh &
                     @hash00  <- hash00Ch &
                     @hashFF  <- hashFFCh) {
                  @PoS!("commitRandomImage", validatorDeployerId, hash00, *retCh) |
                  for (@result1 <- retCh) {
                    @PoS!("commitRandomImage", validatorDeployerId, hashFF, *retCh) |
                    for (@result2 <- retCh) {
                      @PoS!("revealRandom", validatorDeployerId, "FF".hexToBytes(), *retCh) |
                      for (@result3 <- retCh) {
                        @PoS!("revealRandom", validatorDeployerId, "00".hexToBytes(), *retCh) |
                        for (@result4 <- retCh) {
                          rhoSpec!("assertMany",
                            [
                              (((false, "Previously committed random image not found"), "==", result0), "commitRandom before commitRandomImage fails"),
                              ((true, "==", result1), "the first commitRandomImage is successful"),
                              (((false, "Image already committed"), "==", result2), "the second commitRandomImage for the same validator fails"),
                              (((false, "Previously committed image doesn't match the random number"), "==", result3), "the random value doesn't match the commited image stored by the first commitRandomImage"),
                              ((true, "==", result4), "the random value matches the commited image")
                            ],
                            *ackCh
                          )
                        }
                      }
                    }
                  }
                }
              }
            }
          } |
          // Checks that the slashed validator's bond and rewards are moved from the PoS vault to the Coop vault and
          // reduced to 0 in the bond and committedRewards maps and that they are immediately moved to the withdrawers map.
          contract test_slashing_vaults_and_state(rhoSpec, _, ackCh) = {
            new initialBondSumCh, chargeCh, refundCh, initialCoopBalanceCh, finalCoopBalanceCh,
                setupCh, slashCh, activeValidatorsCh, withdrawersCh,
                initialPosBalanceCh, finalPosBalanceCh,
                initialUserBalanceCh, finalUserBalanceCh,
                initialRewardsCh, finalRewardsCh,
                initialBondsCh, finalBondsCh
            in {
              prepareUser!(userB, *setupCh) |
              for (_, _, @userVault, @userDeployerId <- setupCh) {
                @PoS!("getActiveValidators", *activeValidatorsCh) |
                @PoS!("getBonds", *initialBondsCh) |
                getCoopBalance!(*initialCoopBalanceCh) |
                for (@activeValidators   <- activeValidatorsCh &
                     @initialBonds       <- initialBondsCh &
                     @initialCoopBalance <- initialCoopBalanceCh) {
                  match (100, 0) {
                    (chargeAmt, refundAmt) => {
                      @PoS!("chargeDeploy", userDeployerId, chargeAmt, sysAuthToken, *chargeCh) |
                      @PoS!("refundDeploy", refundAmt, sysAuthToken, *refundCh) |
                      for (@(true, _) <- chargeCh &
                           @(true, _) <- refundCh) {
                        match activeValidators.toList().nth(3) {
                          slashedValidator => {
                            getPosBalance!(*initialPosBalanceCh) |
                            @PoS!("getRewards", *initialRewardsCh) |
                            @userVault!("balance", *initialUserBalanceCh) |
                            for (@initialUserBalance <- initialUserBalanceCh &
                                 @initialRewards     <- initialRewardsCh &
                                 @initialPosBalance  <- initialPosBalanceCh) {
                              @PoS!("slash", slashedValidator, sysAuthToken, *slashCh) |
                              for (@(true, _) <- slashCh) {
                                @PoS!("getBonds", *finalBondsCh) |
                                getPosBalance!(*finalPosBalanceCh) |
                                @userVault!("balance", *finalUserBalanceCh) |
                                @PoS!("getRewards", *finalRewardsCh) |
                                @PoS!("getWithdrawers", *withdrawersCh) |
                                getCoopBalance!(*finalCoopBalanceCh) |
                                for (@finalPosBalance  <- finalPosBalanceCh &
                                     @finalUserBalance <- finalUserBalanceCh &
                                     @finalBonds       <- finalBondsCh &
                                     @finalRewards     <- finalRewardsCh &
                                     @withdrawers      <- withdrawersCh &
                                     @finalCoopBalance <- finalCoopBalanceCh) {
                                  stdlog!("info", (initialBonds, finalBonds, slashedValidator)) |
                                  rhoSpec!("assertMany",
                                    [
                                      ((finalBonds, "==", initialBonds.set(slashedValidator, 0)), "Slashed validator's bond is reduced to 0"),
                                      ((0, "==", finalRewards.get(slashedValidator)), "Slashed validator's rewards are reduced to 0"),
                                      ((finalPosBalance, "==", initialPosBalance - initialBonds.get(slashedValidator)), "Slashed validator's funds are transferred out of the PoS vault"),
                                      ((finalCoopBalance, "==", initialCoopBalance + initialBonds.get(slashedValidator)), "Slashed validator's funds are transferred to the Coop vault")
                                    ],
                                    *ackCh
                                  )
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
}
