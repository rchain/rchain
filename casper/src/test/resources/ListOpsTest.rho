//scalapackage coop.rchain.rholang.collection

new
  rl(`rho:registry:lookup`), ListOpsCh, RhoSpecCh,
  greaterThan1,
  setup,
  test_forall, test_forall_shortcircuit,
  test_exists, test_exists_shortcircuit
in {
  rl!(`rho:id:zphjgsfy13h1k85isc8rtwtgt3t9zzt5pjd5ihykfmyapfc4wt3x5h`, *RhoSpecCh) |
  for(@(_, RhoSpec) <- RhoSpecCh) {
    @RhoSpec!("testSuite", *setup,
      [
        ("ListOps.forall works", *test_forall),
        ("ListOps.forall shortcircuit", *test_forall_shortcircuit),
        ("ListOps.exists works", *test_exists),
        ("ListOps.exists shortcircuit", *test_exists_shortcircuit)
      ])
  } |
  rl!(`rho:lang:listOps`, *ListOpsCh) |
  for(@(_, ListOps) <- ListOpsCh) {

    contract setup(returnCh) = {
      returnCh!([])
    } |

    contract test_forall(rhoSpec, _, ackCh) = {
      new ch0, ch1, ch2, ch3, ch4 in {

        @ListOps!("forall", [], *greaterThan1, *ch0) |
        @ListOps!("forall", [1], *greaterThan1, *ch1) |
        @ListOps!("forall", [2], *greaterThan1, *ch2) |
        @ListOps!("forall", [3, 4], *greaterThan1, *ch3) |
        @ListOps!("forall", [1, 2, 3, 4], *greaterThan1, *ch4) |

        rhoSpec!("assertMany",
          [
            ((true, "== <-", *ch0), "forall is successful for empty lists"),
            ((false, "== <-", *ch1), "[1]"),
            ((true, "== <-", *ch2), "[2]"),
            ((true, "== <-", *ch3), "[3, 4]"),
            ((false, "== <-", *ch4), "[1, 2, 3, 4]")
          ], *ackCh)
      }
    } |

    contract test_forall_shortcircuit(rhoSpec, _, ackCh) = {
      new callCountCh, greaterThan1WithCount, resultCh in {
        callCountCh!(0) |
        contract greaterThan1WithCount(@x, returnCh) = {
          for (@count <- callCountCh) {
            callCountCh!(count + 1) |
            returnCh!(x > 1)
          }
        } |

        @ListOps!("forall", [2, 1, 0], *greaterThan1WithCount, *resultCh) |

        for (@result <- resultCh) {
          rhoSpec!("assertMany",
            [
              ((false, "==", result), "second item doesn't satisfy the predicate"),
              ((2, "== <-", *callCountCh), "after the first failure no more calls should happen"),
            ], *ackCh)
        }
      }
    } |

    contract test_exists(rhoSpec, _, ackCh) = {
      new ch0, ch1, ch2, ch3, ch4 in {

        @ListOps!("exists", [], *greaterThan1, *ch0) |
        @ListOps!("exists", [1], *greaterThan1, *ch1) |
        @ListOps!("exists", [2], *greaterThan1, *ch2) |
        @ListOps!("exists", [3, 4], *greaterThan1, *ch3) |
        @ListOps!("exists", [1, 2, 3, 4], *greaterThan1, *ch4) |

        rhoSpec!("assertMany",
          [
            ((false, "== <-", *ch0), "exists returns false for empty lists"),
            ((false, "== <-", *ch1), "[1]"),
            ((true, "== <-", *ch2), "[2]"),
            ((true, "== <-", *ch3), "[3, 4]"),
            ((true, "== <-", *ch4), "[1, 2, 3, 4]")
          ], *ackCh)
      }
    } |

    contract test_exists_shortcircuit(rhoSpec, _, ackCh) = {
      new callCountCh, greaterThan1WithCount, resultCh in {
        callCountCh!(0) |
        contract greaterThan1WithCount(@x, returnCh) = {
          for (@count <- callCountCh) {
            callCountCh!(count + 1) |
            returnCh!(x > 1)
          }
        } |

        @ListOps!("exists", [2, 1, 0], *greaterThan1WithCount, *resultCh) |

        for (@result <- resultCh) {
          rhoSpec!("assertMany",
            [
              ((true, "==", result), "first item satisfies the predicate"),
              ((1, "== <-", *callCountCh), "after the first success no more calls should happen"),
            ], *ackCh)
        }
      }
    } |

    contract greaterThan1(@x, retCh) = { retCh!(x > 1)}
  }
}
