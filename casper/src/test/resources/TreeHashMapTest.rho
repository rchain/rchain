new
  rl(`rho:registry:lookup`), RhoSpecCh,
  stdlog(`rho:io:stdlog`),
  test_get_before_set,
  test_get_after_set,
  test_get_after_update_nil,
  test_get_after_update,
  test_fast_unsafe_get_after_set,
  test_contains_before_set,
  test_contains_after_set,
  test_get_after_set_to_nil,
  test_contains_after_set_to_nil,
  test_contention
in {
  for(@(_, RhoSpec) <- rl!?(`rho:id:zphjgsfy13h1k85isc8rtwtgt3t9zzt5pjd5ihykfmyapfc4wt3x5h`)) {
    @RhoSpec!("testSuite",
      [
        ("Get before set returns Nil", *test_get_before_set),
        ("Get after set returns the new value", *test_get_after_set),
        ("Get after updating a nonexistent key should return Nil", *test_get_after_update_nil),
        ("Get after updating an existing key should return the right value", *test_get_after_update),
        ("Fast unsafe get after set returns the new value", *test_fast_unsafe_get_after_set),
        ("Contains before set returns false", *test_contains_before_set),
        ("Contains after set returns true", *test_contains_after_set),
        ("Get after set to Nil returns Nil", *test_get_after_set_to_nil),
        ("Contains after set to Nil returns true", *test_contains_after_set_to_nil),
        ("Works under contention", *test_contention)
      ])
  } |

  for(TreeHashMap <- rl!?(`rho:lang:treeHashMap`)) {
    contract test_get_before_set(ackCh, rhoSpec, _) = {
      new ch in {
        for (@thm <- TreeHashMap!?("init", 3)) {
          TreeHashMap!( *ch, "get", thm, "no such key") |
          rhoSpec!( *ackCh, "assertMany",
            [
              ((Nil, "== <-", *ch), "Getting with an unused key returns Nil")
            ])
        }
      }
    } |

    contract test_get_after_update_nil(ackCh, rhoSpec, _) = {
      new ack, ch, update in {
        contract update(ret, @val) = {
          ret!(val + 1)
        } |
        for (@thm <- TreeHashMap!?("init", 3);
             _ <- TreeHashMap!?("update", thm, "no such key", *update)) {
          TreeHashMap!(*ch, "get", thm, "no such key") |
          rhoSpec!(*ackCh, "assertMany",
            [
              ((Nil, "== <-", *ch), "Getting after updating with an unused key returns Nil")
            ])
        }
      }
    } |

    contract test_get_after_update(ackCh, rhoSpec, _) = {
      new ch, update in {
        contract update(ret, @val) = {
          ret!(val + 1)
        } |
        for (@thm <- TreeHashMap!?("init", 3) ;
             _ <- TreeHashMap!?("set", thm, "key", 0); 
             _ <- TreeHashMap!?("update", thm, "key", *update)) {
          TreeHashMap!(*ch, "get", thm, "key") |
          rhoSpec!(*ackCh, "assertMany",
            [
              ((1, "== <-", *ch), "Getting after updating after setting returns the right value")
            ])
        }
      }
    } |

    contract test_get_after_set(ackCh, rhoSpec, _) = {
      new ch1, ch2 in {
        for (@thm <- TreeHashMap!?("init", 3);
             _ <- TreeHashMap!?("set", thm, "some key", "some val")) {
          TreeHashMap!(*ch1, "get", thm, "some key") |
          TreeHashMap!(*ch2, "get", thm, "some other key") |
          rhoSpec!(*ackCh, "assertMany",
            [
              (("some val", "== <-", *ch1), "Getting with the proper key returns the correct value"),
              ((Nil, "== <-", *ch2), "Getting with a different key returns Nil")
            ])
        }
      }
    } |

    contract test_fast_unsafe_get_after_set(ackCh, rhoSpec, _) = {
      new ch2 in {
        for (@thm <- TreeHashMap!?("init", 3);_ <- TreeHashMap!?("set", thm, "some key", "some val") ) {
          TreeHashMap!(*ch2, "fastUnsafeGet", thm, "some key") |
          rhoSpec!(*ackCh, "assertMany",
            [
              (("some val", "== <-", *ch2), "Getting with the proper key returns the correct value"),
            ])
        }
      }
    } |

    contract test_contains_before_set(ackCh, rhoSpec, _) = {
      new ch in {
        for (@thm <- TreeHashMap!?("init", 3)) {
          TreeHashMap!(*ch, "contains", thm, "no such key") |
          rhoSpec!(*ackCh, "assertMany",
            [
              ((false, "== <-", *ch), "Getting with an unused key returns false")
            ])
        }
      }
    } |

    contract test_contains_after_set(ackCh, rhoSpec, _) = {
      new ch2, ch3 in {
        for (@thm <- TreeHashMap!?("init", 3);
             _ <- TreeHashMap!?("set", thm, "some key", "some val")) {
          TreeHashMap!(*ch2, "contains", thm, "some key") |
          TreeHashMap!(*ch3, "contains", thm, "some other key") |
          rhoSpec!(*ackCh, "assertMany",
            [
              ((true, "== <-", *ch2), "Getting with the proper key returns true"),
              ((false, "== <-", *ch3), "Getting with a different key returns false")
            ])
        }
      }
    } |

    contract test_get_after_set_to_nil(ackCh, rhoSpec, _) = {
      new ch2 in {
        for (@thm <- TreeHashMap!?("init", 3); 
             _ <- TreeHashMap!?("set", thm, "some key", Nil)) {
          TreeHashMap!(*ch2, "get", thm, "some key") |
          rhoSpec!(*ackCh, "assertMany",
            [
              ((Nil, "== <-", *ch2), "Getting with the proper key returns the correct value"),
            ])
        }
      }
    } |

    contract test_contains_after_set_to_nil(ackCh, rhoSpec, _) = {
      new ret, ch1, ch2, ch3 in {
        for (@thm <- TreeHashMap!?("init", 3); _ <- TreeHashMap!?("set", thm, "some key", Nil) ) {
          TreeHashMap!(*ch2, "contains", thm, "some key") |
          TreeHashMap!(*ch3, "contains", thm, "some other key") |
          rhoSpec!(*ackCh, "assertMany",
            [
              ((true, "== <-", *ch2), "Getting with the proper key returns true"),
              ((false, "== <-", *ch3), "Getting with a different key returns false")
            ])
        }
      }
    } |

    contract test_contention(ackCh, rhoSpec, _) = {
      new tryIt in {
        contract tryIt(@n, @flag) = {
          new out(`rho:io:stdlog`) in {
            for (@map <- TreeHashMap!?("init", 3)) {
              new ret3 in {
                for (_ <- TreeHashMap!?("set", map, "category", "object") ;
                     _ <- TreeHashMap!?("set", map, "category", "morphism"); 
                     @val3 <- TreeHashMap!?("get", map, "category")) {
                  out!("info", [n, val3]) |
                  if (n == 9) {
                    rhoSpec!(*ackCh, "assertMany",
                    [
                      ((flag, "==", true), "Placeholder")
                    ])
                  } else {
                    tryIt!(n+1, flag and (val3 != Nil))
                  }
                }
              }
            }
          }
        } |
        tryIt!(0, true)
      }
    }
  }
}
