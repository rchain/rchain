//scalapackage coop.rchain.rholang.mint

//requires Pos, RhoSpec

match (
  "047b43d6548b72813b89ac1b9f9ca67624a8b372feedd71d4e2da036384a3e1236812227e524e6f237cde5f80dbb921cac12e6500791e9a9ed1254a745a816fe1f".hexToBytes()
) {
  posPubKey => {
    new
      rl(`rho:registry:lookup`),
      makeSysAuthToken(`sys:test:authToken:make`),
      sysAuthTokenCh,
      stdlog(`rho:io:stdlog`),
      revAddressOps(`rho:rev:address`),
      posRevAddressCh, posVaultCh,
      RhoSpecCh, PoSCh, RevVaultCh, ListOpsCh,
      setup, prepareUser,
      test_make_pos_succeeds,
      test_close_block_finishes,
      test_bonding_succeeds,
      test_withdraw_succeeds,
      test_validator_is_paid_after_withdraw,
      test_multiple_bonding_succeeds,
      test_bonding_fails_if_deposit_fails,
      test_bonding_fails_if_already_bonded,
      test_bonding_fails_if_bond_too_small,
      test_pay_succeeds,
      test_refund_succeeds,
      test_commit_random,
      test_dont_reward_inactive_validators,
      test_bonding_failure,
      test_slashing_vaults_and_state,
      getPosBalance, getCoopBalance,
      closeBlock
    in {
      revAddressOps!("fromPublicKey", posPubKey, *posRevAddressCh) |
      rl!(`rho:rchain:revVault`, *RevVaultCh) |
      rl!(`rho:rchain:pos`, *PoSCh) |
      rl!(`rho:lang:listOps`, *ListOpsCh) |
      rl!(`rho:id:zphjgsfy13h1k85isc8rtwtgt3t9zzt5pjd5ihykfmyapfc4wt3x5h`, *RhoSpecCh) |
      makeSysAuthToken!(*sysAuthTokenCh) |
      for(@(_, RhoSpec)  <- RhoSpecCh;
          @(_, PoS)      <- PoSCh;
          @(_, RevVault) <- RevVaultCh;
          @posRevAddress <- posRevAddressCh;
          @(_, ListOps)  <- ListOpsCh;
          @sysAuthToken  <- sysAuthTokenCh) {
        stdlog!("info", {"posRevAddress" : posRevAddress}) |
        @PoS!("getInitialPosVault", *posVaultCh) |
        for (@(posAddr, posVault) <- posVaultCh) {
          @RhoSpec!("testSuite", *setup,
            [
              ("PoS is created with empty rewards", *test_make_pos_succeeds),
              ("closeBlock finishes successfully", *test_close_block_finishes),
              // ("bonding success", *test_bonding_succeeds),
              // ("withdraw succeeds", *test_withdraw_succeeds),
              // ("validator is paid after withdraw", *test_validator_is_paid_after_withdraw),
              ("bonding fails if deposit fails", *test_bonding_fails_if_deposit_fails),
              // ("multiple bondings work", *test_multiple_bonding_succeeds),
              // ("payment works", *test_pay_succeeds),
              // ("payment refund works", *test_refund_succeeds),
              ("bonding fails if already bonded", *test_bonding_fails_if_already_bonded),
              ("bonding fails if bond is too small", *test_bonding_fails_if_bond_too_small),
              // ("payment is not distributed to inactive validators", *test_dont_reward_inactive_validators),
              // ("commited random matches its image", *test_commit_random),
              // ("Slashing transfers funds appropriately", *test_slashing_vaults_and_state)
            ]
          ) |

          contract setup(_, retCh) = {
            retCh!({})
          } |

          contract prepareUser(@pk, retCh) = {
            stdlog!("info", ("preparing user ", pk)) |
            new makeDeployerId(`rho:test:deployerId:make`),
                deployerIdCh, revAddrCh, vaultCh
            in {
              revAddressOps!("fromPublicKey", pk.hexToBytes(), *revAddrCh) |
              makeDeployerId!("deployerId", pk.hexToBytes(), *deployerIdCh) |
              for (@revAddress <- revAddrCh;
                   @deployerId <- deployerIdCh) {
                @RevVault!("findOrCreate", revAddress, *vaultCh) |
                for (@(true, vault) <- vaultCh) {
                  retCh!(pk.hexToBytes(), revAddress, vault, deployerId)
                }
              }
            }
          } |

          contract test_make_pos_succeeds(rhoSpec, _, ackCh) = {
            new bondsCh, rewardsCh, rewardsZeroCh, rewardsZeroPred in {
              @PoS!("getBonds", *bondsCh) |
              @PoS!("getRewards", *rewardsCh) |
              for (@bonds   <- bondsCh;
                   @rewards <- rewardsCh) {
                @ListOps!("forall", rewards.toList(), *rewardsZeroPred, *rewardsZeroCh) |
                contract rewardsZeroPred(@(_, reward), resultCh) = {
                  resultCh!(reward == 0)
                } |
                rhoSpec!("assertMany",
                  [
                    (bonds.size() >= 0, "some bonds map should be received"),
                    ((0, "==", rewards.size()), "the rewards map is initially empty"),
                    ((true, "== <-", *rewardsZeroCh), "no rewards yet")
                  ],
                  *ackCh
                )
              }
            }
          } |
          // Tests that close block finishes on non epoch change block number and on epoch change block number.
          contract test_close_block_finishes(rhoSpec, _, ackCh) = {
            new close1Ch, close2Ch, setBlockData(`rho:test:block:data:set`),
                initialBlockDataCh, finalBlockDataCh, epochCh
            in {
              @PoS!("getEpochLength", *epochCh) |
              for (@epochLength <- epochCh) {
                // non epoch change closeBlock
                setBlockData!("blockNumber", 1, *initialBlockDataCh) |
                for (_ <- initialBlockDataCh) {
                  closeBlock!(*close1Ch) |
                  for (@(true, _) <- close1Ch) {
                    // epoch change closeBlock
                    setBlockData!("blockNumber", epochLength, *finalBlockDataCh) |
                    for (_ <- finalBlockDataCh) {
                      closeBlock!(*close2Ch) |
                      for (@(true, _) <- close2Ch) {
                        rhoSpec!("assertMany",
                          [
                            (true, "all good here")
                          ],
                          *ackCh
                        )
                      }
                    }
                  }
                }
              }
            }
          } |
          // Tests that a user's bond is added to the bonds map properly and all balances change accordingly.
          contract test_bonding_succeeds(rhoSpec, _, ackCh) = {
            new setupCh, retCh, initialPosBalanceCh, finalPosBalanceCh,
                initialUserBalanceCh, finalUserBalanceCh,
                initialCoopBalanceCh, finalCoopBalanceCh,
                initialBondsCh, finalBondsCh, rewardsCh
            in {
              prepareUser!("1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", *setupCh) |
              for (@userPubKey, _, @userVault, @userDeployerId <- setupCh) {
                getPosBalance!(*initialPosBalanceCh) |
                getCoopBalance!(*initialCoopBalanceCh) |
                @userVault!("balance", *initialUserBalanceCh) |
                @PoS!("getBonds", *initialBondsCh) |
                for (@initialPosBalance  <- initialPosBalanceCh;
                     @initialUserBalance <- initialUserBalanceCh;
                     @initialCoopBalance <- initialCoopBalanceCh;
                     @initialBonds       <- initialBondsCh) {
                  match 100 {
                    bondAmt => {
                      @PoS!("bond", userDeployerId, bondAmt, *retCh) |
                      for (@(true, _) <- retCh) {
                        @PoS!("getBonds", *finalBondsCh) |
                        getPosBalance!(*finalPosBalanceCh) |
                        getCoopBalance!(*finalCoopBalanceCh) |
                        @userVault!("balance", *finalUserBalanceCh) |
                        @PoS!("getRewards", *rewardsCh) |
                        for (@finalPosBalance  <- finalPosBalanceCh;
                             @finalUserBalance <- finalUserBalanceCh;
                             @finalCoopBalance <- finalCoopBalanceCh;
                             @finalBonds       <- finalBondsCh;
                             @rewards          <- rewardsCh) {
                          rhoSpec!("assertMany",
                            [
                              ((bondAmt, "==", finalBonds.get(userPubKey)), "the user's bond is expected in the final map"),
                              ((bondAmt, "==", initialUserBalance - finalUserBalance), "the user account decreases accordingly"),
                              ((bondAmt, "==", finalPosBalance - initialPosBalance), "the PoS account increases accordingly"),
                              ((finalCoopBalance, "==", initialCoopBalance), "Coop vault balance does not change"),
                              ((Nil, "==", initialBonds.get(userPubKey)), "the user's bond is not expected in the initial map"),
                              ((0, "==", rewards.getOrElse(userPubKey, 0)), "new validator should not have any rewards")
                            ],
                            *ackCh
                          )
                        }
                      }
                    }
                  }
                }
              }
            }
          } |
          // Tests that when a user requests to bond, they are added to the bond map with the appropriate bond stake.
          // Rewards shouldn't change with a bond request because these funds are just accumulated into the PoS vault during closeBlock.
          // The user's balance should decrease by the bond amount after their bonding request is processed.
          // After withdrawing, the validator should be moved to the withdrawers map with the appropriate quarantine period.
          // Caution: there is interaction between this test and test_withdraw_succeeds because block numbers are manipulated.
          contract test_withdraw_succeeds(rhoSpec, _, ackCh) = {
            new setupCh, bondCh,
                initialPosBalanceCh, finalPosBalanceCh,
                initialUserBalanceCh, finalUserBalanceCh,
                initialRewardsCh, finalRewardsCh,
                initialBondsCh, finalBondsCh,
                withdrawCh, closeBlockCh, quarantineCh, epochCh, quarantinePeriodCh,
                withdrawersCh, setBlockData(`rho:test:block:data:set`), blockDataCh
            in {
              prepareUser!("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", *setupCh) |
              for (@userPubKey, _, @userVault, @userDeployerId <- setupCh) {
                getPosBalance!(*initialPosBalanceCh) |
                @userVault!("balance", *initialUserBalanceCh) |
                @PoS!("getBonds", *initialBondsCh) |
                @PoS!("getRewards", *initialRewardsCh) |
                @PoS!("getQuarantineLength", *quarantineCh) |
                @PoS!("getEpochLength", *epochCh) |
                for (@initialPosBalance  <- initialPosBalanceCh;
                     @initialUserBalance <- initialUserBalanceCh;
                     @initialBonds       <- initialBondsCh;
                     @initialRewards     <- initialRewardsCh;
                     @epochLength        <- epochCh;
                     @quarantineLength   <- quarantineCh) {
                  // block number is set for after a quarantine period so this validator will appear in the initial and final bonds map in test_validator_is_paid_after_withdraw
                  match (100, 2 * epochLength * quarantineLength) {
                    (bondAmt, blockNumber) => {
                      @PoS!("bond", userDeployerId, bondAmt, *bondCh) |
                      setBlockData!("blockNumber", blockNumber, *blockDataCh) |
                      for (@(true, _) <- bondCh;
                           _          <- blockDataCh) {
                        @PoS!("withdraw", userDeployerId, *withdrawCh) |
                        for (_ <- withdrawCh) {
                          closeBlock!(*closeBlockCh) |
                          for (_ <- closeBlockCh) {
                            @PoS!("getBonds", *finalBondsCh) |
                            getPosBalance!(*finalPosBalanceCh) |
                            @userVault!("balance", *finalUserBalanceCh) |
                            @PoS!("getRewards", *finalRewardsCh) |
                            @PoS!("getWithdrawers", *withdrawersCh) |
                            quarantinePeriodCh!(quarantineLength + epochLength * (1 + blockNumber / epochLength)) |
                            for (@finalPosBalance  <- finalPosBalanceCh;
                                 @finalUserBalance <- finalUserBalanceCh;
                                 @finalBonds       <- finalBondsCh;
                                 @finalRewards     <- finalRewardsCh;
                                 @withdrawers      <- withdrawersCh;
                                 @quarantinePeriod <- quarantinePeriodCh) {
                              rhoSpec!("assertMany",
                                [
                                  ((finalBonds, "==", initialBonds.set(userPubKey, bondAmt)), "user is correctly added to the bond map"),
                                  ((finalRewards, "==", initialRewards), "rewards don't change for bonding"),
                                  ((finalUserBalance, "==", initialUserBalance - bondAmt), "user balance should change by bond amount"),
                                  ((finalPosBalance, "==", initialPosBalance + bondAmt), "pos balance should change by bond amount"),
                                  ((true, "==", withdrawers.contains(userPubKey)), "withdrawer is moved to withdrawers map"),
                                  ((quarantinePeriod, "==", withdrawers.get(userPubKey)), "withdrawer has correct quarantine finish block")
                                ],
                                *ackCh
                              )
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } |
          // Tests that a withdrawing validator is only paid after their quarantine period finishes and that when they are paid,
          // their bond is returned to their vault and they are paid the rewards they have accumulated.
          // Caution: there is interaction between this test and test_withdraw_succeeds because block numbers are manipulated.
          contract test_validator_is_paid_after_withdraw(rhoSpec, _, ackCh) = {
            new setupCh, bondCh, chargeCh, refundCh,
                initialValidatorBalanceCh, finalValidatorBalanceCh,
                initialBondsCh, finalBondsCh,
                withdrawCh, closeBlockCh, epochCh, quarantineCh,
                setBlockData(`rho:test:block:data:set`),
                blockDataCh, rewardsCh, validatorRewardCh,
                intermediateValidatorBalanceCh, withdrawersCh
            in {
              prepareUser!("bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb", *setupCh) |
              for (@validatorPubKey, _, @validatorVault, @validatorDeployerId <- setupCh) {
                @validatorVault!("balance", *initialValidatorBalanceCh) |
                @PoS!("getBonds", *initialBondsCh) |
                @PoS!("getQuarantineLength", *quarantineCh) |
                @PoS!("getEpochLength", *epochCh) |
                for (@initialValidatorBalance <- initialValidatorBalanceCh;
                     @initialBonds            <- initialBondsCh;
                     @epochLength             <- epochCh;
                     @quarantineLength        <- quarantineCh) {
                  match (100, 100, 0, 1) {
                    (bondAmt, chargeAmt, refundAmt, blockNumber) => {
                      @PoS!("bond", validatorDeployerId, bondAmt, *bondCh) |
                      for (@(true, _) <- bondCh) {
                        closeBlock!(*closeBlockCh) |
                        for (_ <- closeBlockCh) {
                          prepareUser!("cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc", *setupCh) |
                          for (@userPubKey, _, @userVault, @userDeployerId <- setupCh) {
                            @PoS!("chargeDeploy", userDeployerId, chargeAmt, sysAuthToken, *chargeCh) |
                            @PoS!("refundDeploy", refundAmt, sysAuthToken, *refundCh) |
                            for (@(true, _) <- chargeCh;
                                 @(true, _) <- refundCh){
                              closeBlock!(*closeBlockCh) |
                              for (_ <- closeBlockCh) {
                                @PoS!("getRewards", *rewardsCh) |
                                for (@rewards <- rewardsCh) {
                                  validatorRewardCh!(rewards.getOrElse(validatorPubKey, 0)) |
                                  for (@validatorReward <- validatorRewardCh) {
                                    setBlockData!("blockNumber", blockNumber, *blockDataCh) |
                                    @PoS!("getWithdrawers", *withdrawersCh) |
                                    for (_                   <- blockDataCh;
                                         @initialWithdrawers <- withdrawersCh) {
                                      @PoS!("withdraw", validatorDeployerId, *withdrawCh) |
                                      for (_ <- withdrawCh) {
                                        match quarantineLength + epochLength * (1 + blockNumber / epochLength) {
                                          quarantinePeriod => {
                                            setBlockData!("blockNumber", quarantinePeriod - 1, *blockDataCh) |
                                            for (_ <- blockDataCh) {
                                              @PoS!("getWithdrawers", *withdrawersCh) |
                                              @validatorVault!("balance", *intermediateValidatorBalanceCh) |
                                              for (@intermediateWithdrawers      <- withdrawersCh;
                                                   @intermediateValidatorBalance <- intermediateValidatorBalanceCh) {
                                                // Sets blockNumber to the soonest epoch change after quarantine period is finished.
                                                if (quarantineLength % epochLength == 0) {
                                                  setBlockData!("blockNumber", quarantinePeriod, *blockDataCh)
                                                } else {
                                                  setBlockData!("blockNumber", quarantinePeriod + epochLength - (quarantineLength % epochLength), *blockDataCh)
                                                } |
                                                for (_ <- blockDataCh) {
                                                  closeBlock!(*closeBlockCh) |
                                                  for (_ <- closeBlockCh) {
                                                    @validatorVault!("balance", *finalValidatorBalanceCh) |
                                                    @PoS!("getBonds", *finalBondsCh) |
                                                    @PoS!("getWithdrawers", *withdrawersCh) |
                                                    for (@finalBonds            <- finalBondsCh;
                                                         @finalWithdrawers      <- withdrawersCh;
                                                         @finalValidatorBalance <- finalValidatorBalanceCh) {
                                                      rhoSpec!("assertMany",
                                                        [
                                                          ((finalBonds, "==", initialBonds), "bonds don't change after the same user bonds and withdraws successfully"),
                                                          ((intermediateValidatorBalance, "==", initialValidatorBalance - bondAmt), "withdrawer is not paid before quarantine period is over"),
                                                          ((validatorReward, "==", finalValidatorBalance - initialValidatorBalance), "after payment, validator's balance only changes by their accumulated rewards"),
                                                          ((false, "==", initialWithdrawers.contains(validatorPubKey)), "before validator withdraws, they should not be in withdrawers map"),
                                                          ((true, "==", intermediateWithdrawers.contains(validatorPubKey)), "after validator requests to withdraw and before quarantine is finished, they should be in withdrawers map"),
                                                          ((false, "==", finalWithdrawers.contains(validatorPubKey)), "after quarantine is finished, validator should not be in withdrawers map")
                                                        ],
                                                        *ackCh
                                                      )
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } |
          //
          contract test_multiple_bonding_succeeds(rhoSpec, _, ackCh) = {
            new setupCh, initialPosBalanceCh, finalPosBalanceCh,
                user1BondCh, user2BondCh, initialBondsCh, finalBondsCh,
                initialUser1BalanceCh, finalUser1BalanceCh,
                initialUser2BalanceCh, finalUser2BalanceCh,
                initialCoopBalanceCh, finalCoopBalanceCh
            in {
              prepareUser!("2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222", *setupCh) |
              for (@user1PubKey, _, @user1Vault, @user1DeployerId <- setupCh) {
                getPosBalance!(*initialPosBalanceCh) |
                getCoopBalance!(*initialCoopBalanceCh) |
                @PoS!("getBonds", *initialBondsCh) |
                @user1Vault!("balance", *initialUser1BalanceCh) |
                for (@initialPosBalance   <- initialPosBalanceCh;
                     @initialUser1Balance <- initialUser1BalanceCh;
                     @initialCoopBalance  <- initialCoopBalanceCh;
                     @initialBonds        <- initialBondsCh) {
                  match (100, 200) {
                    (user1Bond, user2Bond) => {
                      @PoS!("bond", user1DeployerId, user1Bond, *user1BondCh) |
                      for (@(true, _) <- user1BondCh) {
                        stdlog!("info", "first bond") |
                        prepareUser!("3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333", *setupCh) |
                        for (@user2PubKey, _, @user2Vault, @user2DeployerId <- setupCh) {
                          @user2Vault!("balance", *initialUser2BalanceCh) |
                          for (@initialUser2Balance <- initialUser2BalanceCh) {
                            @PoS!("bond", user2DeployerId, user2Bond, *user2BondCh) |
                            for (@(true, _) <- user2BondCh) {
                              @PoS!("getBonds", *finalBondsCh) |
                              getPosBalance!(*finalPosBalanceCh) |
                              getCoopBalance!(*finalCoopBalanceCh) |
                              @user1Vault!("balance", *finalUser1BalanceCh) |
                              @user2Vault!("balance", *finalUser2BalanceCh) |
                              for (@finalPosBalance   <- finalPosBalanceCh;
                                   @finalUser1Balance <- finalUser1BalanceCh;
                                   @finalUser2Balance <- finalUser2BalanceCh;
                                   @finalCoopBalance  <- finalCoopBalanceCh;
                                   @finalBonds        <- finalBondsCh) {
                                rhoSpec!("assertMany",
                                  [
                                    ((0, "==", initialBonds.getOrElse(user1PubKey, 0)), "user1's bond is not expected in the initial map"),
                                    ((0, "==", initialBonds.getOrElse(user2PubKey, 0)), "user2's bond is not expected in the initial map"),
                                    ((user1Bond, "==", finalBonds.get(user1PubKey)), "user1's bond is expected in the final map"),
                                    ((user2Bond, "==", finalBonds.get(user2PubKey)), "user2's bond is expected in the final map"),
                                    ((user1Bond, "==", initialUser1Balance - finalUser1Balance), "user1's account decreases as expected"),
                                    ((user2Bond, "==", initialUser2Balance - finalUser2Balance), "user2's account decreases as expected"),
                                    ((finalCoopBalance, "==", initialCoopBalance), "Coop vault balance does not change"),
                                    ((user1Bond + user2Bond, "==", finalPosBalance - initialPosBalance), "the PoS account increases as expected")
                                  ],
                                  *ackCh
                                )
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } |
          contract test_pay_succeeds(rhoSpec, _, ackCh) = {
            new setupCh, closeBlockCh, retCh0, retCh1, initialPosBalanceCh, finalPosBalanceCh,
                initialUser1BalanceCh, finalUser1BalanceCh,
                initialRewardsCh, finalRewardsCh,
                computeDelta, deltaRewardsCh, deltaSumCh, sumDelta,
                isPositive, allRewardsPositiveCh
            in {
              prepareUser!("4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444", *setupCh) |
              for (@validatorPubKey, _, _, @validatorDeployerId <- setupCh) {
                match (100, 100, 0) {
                  (validatorBond, userCharge, userRefund) => {
                    @PoS!("bond", validatorDeployerId, validatorBond, *setupCh) |
                    for (@(true, _) <- setupCh) {
                      closeBlock!(*closeBlockCh) |
                      prepareUser!("5555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555", *setupCh) |
                      for (_, _, @userVault, @userDeployerId <- setupCh;
                           _                                 <- closeBlockCh) {
                        getPosBalance!(*initialPosBalanceCh) |
                        @userVault!("balance", *initialUser1BalanceCh) |
                        @PoS!("getRewards", *initialRewardsCh) |
                        for (@initialPosBalance   <- initialPosBalanceCh;
                             @initialUser1Balance <- initialUser1BalanceCh;
                             @initialRewards      <- initialRewardsCh) {
                          @PoS!("chargeDeploy", userDeployerId, userCharge, sysAuthToken, *retCh0) |
                          @PoS!("refundDeploy", userRefund, sysAuthToken, *retCh1) |
                          for (@(true, _) <- retCh0;
                               @(true, _) <- retCh1) {
                            closeBlock!(*closeBlockCh) |
                            for (_ <- closeBlockCh) {
                              getPosBalance!(*finalPosBalanceCh) |
                              @userVault!("balance", *finalUser1BalanceCh) |
                              @PoS!("getRewards", *finalRewardsCh) |
                              for (@finalPosBalance   <- finalPosBalanceCh;
                                   @finalUser1Balance <- finalUser1BalanceCh;
                                   @finalRewards      <- finalRewardsCh) {
                                @ListOps!("fold", finalRewards.toList(), {}, *computeDelta, *deltaRewardsCh) |
                                contract computeDelta(@(pk, finalReward), @acc, resultCh) = {
                                  resultCh!(acc.set(pk, finalReward - initialRewards.getOrElse(pk, 0)))
                                } |
                                for (@deltaRewards <- deltaRewardsCh) {
                                  @ListOps!("forall", deltaRewards, *isPositive, *allRewardsPositiveCh) |
                                  contract isPositive(@n, resultCh) = {
                                    resultCh!(n > 0)
                                  } |
                                  @ListOps!("fold", deltaRewards.toList(), 0, *sumDelta, *deltaSumCh) |
                                  contract sumDelta(@(_, delta), @acc, resultCh) = {
                                    resultCh!(acc + delta)
                                  } |
                                  rhoSpec!("assertMany",
                                    [
                                      ((userCharge - userRefund, "==", initialUser1Balance - finalUser1Balance), "the user account decreases"),
                                      ((userCharge - userRefund, "==", finalPosBalance - initialPosBalance), "the pos account increases"),
                                      //TODO: active validator stake-weighted reward
                                      ((19, "==", finalRewards.get(validatorPubKey)), "the validator's finalRewards is as expected"),
                                      //TODO use arbitrary precision numbers instead of long ints
                                      ((96, "== <-", *deltaSumCh), "the sum difference should equal the payment"),
                                      ((true, "== <-", *allRewardsPositiveCh), "the rewards can only grow")
                                    ],
                                    *ackCh
                                  )
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } |

          contract test_refund_succeeds(rhoSpec, _, ackCh) = {
            new prepareUserAck,
                bondAck,
                closeBlockAck,
                posBalanceCh,
                userBalanceCh,
                rewardsCh,
                chargeDeployAck,
                refundDeployAck,
                computeDelta, deltaRewardsCh, deltaSumCh, sumDelta,
                isPositive, allRewardsPositiveCh
            in {
              prepareUser!("dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd", *prepareUserAck) |
              for (@validatorPubKey, _, _, @validatorDeployerId <- prepareUserAck) {
                match (100, 100, 50) {
                  (validatorBond, userCharge, userRefund) => {
                    @PoS!("bond", validatorDeployerId, validatorBond, *bondAck) |
                    for (@(true, _) <- bondAck) {
                      closeBlock!(*closeBlockAck) |
                      prepareUser!("eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", *prepareUserAck) |
                      for (_, _, @userVault, @userDeployerId <- prepareUserAck;
                           _                                 <- closeBlockAck) {
                        getPosBalance!(*posBalanceCh) |
                        @userVault!("balance", *userBalanceCh) |
                        @PoS!("getRewards", *rewardsCh) |
                        for (@initialPosBalance  <- posBalanceCh;
                             @initialUserBalance <- userBalanceCh;
                             @initialRewards     <- rewardsCh) {
                          @PoS!("chargeDeploy", userDeployerId, userCharge, sysAuthToken, *chargeDeployAck) |
                          @PoS!("refundDeploy", userRefund, sysAuthToken, *refundDeployAck) |
                          for (@(true, _) <- chargeDeployAck;
                               @(true, _) <- refundDeployAck) {
                            closeBlock!(*closeBlockAck) |
                            for (_ <- closeBlockAck) {
                              getPosBalance!(*posBalanceCh) |
                              @userVault!("balance", *userBalanceCh) |
                              @PoS!("getRewards", *rewardsCh) |
                              for (@finalPosBalance  <- posBalanceCh;
                                   @finalUserBalance <- userBalanceCh;
                                   @finalRewards     <- rewardsCh) {
                                @ListOps!("fold", finalRewards.toList(), {}, *computeDelta, *deltaRewardsCh) |
                                contract computeDelta(@(pk, finalReward), @acc, resultCh) = {
                                  resultCh!(acc.set(pk, finalReward - initialRewards.getOrElse(pk, 0)))
                                } |
                                for (@deltaRewards <- deltaRewardsCh) {
                                  @ListOps!("forall", deltaRewards, *isPositive, *allRewardsPositiveCh) |
                                  contract isPositive(@n, resultCh) = {
                                    resultCh!(n > 0)
                                  } |
                                  @ListOps!("fold", deltaRewards.toList(), 0, *sumDelta, *deltaSumCh) |
                                  contract sumDelta(@(_, delta), @acc, resultCh) = {
                                    resultCh!(acc + delta)
                                  } |
                                  rhoSpec!("assertMany",
                                    [
                                      ((userCharge - userRefund, "==", initialUserBalance - finalUserBalance), "the user account decreases"),
                                      ((userCharge - userRefund, "==", finalPosBalance - initialPosBalance), "the pos account increases"),
                                      //TODO: active validator stake-weighted reward
                                      ((8, "==", finalRewards.get(validatorPubKey)), "the validator's finalRewards is as expected"),
                                      //TODO use arbitrary precision numbers instead of long ints
                                      ((48, "== <-", *deltaSumCh), "the sum difference should equal the payment"),
                                      ((true, "== <-", *allRewardsPositiveCh), "the rewards can only grow")
                                    ],
                                    *ackCh
                                  )
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } |

          contract test_bonding_fails_if_deposit_fails(rhoSpec, _, ackCh) = {
            test_bonding_failure!(*rhoSpec, "6666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666", 20000, "Bond deposit failed: Insufficient funds", *ackCh)
          } |

          contract test_bonding_fails_if_bond_too_small(rhoSpec, _, ackCh) = {
            test_bonding_failure!(*rhoSpec, "7777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777", -1, "Bond is less than minimum!", *ackCh)
          } |

          contract test_bonding_fails_if_already_bonded(rhoSpec, _, ackCh) = {
            new setupCh, initialBondsCh, bond1Ch, bond2Ch, bondsCh,
                finalRewardsCh, initialRewardsCh
            in {
              prepareUser!("8888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888", *setupCh) |
              for (_, _, _, @userDeployerId <- setupCh) {
                match (150, 100) {
                  (userBond1, userBond2) => {
                    @PoS!("bond", userDeployerId, userBond1, *bond1Ch) |
                    for (@(bond1Result, _) <- bond1Ch) {
                      @PoS!("getBonds", *initialBondsCh) |
                      @PoS!("getRewards", *initialRewardsCh) |
                      for (@initialBonds   <- initialBondsCh;
                           @initialRewards <- initialRewardsCh) {
                        @PoS!("bond", userDeployerId, userBond2, *bond2Ch) |
                        for (@(bond2Result, msg2) <- bond2Ch) {
                          @PoS!("getBonds", *bondsCh) |
                          @PoS!("getRewards", *finalRewardsCh) |
                          rhoSpec!("assertMany",
                            [
                              ((true, "==", bond1Result), "the first bond should succeed"),
                              ((false, "==", bond2Result), "the second bond should fail"),
                              (("Public key is already bonded.", "==", msg2), "the message should be as expected"),
                              ((initialBonds, "== <-", *bondsCh), "the bonds map remains unchanged after second bond request"),
                              ((initialRewards, "== <-", *finalRewardsCh), "the rewards map remains unchanged after second bond request")
                            ],
                            *ackCh
                          )
                        }
                      }
                    }
                  }
                }
              }
            }
          } |

          contract test_bonding_failure(rhoSpec, @pk, @transferAmount, @expectedMsg, ackCh) = {
            new setupCh, retCh, bondsCh,
                finalRewardsCh, initialRewardsCh in {
              prepareUser!(pk, *setupCh) |
              for (_, _, _, @deployerId <- setupCh) {
                @PoS!("getBonds", *bondsCh) |
                @PoS!("getRewards", *initialRewardsCh) |
                for (@initialBonds   <- bondsCh;
                     @initialRewards <- initialRewardsCh) {
                  @PoS!("bond", deployerId, transferAmount, *retCh) |
                  for (@(result, msg) <- retCh) {
                    @PoS!("getBonds", *bondsCh) |
                    @PoS!("getRewards", *finalRewardsCh) |
                    rhoSpec!("assertMany",
                      [
                        ((expectedMsg, "==", msg), "the message should be as epected"),
                        ((false, "==", result), "the bond should fail"),
                        ((initialBonds, "== <-", *bondsCh), "the bonds map remains unchanged after failed bond"),
                        ((initialRewards, "== <-", *finalRewardsCh), "the rewards map remains unchanged after failed bond")
                      ],
                      *ackCh
                    )
                  }
                }
              }
            }
          } |

          contract test_dont_reward_inactive_validators(rhoSpec, _, ackCh) = {
            new setupCh, closeBlockCh, chargeCh,
                refundCh, finalRewardsCh
            in {
              prepareUser!("9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999", *setupCh) |
              for (@validatorPubKey, _, _, @validatorDeployerId <- setupCh) {
                @PoS!("bond", validatorDeployerId, 100, *setupCh) |
                for (@(true, _) <- setupCh) {
                  prepareUser!("0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", *setupCh) |
                  for (@user1PubKey, _, @user1Vault, @user1DeployerId <- setupCh) {
                    @PoS!("chargeDeploy", user1DeployerId, 100, sysAuthToken, *chargeCh) |
                    @PoS!("refundDeploy", 10, sysAuthToken, *refundCh) |
                    for (@(true, _) <- chargeCh;
                         @(true, _) <- refundCh) {
                      closeBlock!(*closeBlockCh) |
                      for (_ <- closeBlockCh) {
                        @PoS!("getRewards", *finalRewardsCh) |
                        for(@finalRewards <- finalRewardsCh) {
                          rhoSpec!("assertMany",
                            [
                              ((Nil, "==", finalRewards.get(validatorPubKey)), "the new validator should have no reward")
                            ],
                            *ackCh
                          )
                        }
                      }
                    }
                  }
                }
              }
            }
          } |

          contract getPosBalance(retCh) = {
            new accBalances, vaultsCh, posVaultBalanceCh in {
              contract accBalances(@(_, _, vault), @acc, resultCh) = {
                new balanceCh in {
                  @vault!("balance", *balanceCh) |
                  for (@balance <- balanceCh) {
                    resultCh!(acc + balance)
                  }
                }
              } |
              @posVault!("balance", *posVaultBalanceCh) |
              for (@posVaultBalance <- posVaultBalanceCh) {
                @PoS!("getActiveValidatorVaults", *vaultsCh) |
                for (@vaults <- vaultsCh) {
                  @ListOps!("fold", vaults, posVaultBalance, *accBalances, *retCh)
                }
              }
            }
          } |

          contract closeBlock(ackCh) = {
            new ackCh0, activeValidatorsCh, setBlockData(`rho:test:block:data:set`), blockDataSet in {
              @PoS!("closeBlock", sysAuthToken, *ackCh0) |
              for (@ack              <- ackCh0) {
                @PoS!("getActiveValidators", *activeValidatorsCh) |
                for (@activeValidators <- activeValidatorsCh){
                  // For testing we need one of the active validators to be the block sender
                  setBlockData!("sender", activeValidators.nth(0), *blockDataSet) |
                  for (_ <- blockDataSet) {
                    ackCh!(ack)
                  }
                }
              }
            }
          } |

          contract getCoopBalance(returnCh) = {
            new retCh in {
              @PoS!("getCoopVault", *retCh) |
              for (@(_, _, coopVault) <- retCh) {
                @coopVault!("balance", *returnCh)
              }
            }
          } |

          contract test_commit_random(rhoSpec, _, ackCh) = {
            new setupCh, closeBlockCh, retCh,
                finalRewardsCh, computeHash(`rho:crypto:keccak256Hash`), hash00Ch, hashFFCh
            in {
              prepareUser!("dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd", *setupCh) |
              for (@validatorPubKey, _, _, @validatorDeployerId <- setupCh) {
                @PoS!("revealRandom", validatorDeployerId, "FF".hexToBytes(), *retCh) |

                computeHash!("00".hexToBytes(), *hash00Ch) |
                computeHash!("FF".hexToBytes(), *hashFFCh) |

                for (@result0 <- retCh;
                     @hash00 <- hash00Ch;
                     @hashFF <- hashFFCh) {
                  @PoS!("commitRandomImage", validatorDeployerId, hash00, *retCh) |
                  for (@result1 <- retCh) {
                    @PoS!("commitRandomImage", validatorDeployerId, hashFF, *retCh) |
                    for (@result2 <- retCh) {
                      @PoS!("revealRandom", validatorDeployerId, "FF".hexToBytes(), *retCh) |
                      for (@result3 <- retCh) {
                        @PoS!("revealRandom", validatorDeployerId, "00".hexToBytes(), *retCh) |
                        for (@result4 <- retCh) {
                          rhoSpec!("assertMany",
                            [
                              (((false, "Previously committed random image not found"), "==", result0), "commitRandom before commitRandomImage fails"),
                              ((true, "==", result1), "the first commitRandomImage is successful"),
                              (((false, "Image already committed"), "==", result2), "the second commitRandomImage for the same validator fails"),
                              (((false, "Previously committed image doesn't match the random number"), "==", result3), "the random value doesn't match the commited image stored by the first commitRandomImage"),
                              ((true, "==", result4), "the random value matches the commited image")
                            ],
                            *ackCh
                          )
                        }
                      }
                    }
                  }
                }
              }
            }
          } |
          // Checks that the slashed validator's bond and rewards are moved from the PoS vault to the Coop vault and
          // reduced to 0 in the bond and committedRewards maps and that they are immediately moved to the withdrawers map.
          contract test_slashing_vaults_and_state(rhoSpec, _, ackCh) = {
            new setInvalidBlocks(`rho:test:casper:invalidBlocks:set`),
                computeHash(`rho:crypto:keccak256Hash`), hashCh, invalidBlocksSetCh,
                initialBondSumCh, chargeCh, refundCh, initialCoopBalanceCh, finalCoopBalanceCh,
                setupCh, slashCh, activeValidatorsCh, withdrawersCh,
                initialPosBalanceCh, finalPosBalanceCh,
                initialUserBalanceCh, finalUserBalanceCh,
                initialRewardsCh, finalRewardsCh,
                initialBondsCh, finalBondsCh
            in {
              prepareUser!("bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb", *setupCh) |
              for (_, _, @userVault, @userDeployerId <- setupCh) {
                @PoS!("getActiveValidators", *activeValidatorsCh) |
                @PoS!("getBonds", *initialBondsCh) |
                getCoopBalance!(*initialCoopBalanceCh) |
                for (@activeValidators   <- activeValidatorsCh;
                     @initialBonds       <- initialBondsCh;
                     @initialCoopBalance <- initialCoopBalanceCh) {
                  match (100, 0) {
                    (chargeAmt, refundAmt) => {
                      @PoS!("chargeDeploy", userDeployerId, chargeAmt, sysAuthToken, *chargeCh) |
                      @PoS!("refundDeploy", refundAmt, sysAuthToken, *refundCh) |
                      for (@(true, _) <- chargeCh;
                           @(true, _) <- refundCh) {
                        match activeValidators.nth(3) {
                          slashedValidator => {
                            computeHash!(slashedValidator, *hashCh) |
                            for (@hash <- hashCh) {
                              getPosBalance!(*initialPosBalanceCh) |
                              @PoS!("getRewards", *initialRewardsCh) |
                              @userVault!("balance", *initialUserBalanceCh) |
                              setInvalidBlocks!({hash : slashedValidator}, *invalidBlocksSetCh) |
                              for (_                   <- invalidBlocksSetCh;
                                   @initialUserBalance <- initialUserBalanceCh;
                                   @initialRewards     <- initialRewardsCh;
                                   @initialPosBalance  <- initialPosBalanceCh) {
                                @PoS!("slash", userDeployerId, hash, sysAuthToken, *slashCh) |
                                for (@(true, _) <- slashCh) {
                                  @PoS!("getBonds", *finalBondsCh) |
                                  getPosBalance!(*finalPosBalanceCh) |
                                  @userVault!("balance", *finalUserBalanceCh) |
                                  @PoS!("getRewards", *finalRewardsCh) |
                                  @PoS!("getWithdrawers", *withdrawersCh) |
                                  getCoopBalance!(*finalCoopBalanceCh) |
                                  for (@finalPosBalance  <- finalPosBalanceCh;
                                       @finalUserBalance <- finalUserBalanceCh;
                                       @finalBonds       <- finalBondsCh;
                                       @finalRewards     <- finalRewardsCh;
                                       @withdrawers      <- withdrawersCh;
                                       @finalCoopBalance <- finalCoopBalanceCh) {
                                    rhoSpec!("assertMany",
                                      [
                                        ((finalBonds, "==", initialBonds.set(slashedValidator, 0)), "Slashed validator's bond is reduced to 0"),
                                        ((0, "==", finalRewards.get(slashedValidator)), "Slashed validator's rewards are reduced to 0"),
                                        ((true, "==", withdrawers.contains(slashedValidator)), "Slashed validator is immediately moved to withdrawers map"),
                                        ((finalPosBalance, "==", initialPosBalance - initialBonds.get(slashedValidator) - initialRewards.get(slashedValidator)), "Slashed validator's funds are transferred out of the PoS vault"),
                                        ((finalCoopBalance, "==", initialCoopBalance + initialBonds.get(slashedValidator) + initialRewards.get(slashedValidator)), "Slashed validator's funds are transferred to the Coop vault")
                                      ],
                                      *ackCh
                                    )
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
