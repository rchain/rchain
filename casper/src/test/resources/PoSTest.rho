//scalapackage coop.rchain.rholang.mint

//requires Pos, RhoSpec

match (
  "047b43d6548b72813b89ac1b9f9ca67624a8b372feedd71d4e2da036384a3e1236812227e524e6f237cde5f80dbb921cac12e6500791e9a9ed1254a745a816fe1f".hexToBytes()
) {
  posPubKey => {
    new
      rl(`rho:registry:lookup`),
      stdlog(`rho:io:stdlog`),
      revAddressOps(`rho:rev:address`),
      posRevAddressCh, posVaultCh,
      RhoSpecCh, PoSCh, RevVaultCh, ListOpsCh,
      setup, prepareUser,
      test_bonding_fails_if_bond_too_small,
      test_dont_pay_inactive_validators,
      test_bonding_failure
    in {
      revAddressOps!("fromPublicKey", posPubKey, *posRevAddressCh) |
      rl!(`rho:rchain:revVault`, *RevVaultCh) |
      rl!(`rho:rchain:pos`, *PoSCh) |
      rl!(`rho:lang:listOps`, *ListOpsCh) |
      rl!(`rho:id:zphjgsfy13h1k85isc8rtwtgt3t9zzt5pjd5ihykfmyapfc4wt3x5h`, *RhoSpecCh) |
      for(@(_, RhoSpec) <- RhoSpecCh;
          @(_, PoS) <- PoSCh;
          @(_, RevVault) <- RevVaultCh;
          @posRevAddress <- posRevAddressCh;
          @(_, ListOps) <- ListOpsCh) {
        stdlog!("info", {"posRevAddress":posRevAddress}) |

        @RevVault!("findOrCreate", posRevAddress, *posVaultCh) |
        for(@(true, posVault) <- posVaultCh) {
          @RhoSpec!("testSuite", *setup,
            [
              ("bonding fails is bond is too small", *test_bonding_fails_if_bond_too_small),
              ("payment is not distributed to inactive validators", *test_dont_pay_inactive_validators)
            ]) |

          contract setup(_, retCh) = {
            retCh!({})
          } |

          contract prepareUser(@pk, retCh) = {
            stdlog!("info", ("preparing user ", pk)) |
            new setDeployData(`rho:test:deploy:set`), identitySet, revAddrCh, vaultCh in {
              setDeployData!("userId", pk.hexToBytes(), *identitySet) |
              revAddressOps!("fromPublicKey", pk.hexToBytes(), *revAddrCh) |
              for (_ <- identitySet; @revAddress <- revAddrCh) {
                @RevVault!("findOrCreate", revAddress, *vaultCh) |
                for (@(true, vault) <- vaultCh) {
                  retCh!(pk.hexToBytes(), revAddress, vault)
                }
              }
            }
          } |

          contract test_bonding_fails_if_bond_too_small(rhoSpec, _, ackCh) = {
            test_bonding_failure!(*rhoSpec, "7777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777", -1, "Bond is less than minimum!", *ackCh)
          } |

          contract test_bonding_failure(rhoSpec, @pk, @transferAmount, @expectedMsg, ackCh) = {
            new setupCh, retCh, bondsCh,
                finalRewardsCh, initialRewardsCh in {
              prepareUser!(pk, *setupCh) |
              for (_, _, _ <- setupCh) {
                @PoS!("getBonds", *bondsCh) |
                @PoS!("getRewards", *initialRewardsCh) |
                for ( @initialBonds <- bondsCh;
                      @initialRewards <- initialRewardsCh) {
                  @PoS!("bond", transferAmount, *retCh) |

                  for ( @(result, msg) <- retCh) {
                    @PoS!("getBonds", *bondsCh) |
                    @PoS!("getRewards", *finalRewardsCh) |
                    rhoSpec!("assertMany",
                      [
                        ((expectedMsg, "==", msg), "the message should be as epected"),
                        ((false, "==", result), "the bond should fail"),
                        ((initialBonds, "== <-", *bondsCh), "the bonds map remains unchanged"),
                        ((initialRewards, "== <-", *finalRewardsCh), "the rewards map should not change")
                      ],
                      *ackCh
                    )
                  }
                }
              }
            }
          } |

          contract test_dont_pay_inactive_validators(rhoSpec, _, ackCh) = {
            new setupCh, closeBlockCh, retCh,
                finalRewardsCh
            in {
              prepareUser!("9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999", *setupCh) |
              for (@validatorPubKey, _, _ <- setupCh) {
                @PoS!("bond", 100, *setupCh) |
                for (@(true, _) <- setupCh) {
                  prepareUser!("0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", *setupCh) |
                  for (@user1PubKey, _, @user1Vault <- setupCh) {
                    @PoS!("pay", 100, *retCh) |
                    for ( @(true, _) <- retCh) {
                      @PoS!("closeBlock", *closeBlockCh) |
                      for (_ <- closeBlockCh) {
                        @PoS!("getRewards", *finalRewardsCh) |
                        for(@finalRewards <- finalRewardsCh) {
                          rhoSpec!("assertMany",
                            [
                              ((Nil, "==", finalRewards.get(validatorPubKey)), "the new validator should have no reward")
                            ],
                            *ackCh
                          )
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
