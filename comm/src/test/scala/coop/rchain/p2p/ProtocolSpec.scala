package coop.rchain.p2p

import org.scalatest._
import coop.rchain.comm.protocol.rchain._
import com.google.common.io.BaseEncoding
import coop.rchain.comm._, CommError._, NetworkProtocol._
import cats._, cats.data._, cats.implicits._
import coop.rchain.catscontrib._, Catscontrib._, ski._, Encryption._

import EffectsTestInstances._

class ProtocolSpec extends FunSpec with Matchers with BeforeAndAfterEach with AppendedClues {

  val encoder = BaseEncoding.base16().lowerCase()

  val src: ProtocolNode    = protocolNode("src", 30300)
  val remote: ProtocolNode = protocolNode("remote", 30301)
  val srcKeys              = PublicPrivateKeys(encoder.decode("ff00ff00"), encoder.decode("cc00cc00"))
  val remoteKeys           = PublicPrivateKeys(encoder.decode("ee00ee00"), encoder.decode("dd00dd00"))
  val nonce                = encoder.decode("00112233")

  type Effect[A] = CommErrT[Id, A]

  implicit val logEff           = new Log.NOPLog[Effect]
  implicit val timeEff          = new LogicalTime[Effect]
  implicit val metricEff        = new Metrics.MetricsNOP[Effect]
  implicit val communicationEff = new CommunicationStub[Effect](src)
  implicit val encryptionEff    = new EncryptionStub[Effect](srcKeys, nonce)
  implicit val keysStoreEff     = new Kvs.InMemoryKvs[Effect, PeerNode, Key]

  override def beforeEach(): Unit = {
    communicationEff.reset()
    encryptionEff.reset()
    keysStoreEff.keys.map(_.map(k => keysStoreEff.delete(k)))
  }

  describe("Node") {
    describe("when connecting to other remote node") {
      describe(" to which he was not connect in the past") {

        it("should first send EncryptionHanshakeMessage with its public key") {
          // given
          communicationEff.setResponses(kp(generateResponses(fstPhase, sndPhase)))
          // when
          Network.connect[Effect](remote)
          // then
          val EncryptionHandshakeMessage(proto, _) = communicationEff.requests(0)
          val Right(EncryptionHandshake(pk))       = NetworkProtocol.toEncryptionHandshake(proto)
          pk.toByteArray should equal(srcKeys.pub)
        }

        it("should then store remote's public key") {
          // given
          communicationEff.setResponses(kp(generateResponses(fstPhase, sndPhase)))
          // when
          Network.connect[Effect](remote)
          // then
          value(keysStoreEff.get(remote)).get should equal(remoteKeys.pub)
        }

        it("should then send encrypted ProtocolMessage") {
          // given
          communicationEff.setResponses(kp(generateResponses(fstPhase, sndPhase)))
          // when
          Network.connect[Effect](remote)
          // then
          val FrameMessage(proto, _) = communicationEff.requests(1)
          val Right(Frame(n, f))     = NetworkProtocol.toFrame(proto)

          n.toByteArray should equal(nonce) withClue ("nonce send should be equal to the one generated by Encryption")
          val (p, s, un, _) = encryptionEff.encryptions(0)
          p should equal(remoteKeys.pub) withClue ("remotes public should be used for encryption")
          s should equal(srcKeys.priv) withClue ("source private should be used for encryption")
          un should equal(nonce) withClue ("generated nounce should be used for encryption")
          Frameable
            .parseFrom(f.toByteArray)
            .message
            .protocolHandshake
            .map(_.nonce.toByteArray)
            .get should equal(nonce) withClue ("framed massaged should be ProtocolHandshake with nonce in it")
        }
      }
      describe(" to which he was connected in the past") {
        it("should skip encryption handshake")(pending)
        it("should init protocol handshake")(pending)
        it("should rollback to encryption handshake if initialized protocol handshake did not respond")(
          pending)
      }
    }

    describe("when receiving encryption handshake from remote node") {
      it("should send back its public key in response") {
        // given
        val receivedMessage =
          EncryptionHandshakeMessage(encryptionHandshake(src, remoteKeys), 1)
        // when
        Network.handleEncryptionHandshake[Effect](remote, receivedMessage)
        // then
        val EncryptionHandshakeResponseMessage(proto, _) = communicationEff.requests(0)
        val Right(EncryptionHandshakeResponse(pk)) =
          NetworkProtocol.toEncryptionHandshakeResponse(proto)
        pk.toByteArray should equal(srcKeys.pub)
      }

      it("should store remote's public key") {
        // given
        val receivedMessage =
          EncryptionHandshakeMessage(encryptionHandshake(src, remoteKeys), 1)
        // when
        Network.handleEncryptionHandshake[Effect](remote, receivedMessage)
        // then
        value(keysStoreEff.get(remote)).map(_.toList) should equal(Some(remoteKeys.pub.toList))
      }

      it("should not store remote's public key if sending response failed with error")(pending)

      it("should log when there were errors while sending resonse back to remote node")(pending)
    }

    describe("when reciving encrypted ProtocolHandshake") {

      it("should decrypt the frame") {
        // given
        keysStoreEff.put(remote, remoteKeys.pub)
        val receivedMessage =
          FrameMessage(frame(src, nonce, protocolHandshake(src, nonce).toByteArray), 1)
        // when
        Network.handleFrame[Effect](remote, receivedMessage)
        // then
        encryptionEff.decryptions should not be empty withClue ("decryption should be used")
        val (p, s, un, c) = encryptionEff.decryptions(0)
        p should equal(remoteKeys.pub) withClue ("remotes public should be used for decryption")
        s should equal(srcKeys.priv) withClue ("source private should be used for decryption")
        un should equal(nonce) withClue ("generated nounce should be used for decryption")
        Frameable
          .parseFrom(c)
          .message
          .protocolHandshake
          .map(_.nonce.toByteArray)
          .get should equal(nonce) withClue ("framed massaged should be ProtocolHandshake with nonce in it")
      }

      it("should encrypt protocol handshake response")(pending)

      it("should send encrypted protocol handshake response back to the remote") {
        // given
        keysStoreEff.put(remote, remoteKeys.pub)
        val receivedMessage =
          FrameMessage(frame(src, nonce, protocolHandshake(src, nonce).toByteArray), 1)
        // when
        Network.handleFrame[Effect](remote, receivedMessage)
        // then
        val FrameMessage(proto, _)  = communicationEff.requests(0)
        val Right(Frame(n, framed)) = toFrame(proto)
        n.toByteArray should equal(nonce)
      }
      it("should add node once protocol handshake response is sent")(pending)
      it("should not respond if message can not be decrypted")(pending)
      it("should not respond if it does not contain remotes public key")(pending)
    }

  }

  private def value[A](ea: Effect[A]): A = ea.value.right.get

  private val fstPhase: PartialFunction[ProtocolMessage, CommErr[ProtocolMessage]] = {
    case hs @ EncryptionHandshakeMessage(_, _) =>
      hs.response[Effect](remote, remoteKeys).value.right.get
  }

  private val sndPhase: PartialFunction[ProtocolMessage, CommErr[ProtocolMessage]] = {
    case hs @ FrameMessage(_, _) => Left(unknownProtocol("unknown")) //hs.response(remote)
  }

  private def generateResponses(
      fstPhase: PartialFunction[ProtocolMessage, CommErr[ProtocolMessage]],
      sndPhase: PartialFunction[ProtocolMessage, CommErr[ProtocolMessage]])
    : ProtocolMessage => CommErr[ProtocolMessage] =
    fstPhase orElse sndPhase

  private val roundTripNOP =
    kp2[ProtocolMessage, ProtocolNode, CommErr[ProtocolMessage]](Left(unknownProtocol("unknown")))
  private def endpoint(port: Int): Endpoint = Endpoint("host", port, port)

  private def protocolNode(name: String, port: Int): ProtocolNode =
    ProtocolNode(new PeerNode(NodeIdentifier(name.getBytes), endpoint(port)), roundTripNOP)
}
