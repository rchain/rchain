package coop.rchain.p2p

import org.scalatest._
import coop.rchain.comm.protocol.rchain._
import com.google.common.io.BaseEncoding
import coop.rchain.comm._, CommError._, NetworkProtocol._, Network.defaultTimeout
import coop.rchain.p2p.effects._
import cats._, cats.data._, cats.implicits._
import coop.rchain.catscontrib._, Catscontrib._, ski._, Encryption._
import coop.rchain.metrics.Metrics

import EffectsTestInstances._

class ProtocolSpec extends FunSpec with Matchers with BeforeAndAfterEach with AppendedClues {

  val encoder = BaseEncoding.base16().lowerCase()

  val src: PeerNode    = peerNode("src", 30300)
  val remote: PeerNode = peerNode("remote", 30301)
  val srcKeys          = PublicPrivateKeys(encoder.decode("ff00ff00"), encoder.decode("cc00cc00"))
  val remoteKeys       = PublicPrivateKeys(encoder.decode("ee00ee00"), encoder.decode("dd00dd00"))
  val nonce            = encoder.decode("00112233")

  type Effect[A] = CommErrT[Id, A]

  implicit val logEff            = new Log.NOPLog[Effect]
  implicit val timeEff           = new LogicalTime[Effect]
  implicit val metricEff         = new Metrics.MetricsNOP[Effect]
  implicit val nodeDiscoveryEff  = new NodeDiscoveryStub[Effect]()
  implicit val transportLayerEff = new TransportLayerStub[Effect](src)
  implicit val encryptionEff     = new EncryptionStub[Effect](srcKeys, nonce)
  implicit val keysStoreEff      = new Kvs.InMemoryKvs[Effect, PeerNode, Key]
  implicit val packetHandler     = new PacketHandler.NOPPacketHandler[Effect]

  override def beforeEach(): Unit = {
    nodeDiscoveryEff.reset()
    transportLayerEff.reset()
    encryptionEff.reset()
    keysStoreEff.keys.map(_.map(k => keysStoreEff.delete(k)))
  }

  describe("Node") {

    describe("when connecting to other remote node") {

      describe(" to which he was not connect in the past") {

        it("should first send EncryptionHanshakeMessage with its public key") {
          // given
          transportLayerEff.setResponses(kp(generateResponses(fstPhase, sndPhaseSucc)))
          // when
          Network.connect[Effect](remote, defaultTimeout)
          // then
          val EncryptionHandshakeMessage(proto, _) = transportLayerEff.requests.head
          val Right(EncryptionHandshake(pk))       = NetworkProtocol.toEncryptionHandshake(proto)
          pk.toByteArray should equal(srcKeys.pub)
        }

        it("should then store remote's public key") {
          // given
          transportLayerEff.setResponses(kp(generateResponses(fstPhase, sndPhaseSucc)))
          // when
          Network.connect[Effect](remote, defaultTimeout)
          // then
          value(keysStoreEff.get(remote)).get should equal(remoteKeys.pub)
        }

        it("should then send encrypted ProtocolMessage") {
          // given
          transportLayerEff.setResponses(kp(generateResponses(fstPhase, sndPhaseSucc)))
          // when
          Network.connect[Effect](remote, defaultTimeout)
          // then
          val FrameMessage(proto, _) = transportLayerEff.requests(1)
          val Right(Frame(n, f))     = NetworkProtocol.toFrame(proto)

          n.toByteArray should equal(nonce) withClue "nonce send should be equal to the one generated by Encryption"
          val (p, s, un, _) = encryptionEff.encryptions.head
          p should equal(remoteKeys.pub) withClue "remotes public should be used for encryption"
          s should equal(srcKeys.priv) withClue "source private should be used for encryption"
          un should equal(nonce) withClue "generated nounce should be used for encryption"
          Frameable
            .parseFrom(f.toByteArray)
            .message
            .protocolHandshake
            .map(_.nonce.toByteArray)
            .get should equal(nonce) withClue "framed massaged should be ProtocolHandshake with nonce in it"
        }

        it("should then add remote node to communication layer") {
          // given
          transportLayerEff.setResponses(kp(generateResponses(fstPhase, sndPhaseSucc)))
          // when
          Network.connect[Effect](remote, defaultTimeout)
          // then
          nodeDiscoveryEff.nodes should not be empty
        }
      }

      describe(" to which he was connected in the past") {
        it("should skip encryption handshake") {
          // given
          transportLayerEff.setResponses(kp(generateResponses(fstPhase, sndPhaseSucc)))
          keysStoreEff.put(remote, remoteKeys.pub)
          // when
          Network.connect[Effect](remote, defaultTimeout)
          // then
          transportLayerEff.requests.head should not be an[EncryptionHandshakeMessage]
        }
        it("should init protocol handshake") {
          // given
          transportLayerEff.setResponses(kp(generateResponses(fstPhase, sndPhaseSucc)))
          keysStoreEff.put(remote, remoteKeys.pub)
          // when
          Network.connect[Effect](remote, defaultTimeout)
          // then
          val FrameMessage(proto, _) = transportLayerEff.requests.head
          val Right(Frame(n, f))     = NetworkProtocol.toFrame(proto)

          n.toByteArray should equal(nonce) withClue "nonce send should be equal to the one generated by Encryption"
          val (p, s, un, _) = encryptionEff.encryptions.head
          p should equal(remoteKeys.pub) withClue "remotes public should be used for encryption"
          s should equal(srcKeys.priv) withClue "source private should be used for encryption"
          un should equal(nonce) withClue "generated nounce should be used for encryption"
          Frameable
            .parseFrom(f.toByteArray)
            .message
            .protocolHandshake
            .map(_.nonce.toByteArray)
            .get should equal(nonce) withClue "framed massaged should be ProtocolHandshake with nonce in it"
        }

        it("should then add remote node to communication layer") {
          // given
          transportLayerEff.setResponses(kp(generateResponses(fstPhase, sndPhaseSucc)))
          keysStoreEff.put(remote, remoteKeys.pub)
          // when
          Network.connect[Effect](remote, defaultTimeout)
          // then
          nodeDiscoveryEff.nodes should not be empty
        }

        it("should rollback to encryption handshake if initialized protocol handshake did not respond") {
          // given
          transportLayerEff.setResponses(kp(generateResponses(fstPhase, sndPhaseFailure)))
          keysStoreEff.put(remote, remoteKeys.pub)
          // when
          Network.connect[Effect](remote, defaultTimeout)
          // then
          transportLayerEff.requests.head should be(an[FrameMessage])
          transportLayerEff.requests(1) should be(an[EncryptionHandshakeMessage])
          transportLayerEff.requests(2) should be(an[FrameMessage])
        }
      }
    }

    describe("when receiving encryption handshake from remote node") {
      it("should send back its public key in response") {
        // given
        val receivedMessage =
          EncryptionHandshakeMessage(encryptionHandshake(src, remoteKeys), 1)
        // when
        val HandledWithMessage(EncryptionHandshakeResponseMessage(proto, _)) =
          Network.handleEncryptionHandshake[Effect](remote, receivedMessage).value.right.get
        // then
        val Right(EncryptionHandshakeResponse(pk)) =
          NetworkProtocol.toEncryptionHandshakeResponse(proto)
        pk.toByteArray should equal(srcKeys.pub)
      }

      it("should store remote's public key") {
        // given
        val receivedMessage =
          EncryptionHandshakeMessage(encryptionHandshake(src, remoteKeys), 1)
        // when
        Network.handleEncryptionHandshake[Effect](remote, receivedMessage)
        // then
        value(keysStoreEff.get(remote)).map(_.toList) should equal(Some(remoteKeys.pub.toList))
      }

      it("should not store remote's public key if sending response failed with error")(pending)

      it("should log when there were errors while sending resonse back to remote node")(pending)
    }

    describe("when reciving encrypted ProtocolHandshake") {

      it("should decrypt the frame") {
        // given
        keysStoreEff.put(remote, remoteKeys.pub)
        val receivedMessage =
          FrameMessage(frame(src, nonce, protocolHandshake(src, nonce).toByteArray), 1)
        // when
        Network.handleFrame[Effect](remote, receivedMessage)
        // then
        encryptionEff.decryptions should not be empty withClue "decryption should be used"
        val (p, s, un, c) = encryptionEff.decryptions.head
        p should equal(remoteKeys.pub) withClue "remotes public should be used for decryption"
        s should equal(srcKeys.priv) withClue "source private should be used for decryption"
        un should equal(nonce) withClue "generated nounce should be used for decryption"
        Frameable
          .parseFrom(c)
          .message
          .protocolHandshake
          .map(_.nonce.toByteArray)
          .get should equal(nonce) withClue "framed massaged should be ProtocolHandshake with nonce in it"
      }

      it("should encrypt protocol handshake response")(pending)

      it("should send encrypted protocol handshake response back to the remote") {
        // given
        keysStoreEff.put(remote, remoteKeys.pub)
        val receivedMessage =
          FrameMessage(frame(src, nonce, protocolHandshake(src, nonce).toByteArray), 1)
        // when
        val HandledWithMessage(FrameMessage(proto, _)) =
          Network.handleFrame[Effect](remote, receivedMessage).value.right.get
        // then
        val Right(Frame(n, _)) = toFrame(proto)
        n.toByteArray should equal(nonce)
      }
      it("should add node once protocol handshake response is sent")(pending)
      it("should not respond if message can not be decrypted")(pending)
      it("should not respond if it does not contain remotes public key")(pending)
    }

  }

  private def value[A](ea: Effect[A]): A = ea.value.right.get

  private val fstPhase: PartialFunction[ProtocolMessage, CommErr[ProtocolMessage]] = {
    case hs @ EncryptionHandshakeMessage(_, _) =>
      hs.response[Effect](remote, remoteKeys).value.right.get
  }

  private val sndPhaseSucc: PartialFunction[ProtocolMessage, CommErr[ProtocolMessage]] = {
    case hs @ FrameMessage(_, _) =>
      Right(
        FrameMessage(frameResponse(remote, hs.header.get, Array.empty[Byte], Array.empty[Byte]), 1))
  }

  private val sndPhaseFailure: PartialFunction[ProtocolMessage, CommErr[ProtocolMessage]] = {
    case FrameMessage(_, _) => Left(unknownProtocol("unknown"))
  }

  private def generateResponses(
      fstPhase: PartialFunction[ProtocolMessage, CommErr[ProtocolMessage]],
      sndPhase: PartialFunction[ProtocolMessage, CommErr[ProtocolMessage]])
    : ProtocolMessage => CommErr[ProtocolMessage] =
    fstPhase orElse sndPhase

  private def endpoint(port: Int): Endpoint = Endpoint("host", port, port)

  private def peerNode(name: String, port: Int): PeerNode =
    PeerNode(NodeIdentifier(name.getBytes), endpoint(port))

}
